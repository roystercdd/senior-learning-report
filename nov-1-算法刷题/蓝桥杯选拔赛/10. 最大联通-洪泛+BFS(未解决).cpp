#include<bits/stdc++.h>
#define x first
#define y second

using namespace std;

typedef long long LL;
typedef pair<int,int> PII;

/*
  解题思路: 我就说我这洪泛怎么有问题, 原来题目问的是最大联通块的块数大小!!!
  
 */

const int N=30+5;
const int dx[]={0,1,-1,0,0};
const int dy[]={0,0,0,1,-1};

int n=30,m=60;
char g[N][N*2]; // 地图

// 从(i,j)开始bfs
int bfs(int i,int j) {
	queue<PII> q;
	q.push({i,j});
	int cnt=0;
	
	while(!q.empty()) {
		PII t=q.front();
		q.pop();
		cnt++;
		g[t.x][t.y]='0';
		// 四方
		for(int i=1;i<=4;i++) {
			int xx=t.x+dx[i];
			int yy=t.y+dy[i];
			// 1) 越界
			if(xx<1 || yy<1 || xx>n || yy>m) continue;
			// 2) 不是1
			if(g[xx][yy]=='0') continue;
			// 加入队列
			q.push({xx,yy});
		}
	}

	return cnt;
}

string s;

int main() {
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cin>>g[i][j];
		}	
	}
	puts("");
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cout<<g[i][j];
		}	
		puts("");
	}
	int mmax=INT_MIN;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			// 使用标记代替状态数组
			if(g[i][j]=='1') {
				int tmp=bfs(i,j);
				mmax=max(mmax,tmp); // 更新
			}
		}	
	}
	cout<<mmax<<'\n';
	return 0;
}

/*
输入样例:
110010000011111110101001001001101010111011011011101001111110
010000000001010001101100000010010110001111100010101100011110 
001011101000100011111111111010000010010101010111001000010100 
101100001101011101101011011001000110111111010000000110110000 
010101100100010000111000100111100110001110111101010011001011 
010011011010011110111101111001001001010111110001101000100011 
101001011000110100001101011000000110110110100100110111101011 
101111000000101000111001100010110000100110001001000101011001 
001110111010001011110000001111100001010101001110011010101110 
001010101000110001011111001010111111100110000011011111101010 
011111100011001110100101001011110011000101011000100111001011 
011010001101011110011011111010111110010100101000110111010110 
001110000111100100101110001011101010001100010111110111011011 
111100001000001100010110101100111001001111100100110000001101 
001110010000000111011110000011000010101000111000000110101101 
100100011101011111001101001010011111110010111101000010000111 
110010100110101100001101111101010011000110101100000110001010 
110101101100001110000100010001001010100010110100100001000011 
100100000100001101010101001101000101101000000101111110001010 
101101011010101000111110110000110100000010011111111100110010 
101111000100000100011000010001011111001010010001010110001010 
001010001110101010000100010011101001010101101101010111100101 
001111110000101100010111111100000100101010000001011101100001 
101011110010000010010110000100001010011111100011011000110010 
011110010100011101100101111101000001011100001011010001110011 
000101000101000010010010110111000010101111001101100110011100 
100011100110011111000110011001111100001110110111001001000111 
111011000110001000110111011001011110010010010110101000011111 
011110011110110110011011001011010000100100101010110000010011 
010011110011100101010101111010001001001111101111101110011101
输出样例:

 */
