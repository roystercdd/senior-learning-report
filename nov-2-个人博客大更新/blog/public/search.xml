<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC自动机</title>
    <url>/2024/10/05/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="ac自动机">AC自动机</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a><ul>
<li><a href="#1-%E6%9E%84%E5%BB%BAtrie%E6%A0%91">1. 构建Trie树</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0ac%E8%87%AA%E5%8A%A8%E6%9C%BA">2. 构造AC自动机</a><ul>
<li><a href="#21-%E5%9B%9E%E8%B7%B3%E8%BE%B9">2.1. 回跳边</a></li>
<li><a href="#22-%E8%BD%AC%E7%A7%BB%E8%BE%B9">2.2. 转移边</a></li>
<li><a href="#23-%E7%94%A8bfs%E6%9E%84%E9%80%A0ac%E8%87%AA%E5%8A%A8%E6%9C%BA">2.3. 用BFS构造AC自动机</a></li>
</ul>
</li>
<li><a href="#3-%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">3. 查找单词出现次数</a></li>
<li><a href="#4-kmp%E4%B8%8Eac%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AF%B9%E6%AF%94">4. KMP与AC自动机对比</a></li>
<li><a href="#5-%E4%BE%8B%E6%B4%9B%E8%B0%B7p3808-ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95">5. 【例】洛谷P3808 AC自动机(简单)</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>跟学视频：<a href="https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F08【模板】AC自动机_</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>$AC$自动机是多模式匹配算法，给定$n$个模式串和一个主串，查找有多少个模式串在主串中出现过。</li>
</ul>
<blockquote>
<p>复习一下字典树吧：<a href="https://blog.csdn.net/qq_63586399/article/details/136725155?spm=1001.2014.3001.5502">【C++算法模板】字典树，超详细注释带例题讲解-CSDN博客</a></p>
</blockquote>
<h3><span id="1-构建trie树">1. 构建Trie树</span></h3><ul>
<li>我们先用n个模式串构造一颗Trie。</li>
<li>Trie中的一个节点表示一个从根到当前节点的字符串。</li>
<li>根节点表示空串，节点⑤表示“s”，节点6表示“sh”，节点7表示“she”。</li>
<li>如果节点是个模式串，则打个标记。例如，cnt[7]&#x3D;1。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213085433083.png" alt="image-20240213085433083"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树的insert函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123; <span class="comment">// 遍历主串</span></span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到下标0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 如果没有孩子节点,则创建一个</span></span><br><span class="line">		p=ch[p][j]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1,标记从根节点出发到该节点是一个模式串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="2-构造ac自动机">2. 构造AC自动机</span></h3><ul>
<li>构造AC自动机的过程就是在Trie树上构建两类边：<strong>回跳边</strong>和<strong>转移边</strong></li>
</ul>
<h4><span id="21-回跳边">2.1. 回跳边</span></h4><ul>
<li><p>开一个数组ne[]，ne[v] 存节点v的回跳边的终点，如：ne[7]&#x3D;3，表示节点7的回跳边的终点是3</p>
</li>
<li><p>回跳边指向<strong>父节点的回跳边所指节点的儿子</strong>，对于ne[7]&#x3D;3来说，7的父节点是6，6的子节点是3，所以7指向3，此时四个点$(v,u,ne[u],ch[][])$构成四边形</p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213091335787.png" alt="image-20240213091335787" style="zoom:80%;">
</li>
<li><p>并且回跳边所指节点一定是当前节点的<strong>最长后缀</strong>，cnt[7]&#x3D;1，代表模式串是she，cnt[3]&#x3D;1，代表模式串是he，此时he是she的最长后缀，下图中绿色边代表回跳边。</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213090937272.png" alt="image-20240213090937272" style="zoom:80%;">



<h4><span id="22-转移边">2.2. 转移边</span></h4><ul>
<li>转移边指向的是<strong>当前节点的回跳边所指节点的儿子</strong>，转移边和树边共同存储在数组$ch[][]$中<ul>
<li>$ch[u][i]$存节点u的树边的终点，如$ch[6][e]&#x3D;7$，节点6走e边到达节点7</li>
<li>$ch[u][i]$存节点u的转移边的终点，如$ch[7][r]$&#x3D;4，节点7的回跳边是3，节点3的儿子是节点4，注意上图中没有画出转移边，只有树边和回跳边</li>
</ul>
</li>
<li>此时三个点$(u,ne[u],ch[][])$构成三角形</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213092022148.png" alt="image-20240213092022148"></p>
<ul>
<li>转移边所指节点一定是当前节点的<strong>最短路</strong>，比如$ch[7][r]&#x3D;4$，那么从节点7到达节点4的最短路就是这条直通的r，而不是回溯到根节点再重新匹配到节点4</li>
</ul>
<h4><span id="23-用bfs构造ac自动机">2.3. 用BFS构造AC自动机</span></h4><ol>
<li>初始化，把根节点的儿子们入队（枚举26次，因为只有26个字母）</li>
<li>只要队不空，队头节点u出队，枚举u的26个儿子<ol>
<li>若儿子存在，则爹帮儿子建回跳边，并把儿子入队</li>
<li>若儿子不存在，则爹自建转移边</li>
</ol>
</li>
</ol>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213090937272.png" alt="image-20240213090937272" style="zoom:80%;">

<ul>
<li>上图对应的完整建边过程如下，这里只模拟节点1和节点2的建边过程：</li>
<li>1）对节点1：<ol>
<li>节点1出队，但是节点1下没有儿子，所以不用给他的儿子建回跳边，但是图中节点1的回跳边指向节点0，这是因为ne[]数组是全局变量默认初始化为0，或者可以这样想，根节点代表的是空串，此时节点1的最长后缀也就是空串</li>
<li>现在建转移边，因为节点1的父节点的儿子就是本身，所以建立26条转移边，有$ch[1][e]&#x3D;1$，既节点1的转移边指向自己，对于遍历到父节点的下一条树边h时，当前节点的转移边指向父节点的儿子，所以有$ch[1][h]&#x3D;2$，同理有$ch[1][s]&#x3D;5$，那么对于父节点0的其他边(即不存在的边)有$ch[1][···]&#x3D;0$，指向咱们的根节点</li>
</ol>
</li>
<li>2）对节点2：<ol>
<li>节点2出队，因为节点2下的有儿子节点3，所以先为节点3建立回跳边为节点3的父节点的回跳边指向的儿子，其实就是节点1，所以有$ne[3]&#x3D;1$，并且将节点3入队</li>
<li>因为只有这一个儿子，随后建立25条转移边，节点2的父节点0在e之后(因为e已经用于做最长后缀去建回跳边了)的树边有h和s，对h和s建立回跳边的过程同上，所以有$ch[2][h]&#x3D;2$、$ch[2][s]&#x3D;5$、$ch[2][···]&#x3D;0$</li>
</ol>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213094042809.png" alt="image-20240213094042809" style="zoom:80%;">

<ul>
<li>时间复杂度O(26n)，一共需要入队出队n个字符，n是模式串所有的总长度，每个节点都要枚举26次，要么帮儿子建回跳边，要么自己建转移边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 存储回跳边的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 1:将根节点的儿子入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">		<span class="keyword">if</span>(ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="comment">// 2:当队列非空,取队头,建回跳边和转移边</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> v=ch[u][i]; <span class="comment">// 取出儿子节点</span></span><br><span class="line">			<span class="comment">// 如果有儿子节点,构建v的回跳边为父节点的回跳边所指向的儿子</span></span><br><span class="line">			<span class="keyword">if</span>(v) ne[v]=ch[ne[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="comment">// 如果没有儿子节点,构建u的转移边为回跳边所指向节点的儿子</span></span><br><span class="line">			<span class="keyword">else</span> ch[u][i]=ch[ne[u]][i]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="3-查找单词出现次数">3. 查找单词出现次数</span></h3><ul>
<li><p>匹配的方式和$KMP$类似，是一个双指针匹配，首先扫描主串，依次取出字符s[k]</p>
</li>
<li><p>1）i 指针走主串对应的节点，沿着<strong>树边</strong>或<strong>转移边</strong>走，保证不回退</p>
</li>
<li><p>2）j 指针沿着<strong>回跳边</strong>搜索模式串，每次从当前节点走到根节点，把当前节点中的所有<strong>后缀模式串</strong>一网打尽，保证不漏解。</p>
</li>
<li><p>3）扫描完主串，返回答案</p>
</li>
<li><p>算法一边走串，一边把当前串的所有后缀串搜出来，实在是强，对于此过程的模拟，建议听原视频（因为太复杂了不想写）</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F08【模板】AC自动机_哔哩哔哩_bilibili</a>，从$24:48$ 开始</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213101043808.png" alt="image-20240213101043808"></p>
<ul>
<li>时间复杂度$O(n+m)$，m是主串长度，n是所有模式串的总长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找单词出现次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;s[k];k++) &#123;</span><br><span class="line">		i=ch[i][s[k]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// i指针指向s[k]这个字符对应的节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&amp;&amp;~cnt[j];j=ne[j]) <span class="comment">// j指针从当前指针开始,沿沿着回跳边跑</span></span><br><span class="line">			ans+=cnt[j],cnt[j]=<span class="number">-1</span>; <span class="comment">// 如果有标记,则累加答案,无论有无标记,都把标记清空,注意这里的写法不是固定的,如果题目要求出现几次就累计几次,那么cnt[j]是不用清空的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="4-kmp与ac自动机对比">4. KMP与AC自动机对比</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213102219322.png" alt="image-20240213102219322" style="zoom: 80%;">



<h3><span id="5-例洛谷p3808-ac自动机简单">5. 【例】洛谷P3808 AC自动机(简单)</span></h3><ul>
<li>给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过，当两个模式串编号不同时即视为不同的模式串。</li>
<li>注意：$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213103041931.png" alt="image-20240213103041931"></p>
<ul>
<li>注意：$s_1$，$s_2$，$s_4$ 都在串$abcd$里出现过</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213103223172.png" alt="image-20240213103223172" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 存储回跳边的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 模式串个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN=<span class="number">1e6</span><span class="number">+10</span>; <span class="comment">// 模式串最长长度</span></span><br><span class="line"><span class="type">char</span> str[MAX_LEN]; <span class="comment">// 存储模式串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树的insert函数,传入字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123; <span class="comment">// 遍历主串</span></span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到下标0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 如果没有孩子节点,则创建一个</span></span><br><span class="line">		p=ch[p][j]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1,标记从根节点出发到该节点是一个模式串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 1:将根节点的儿子入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">		<span class="keyword">if</span>(ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="comment">// 2:当队列非空,取队头,建回跳边和转移边</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> v=ch[u][i]; <span class="comment">// 取出儿子节点</span></span><br><span class="line">			<span class="comment">// 如果有儿子节点,构建v的回跳边为父节点的回跳边所指向的儿子</span></span><br><span class="line">			<span class="keyword">if</span>(v) ne[v]=ch[ne[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="comment">// 如果没有儿子节点,构建u的转移边为回跳边所指向节点的儿子</span></span><br><span class="line">			<span class="keyword">else</span> ch[u][i]=ch[ne[u]][i]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找单词出现次数,传入字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;s[k];k++) &#123;</span><br><span class="line">		i=ch[i][s[k]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// i指针指向s[k]这个字符对应的节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&amp;&amp;~cnt[j];j=ne[j]) <span class="comment">// j指针从当前指针开始,沿沿着回跳边跑</span></span><br><span class="line">			ans+=cnt[j],cnt[j]=<span class="number">-1</span>; <span class="comment">// 如果有标记,则累加答案,无论有无标记,都把标记清空,视情况嗷</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n; <span class="comment">// 模式串个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;str;	</span><br><span class="line">		<span class="built_in">insert</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>();</span><br><span class="line">	cin&gt;&gt;str; <span class="comment">// 输入主串</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">query</span>(str)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/10/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2024/10/07/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="kmp算法">KMP算法</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84">1. 求解next数组</a></li>
<li><a href="#2-%E6%B1%82%E8%A7%A3%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">2. 求解匹配位置的核心函数</a></li>
<li><a href="#3-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">3. 完整代码</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>在做模式串与文本串的匹配问题时，匹配失败时，如果每次都只向后递进一位，时间复杂度为 $O(n+m)$，很容易被卡成 $O(m×n)$ ，所以为了降低字符串匹配算法的时间复杂度，对模式串中的每一位，设置<strong>唯一</strong>的<strong>特定变化位置</strong>，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间</li>
<li><strong>如果主串已匹配相等的前缀序列中有某个后缀恰等于模式串的前缀，那么可以直接将模式串向后滑动到与这些相等字符对其的位置</strong>，用 $ne$ 数组记录到它为止的<strong>模式串前缀的真前缀和真后缀最大相同的位置</strong></li>
<li>当 $i&#x3D;1$ 或 $i&#x3D;2$ 时，$ne[i]$ 的返回值是 $1$，即 $ne[1]&#x3D;ne[2]&#x3D;1$ (当下标从 $1$ 开始)，因为当 $n&#x3D;1$ 时（只有一个元素，此时无前后缀），当 $n&#x3D;2$ 时（两个元素，一个是前缀一个是后缀，仍然回溯到第一个位置）</li>
</ul>
<h2><span id="1-求解next数组">1. 求解next数组</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求next数组的过程[s1与自己匹配,通过前后缀来更新ne数组]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s1[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">        j=ne[j]; <span class="comment">// 如果不匹配的话,j就一直后退</span></span><br><span class="line">    <span class="keyword">if</span>(s1[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">        j++; <span class="comment">// 如果当前匹配成功的,j向前递推一位</span></span><br><span class="line">    ne[i]=j; <span class="comment">// 记录并且更新当前j的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当看不懂或者忘了的时候建议自己调试模拟跟踪一遍</p>
</li>
<li><p>因为 $ne$ 数组是全局初始化，$while()$ 语句中的 $j$ 保证了 $ne[1]&#x3D;ne[2]$ </p>
</li>
<li><p>注意next数组的值是根据模式串的前缀和后缀的最大相同位置来的，所以匹配自己。</p>
</li>
</ul>
<h2><span id="2-求解匹配位置的核心函数">2. 求解匹配位置的核心函数</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求匹配的过程[i遍历文本串]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len2;i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果不匹配的话,j回退</span></span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s2[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="comment">// 如果相等的话,j向前递推一位</span></span><br><span class="line">    <span class="keyword">if</span>(s2[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 刚好长度相等的话说明匹配上了,把下标打印出来</span></span><br><span class="line">    <span class="keyword">if</span>(j==len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文本串的位置减去长度即为下标,加1得到位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-len1<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">        <span class="comment">// 需要让j回退到一定位置,再让i加1继续进行比较</span></span><br><span class="line">        <span class="comment">// 回退到ne[j]可以保证j最大,即已经成功匹配的部分最长</span></span><br><span class="line">        j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心实现和求解 $next$ 数组的函数差不多，主要是是模式串和文本串之间的匹配，当 $j&#x3D;&#x3D;len1$ 的时候说明大小相等即匹配上了，这个时候把相应的下标位置输出出来，同时 $j$ 还是要回溯，因为怕遇到位置重叠的情况。</li>
</ul>
<h2><span id="3-完整代码">3. 完整代码</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP - 洛谷</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> len1,len2; <span class="comment">// n是模板串长度,m是文本串</span></span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// next[i] 就是使子串 s2[0···i] 有最长相等前后缀的前缀的最后一位的下标</span></span><br><span class="line"><span class="type">char</span> s1[N],s2[N]; <span class="comment">// s1[]存储模式串,s2[]存储文本串</span></span><br><span class="line"><span class="comment">// 计算p[]在s[]中出现的位置</span></span><br><span class="line"><span class="comment">// ne代表next数组,因为next在C++中是关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;s1<span class="number">+1</span>&gt;&gt;s2<span class="number">+1</span>; <span class="comment">// 先输入模式串,再输入文本串[从下标1开始]</span></span><br><span class="line">	len1=<span class="built_in">strlen</span>(s1<span class="number">+1</span>);</span><br><span class="line">	len2=<span class="built_in">strlen</span>(s2<span class="number">+1</span>);</span><br><span class="line">	cout&lt;&lt;len1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;len2&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 求next数组的过程[s1与自己匹配,通过前后缀来更新ne数组]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s1[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j]; <span class="comment">// 如果不匹配的话,j就一直后退</span></span><br><span class="line">		<span class="keyword">if</span>(s1[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">			j++; <span class="comment">// 如果当前匹配成功的,j向前递推一位</span></span><br><span class="line">		ne[i]=j; <span class="comment">// 记录并且更新当前j的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求匹配的过程[i遍历文本串]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len2;i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果不匹配的话,j回退</span></span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s2[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j];</span><br><span class="line">		<span class="comment">// 如果相等的话,j向前递推一位</span></span><br><span class="line">		<span class="keyword">if</span>(s2[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">// 刚好长度相等的话说明匹配上了,把下标打印出来</span></span><br><span class="line">		<span class="keyword">if</span>(j==len1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 文本串的位置减去长度即为下标</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-len1);</span><br><span class="line">			<span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">			<span class="comment">// 需要让j回退到一定位置,再让i加1继续进行比较</span></span><br><span class="line">			<span class="comment">// 回退到ne[j]可以保证 j 最大,即已经成功匹配的部分最长</span></span><br><span class="line">			j=ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 还需要把next数组输出出来</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> num:ne) </span><br><span class="line">		cout&lt;&lt;num&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>lower_bound、upper_bound函数</title>
    <url>/2024/10/03/lower-bound%E3%80%81upper-bound%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="lower_bound和upper_bound">lower_bound和upper_bound</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8">2. 函数使用</a></li>
<li><a href="#3-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81">3. 案例代码</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-概述">1. 概述</span></h2><ul>
<li>$lower_bound()$ 和$upper_bound()$ 都是基于<strong>二分查找</strong>在一个<strong>排好序</strong>的数组或容器（如 $vector,\ list,\ set$ ）中进行快速查找的函数，位于 $<algorithm>$ 标准库中，由于采用二分查找，所以函数的时间复杂度是 $O(log_2^n)$</algorithm></li>
<li><strong>划重点！基于二分查找！数组或容器必须有序！</strong></li>
</ul>
<h2><span id="2-函数使用">2. 函数使用</span></h2><ul>
<li><p>$lower_bound(begin,end,num)$：适用于<strong>从小到大排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>大于等于</strong> $num$ 的数字</p>
<ul>
<li>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $lower_bound(arr,arr+n,3)-arr$ 表示在数组 $arr$ 中查找第一个大于等于 $3$ 的元素在数组中的下标</li>
<li>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</li>
</ul>
</li>
<li><p>$upper_bound(begin,end,num)$：适用于<strong>从小到大排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>大于</strong> $num$ 的数字</p>
<ul>
<li><p>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $upper_bound(arr,arr+n,3)-arr$ 表示在数组 $arr$ 中查找第一个大于 $3$ 的元素在数组中的下标</p>
</li>
<li><p>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</p>
</li>
</ul>
</li>
<li><p>$lower_bound(begin,end,num,greater<type>())$：适用于<strong>从大到小排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>小于等于</strong> $num$ 的数字</type></p>
<ul>
<li>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $lower_bound(arr,arr+n,3,greater<int>())-arr$ 表示在数组 $arr$ 中查找第一个小于等于 $3$ 的元素在数组中的下标</int></li>
<li>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</li>
</ul>
</li>
<li><p>$upper_bound(begin,end,num,greater<type>())$：适用于<strong>从大到小排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>小于</strong> $num$ 的数字</type></p>
<ul>
<li><p>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $upper_bound(arr,arr+n,3,greater<int>())-arr$ 表示在数组 $arr$ 中查找第一个小于 $3$ 的元素在数组中的下标</int></p>
</li>
<li><p>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</p>
</li>
</ul>
</li>
</ul>
<h2><span id="3-案例代码">3. 案例代码</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 升序</span></span><br><span class="line">	<span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	sort(arr,arr+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;序列为(从小到大排序):&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:arr) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 1.lower_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;lower_bound(arr,arr+<span class="number">5</span>,<span class="number">5</span>)-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个大于等于5的是5,下标是3</span></span><br><span class="line">	<span class="comment">// 2.upper_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;upper_bound(arr,arr+<span class="number">5</span>,<span class="number">6</span>)-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个大于6的是8,下标是4</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 降序</span></span><br><span class="line">	sort(arr,arr+<span class="number">5</span>,greater&lt;<span class="type">int</span>&gt;()); <span class="comment">// greater&lt;int&gt;()表示降序规则</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;序列为(从大到小排序):&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:arr) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 3.lower_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;lower_bound(arr,arr+<span class="number">5</span>,<span class="number">3</span>,greater&lt;<span class="type">int</span>&gt;())-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个小于等于3的是3,下标是2</span></span><br><span class="line">	<span class="comment">// 4.upper_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;upper_bound(arr,arr+<span class="number">5</span>,<span class="number">3</span>,greater&lt;<span class="type">int</span>&gt;())-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个小于等于3的是2,下标是3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>函数速查</tag>
      </tags>
  </entry>
  <entry>
    <title>strcmp、compare函数</title>
    <url>/2024/10/03/strcmp%E3%80%81compare%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="函数速查-strcmp-compare">函数速查-strcmp、compare</span></h1><!-- toc -->

<ul>
<li><a href="#1-strcmp">1. strcmp</a></li>
<li><a href="#2-compare">2. compare</a></li>
<li><a href="#3-%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2">3. 直接比较字符串</a></li>
<li><a href="#4-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83">4. 字符数组&#x2F;字符串按数值比较</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-strcmp">1. strcmp</span></h2><ul>
<li>用于字符数组之间的大小比较</li>
<li>比较原则：两个字符数组逐位比较$ASCII$码，首位$ASCII$码的更大的字符数组更大；当一个字符数组是另一个字符数组的前缀时，长度更长的字符数组更大</li>
<li>$strcmp(str1,str2)$，若前者比后者大，返回$1$，若相等，返回$0$，若后者比前者大，返回$-1$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str_1[<span class="number">20</span>],str_2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 1)逐位比较ASCII码,首位ASCII码更大的字符串更大</span></span><br><span class="line">	<span class="comment">// 前者比后者大,返回1 </span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;CDEF&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;BCDE&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 两者相等,返回0</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 前者比后者小,返回-1</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;bbcde&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 2)其中一个字符串是另一个字符串的前缀,长度更长的字符串更大</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-compare">2. compare</span></h2><ul>
<li>用于字符串之间的大小比较</li>
<li>比较原则：两个字符串逐位比较$ASCII$码，首位$ASCII$码的更大的字符串更大；当一个字符串是另一个字符串的前缀时，长度更长的字符串更大</li>
<li>$strcmp(str1,str2)$，若前者比后者大，返回$1$，若相等，返回$0$，若后者比前者大，返回$-1$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str_1,str_2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 前者比后者大,返回1</span></span><br><span class="line">	str_1=<span class="string">&quot;CDEF&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;BCDE&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 两者相等,返回0</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 前者比后者小,返回-1</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;bbcde&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 2)其中一个字符串是另一个字符串的前缀,长度更长的字符串更大</span></span><br><span class="line">	str_1=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3)比较特定位置开始的字符串</span></span><br><span class="line">	<span class="type">int</span> res_1=str_1.compare(<span class="number">1</span>,<span class="number">3</span>,str_2); <span class="comment">// str_1从下标1开始的3个字符与str_2比较大小</span></span><br><span class="line">	<span class="type">int</span> res_2=str_1.compare(<span class="number">1</span>,<span class="number">3</span>,str_2,<span class="number">1</span>,<span class="number">4</span>); <span class="comment">// str_1从下标1开始的3个字符与str_2从下标0开始的2个字符比较大小</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res_1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res_2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-直接比较字符串">3. 直接比较字符串</span></h2><ul>
<li>在$C++$中直接使用 $&gt;, &lt;, &#x3D;&#x3D;, &gt;&#x3D;, &lt;&#x3D; $这样的关系运算符也能比较字符串的大小，并且同样基于字符串中字符的字典顺序逐位字符比较，直到遇到不相同的字符或者一个字符串结束为止</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_compare</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前者比后者大&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a==b) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;二者一样大&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前者比后者小&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str_1,str_2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	str_1=<span class="string">&quot;CDEF&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;BCDE&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="comment">// 两者相等,返回0</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="comment">// 前者比后者小,返回-1</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;bbcde&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="comment">// 2)其中一个字符串是另一个字符串的前缀,长度更长的字符串更大</span></span><br><span class="line">	str_1=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-字符数组x2f字符串按数值比较">4. 字符数组&#x2F;字符串按数值比较</span></h2><ul>
<li><p>比如现在有两个数字， $123456$ 和 $23456$ ，并且是以字符形式存储到字符数组&#x2F;字符串中，现在要比较这两个字符数组&#x2F;字符串的大小关系如果直接使用前文的比较方法(按$ASCII$码逐位比较就会出问题)，因为$1$的$ASCII$码小于$2$，但很明显$123456&gt;23456$</p>
</li>
<li><p>如果在字符数组&#x2F;字符串中按下标对其的话又略嫌麻烦，显然是想让$123456$和$23456$都从下标$0$开始存储，这个时候我们可以(在没有前导$0$的情况下)返回长度更长的那个数字，当长度相等的时候直接用$strcmp$或者$compare$比较两个字符串即可</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[<span class="number">20</span>],str2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> str11,str22;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">chars_compare</span><span class="params">(<span class="type">char</span> str1[],<span class="type">char</span> str2[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> len1=<span class="built_in">strlen</span>(str1);</span><br><span class="line">	<span class="type">int</span> len2=<span class="built_in">strlen</span>(str2);</span><br><span class="line">	<span class="keyword">if</span>(len1!=len2) <span class="keyword">return</span> len1&gt;len2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(str1,str2)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">str_compare</span><span class="params">(<span class="built_in">string</span> str11,<span class="built_in">string</span> str22)</span> &#123;</span><br><span class="line">	<span class="type">int</span> len1=str11.length();</span><br><span class="line">	<span class="type">int</span> len2=str22.length();</span><br><span class="line">	<span class="keyword">if</span>(len1!=len2) <span class="keyword">return</span> len1&gt;len2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> str11.compare(str22)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 字符数组</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str1,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str2,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;chars_compare(str1,str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(str1,<span class="string">&quot;34&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str2,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;chars_compare(str1,str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 字符串</span></span><br><span class="line">	str11=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">	str22=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_compare(str11,str22)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	str11=<span class="string">&quot;34&quot;</span>;</span><br><span class="line">	str22=<span class="string">&quot;23&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_compare(str11,str22)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>函数速查</tag>
      </tags>
  </entry>
  <entry>
    <title>substr函数</title>
    <url>/2024/10/03/substr%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="函数速查-substr">函数速查-substr</span></h1><span id="more"></span>



<ul>
<li>$substr$ 函数用于截取字符串，$substr(pos,\ n)$ 指从指定字符串的 $pos$ 索引起向后截取 $n$ 个字符，具体使用方法见代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">string</span> s=<span class="string">&quot;01234567&quot;</span>; <span class="comment">// 索引从0开始</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s1=s.substr(); <span class="comment">// 1)不传参等价于复制字符串</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 01234567</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s2=s.substr(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 2)传递2个参数,截取从字符串s下标0开始往后的2个字符</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 01</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s3=s.substr(<span class="number">4</span>); <span class="comment">// 3)传递1个参数,截取s索引为4到字符串尾部</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4567</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s4=s.substr(<span class="number">8</span>); <span class="comment">// 4)若pos超过了string的大小,不抛出异常但没有输出</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 不输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s5=s.substr(<span class="number">2</span>,<span class="number">10</span>); <span class="comment">// 5)若pos+n超过了string的大小,则自动调整n的值,最多只截取到s的末尾</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s5&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 234567</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s6=s.substr(<span class="number">-1</span>); <span class="comment">// 6)pos传入负值,抛出out_of_range异常(RE运行时错误)</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s6&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 报错,RE</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s7=s.substr(<span class="number">3</span>,<span class="number">-2</span>); <span class="comment">// 7)n传入负值,则默认截取到字符串末尾</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s7&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 34567</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>函数速查</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/2024/10/04/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="二分图">二分图</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9F%93%E8%89%B2%E6%B3%95">1. 染色法</a></li>
<li><a href="#2-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95">2. 匈牙利算法</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>二分图当且仅当图中不含奇数环，可以把所有点划分成两边，使得所有的边都是在集合之间的，集合内没有边。</li>
</ul>
<img src="E:/Typora/%E5%9B%BE%E7%89%87/image-20240201103004073.png" alt="image-20240201103004073" style="zoom:80%;">

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240201103116146.png" alt="image-20240201103116146" style="zoom:80%;">



<p>​		如果图中存在奇数环，那么会出现下面这种自相矛盾的情况。</p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240201103038838.png" alt="image-20240201103038838">



<h2><span id="1-染色法">1. 染色法</span></h2><blockquote>
<p>时间复杂度O(n+m)，用于判断一个图是否为二分图</p>
</blockquote>
<p>只要图中不存在奇数环，染色过程就不会出现矛盾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染色法:</span></span><br><span class="line"><span class="comment">// for v=1~n: 如果没有染色,dfs(v)</span></span><br><span class="line"><span class="comment">// 宽搜和深搜都能实现,但是深搜代码短</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span><span class="number">+10</span>)*<span class="number">2</span>; <span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	color[u]=c; <span class="comment">// 把当前点染成c色</span></span><br><span class="line">	<span class="comment">// 遍历与u相连的所有边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="comment">// 取出相连的边的点</span></span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="comment">// 如果没有染色</span></span><br><span class="line">		<span class="keyword">if</span>(!color[j]) &#123;</span><br><span class="line">			<span class="comment">// 3-c:如果c为1,则3-c为2,表示染成2色;如果c为2,则3-c为1,表示染成1色</span></span><br><span class="line">			<span class="comment">// 如果无法像这样染色,则返回false</span></span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果颜色发生冲突,则直接返回false</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">add</span>(a,b);</span><br><span class="line">		<span class="built_in">add</span>(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">true</span>; <span class="comment">// 未发生冲突</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果没有染色</span></span><br><span class="line">		<span class="keyword">if</span>(!color[i]) &#123;</span><br><span class="line">			<span class="comment">// 如果深搜发生冲突(染色冲突)</span></span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>)) &#123;</span><br><span class="line">				flag=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4个点4条边</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">Yes</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-匈牙利算法">2. 匈牙利算法</span></h2><blockquote>
<p>时间复杂度O(mn)，实际执行时间远小于O(mn)：求二分图的最大匹配数</p>
</blockquote>
<ul>
<li><p>注意需要满足是二分图这个前提才能使用匈牙利算法。</p>
</li>
<li><p>下面这个图个人感觉有问题，应该是先 (1,5)，后找到 (2,8)，再找到 (3,5) 这时发现5已经被1占有，所以1退而求其次找到7，变为 (1,7)，对于4，只有 (4,8)，但2也仅与 8 相连，所以最大匹配数为3，匹配为：(1,7)、(2,8)、(3,5)</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240201103242589.png" alt="image-20240201103242589" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有两条边共用一个点,表示匹配</span></span><br><span class="line"><span class="comment">// 求图中的最大匹配数 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1,n2,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 去查找这个与这个点相连的所有边的点集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">			st[j]=<span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 如果这个点还没有和任何点匹配,并且也没有其他点与自身相连,则返回true</span></span><br><span class="line">			<span class="keyword">if</span>(match[j]==<span class="number">0</span> || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">				match[j]=x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">add</span>(a,b); <span class="comment">// 有向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>; <span class="comment">// 存放最终答案</span></span><br><span class="line">	<span class="comment">// 遍历二分图中n1这个点集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st); <span class="comment">// 用于寻找增广路径时重置st</span></span><br><span class="line">		<span class="comment">// 如果能找到匹配点,则res++</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">			res++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左边2点,右边2点,共4条边</span></span><br><span class="line"><span class="comment">1 1(表示左边点1和右边点1有边)</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">2 2 4</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2024/10/03/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="前缀和">前缀和</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">1. 一维前缀和</a></li>
<li><a href="#2-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">2. 二维前缀和</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>因为前缀和这个板子的推导比较简单，因此本博客重点在于知识点归纳而不在于证明</li>
</ul>
<h2><span id="1-一维前缀和">1. 一维前缀和</span></h2><ul>
<li>一维数组的前缀和计算公式：$s[i]&#x3D;\sum_{i&#x3D;1}^ia[i]&#x3D;s[i-1]+a[i]$，时间复杂度 $O(n)$</li>
<li>原数组 $[l,r]$ 区间和计算公式：$s[r]-s[l-1]$ ，时间复杂度 $O(1)$</li>
</ul>
<blockquote>
<p>【例题】AcWing 795，链接：<a href="https://www.acwing.com/problem/content/797/">795. 前缀和 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入规模超过1e5时推荐使用scanf而不是cin和cout</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h2><span id="2-二维前缀和">2. 二维前缀和</span></h2><ul>
<li>二维数组的前缀和计算公式：$s[i][j]&#x3D;\sum_{i&#x3D;1}^i\sum_{j&#x3D;1}^ja[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$，时间复杂度 $O(n^2)$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031156232.png" alt="image-20240316232827015"></p>
<ul>
<li>原数组 $(x_1,y_1)$ 到 $(x_2,y_2)$ 区间和计算公式：$s[x_2][y_2]-s[x_1-1][y_2]-s[x_2][y_1-1]+s[x_1-1][x_2-1]$ ，时间复杂度 $O(1)$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031156219.png" alt="image-20240316232908005"></p>
<blockquote>
<p>【例题】AcWing 796，链接：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/4324/">796. 子矩阵的和 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容斥原理:</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> s[N][N]; <span class="comment">// 二维前缀和矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">			<span class="comment">// 预处理二维前缀和数组</span></span><br><span class="line">			s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">		<span class="comment">// 算区间和</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>前缀和</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/2024/10/02/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="二分答案">二分答案</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E8%A7%A3%E4%BA%8C%E5%88%86%E9%A2%98%E6%AD%A5%E9%AA%A4">1. 解二分题步骤</a></li>
<li><a href="#2-%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86">2. 整数二分</a><ul>
<li><a href="#21-%E6%B4%9B%E8%B0%B7-p2440%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5">2.1. 洛谷 P2440.木材加工</a></li>
<li><a href="#22-%E6%B4%9B%E8%B0%B7-p1873eko%E7%A0%8D%E6%A0%91">2.2. 洛谷 P1873.EKO&#x2F;砍树</a></li>
<li><a href="#23-%E6%B4%9B%E8%B0%B7-p1678%E7%83%A6%E6%81%BC%E7%9A%84%E9%AB%98%E8%80%83%E5%BF%97%E6%84%BF">2.3. 洛谷 P1678.烦恼的高考志愿</a></li>
<li><a href="#24-%E8%93%9D%E6%A1%A5%E6%9D%AF-23%E7%9C%81b-%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E">2.4. 蓝桥杯 23省b 冶炼金属</a></li>
</ul>
</li>
<li><a href="#3-%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86">3. 浮点二分</a><ul>
<li><a href="#31-acwing-790-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9">3.1. AcWing 790. 数的三次方根</a></li>
</ul>
</li>
<li><a href="#4-%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3">4. 加深理解</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>将答案区间进行二分搜索， 每次取区间中间值出来用于尝试是否满足题目性质，不断缩小调整区间，直到确定最终答案为止</li>
<li>有单调性的题目一定可以二分，但是用二分做的题目不一定拥有单调性。</li>
<li>注意：二分一定是有解的，不可能无解，无解永远是题目的无解而不是二分的无解。</li>
</ul>
<h2><span id="1-解二分题步骤">1. 解二分题步骤</span></h2><ul>
<li>题目出现求最值，首先想到二分&#x2F;贪心&#x2F;动态规划等算法</li>
<li>题目具有单调性，则可以考虑用二分求解</li>
<li>若求满足某个性质的数第一次出现，或求最小值 → 答案在左边 → 满足性质时压缩右边界 → 二分出来的答案一定在 $l$ 上</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案在左边</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 压缩右边界</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 答案在左边界上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>若求满足某个性质的数最后一次出现，或求最大值 → 答案在右边 → 满足性质时压缩左边界 → 二分出来的答案一定在 $r$ 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案在右边</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 压缩左边界</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;r&lt;&lt;endl; <span class="comment">// 答案在右边界上</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-整数二分">2. 整数二分</span></h2><h3><span id="21-洛谷-p2440木材加工">2.1. 洛谷 P2440.木材加工</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2440">P2440 木材加工 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 原木/要的根数</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 每根木头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果切出来的数量满足k根说明切够了</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cnt+=a[i]/x;</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="type">int</span> mmax;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		mmax=max(mmax,a[i]); <span class="comment">// 找最大木头数,作为r的初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>; <span class="comment">// 此时切出来最多,每根都能切成a[i]份</span></span><br><span class="line">	<span class="type">int</span> r=mmax; <span class="comment">// 此时切出来最少,只能切一根</span></span><br><span class="line">	<span class="comment">// 找最大值,答案在右边,压缩左边界,答案在r上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 答案一定在r上且r一定比l小1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-洛谷-p1873ekox2f砍树">2.2. 洛谷 P1873.EKO&#x2F;砍树</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO &#x2F; 砍树 - 洛谷 </a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n:树的数量,m:所需总长度</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 存储每棵树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	ll cnt=<span class="number">0</span>; <span class="comment">// 切出来的长度爆int,题目也说超过M</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-x&gt;<span class="number">0</span>)</span><br><span class="line">			cnt+=a[i]-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> mmax; <span class="comment">// 存储最大高度作为r的初始值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		mmax=max(mmax,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>; <span class="comment">// 此时每棵树能切出来的长度都是a[i],切得最多</span></span><br><span class="line">	<span class="type">int</span> r=mmax; <span class="comment">// 此时每棵树能切出来的高度都是0,切得最少</span></span><br><span class="line">	<span class="comment">// l能取0吗?如果停在l=0,那么r一定等于-1,此时有问题</span></span><br><span class="line">	<span class="comment">// 找锯片的最大高度,压缩左边界,答案在r上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-洛谷-p1678烦恼的高考志愿">2.3. 洛谷 P1678.烦恼的高考志愿</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1678">P1678 烦恼的高考志愿 - 洛谷 </a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 开ll不然过不了</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll a[N]; <span class="comment">// 存储学校的分数线</span></span><br><span class="line">ll b[N]; <span class="comment">// 存储每个同学的估分</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// n个学校,m个同学</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	ll cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 遍历所有同学</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="comment">// 卫语言风格</span></span><br><span class="line">		<span class="comment">// 比最小值还小,跳过</span></span><br><span class="line">		<span class="keyword">if</span>(b[i]&lt;=a[<span class="number">1</span>]) &#123;</span><br><span class="line">			cnt+=<span class="built_in">abs</span>(b[i]-a[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b[i]&gt;=a[n]) &#123;</span><br><span class="line">			cnt+=<span class="built_in">abs</span>(b[i]-a[n]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll l=<span class="number">1</span>,r=n; <span class="comment">// 边界是[1,n]</span></span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">			ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 注意找第一个是答案在左边的问题,所以要压缩右边界</span></span><br><span class="line">			<span class="comment">// 找第一个大于等于b[i]的第一个学校的分数线,答案在左边,即a[l]</span></span><br><span class="line">			<span class="comment">// 那么最后一个小于b[i]的元素的下标就应该是a[l-1]</span></span><br><span class="line">			<span class="keyword">if</span>(a[mid]&gt;=b[i])</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取二者之中的最小值</span></span><br><span class="line">		cnt+=min(<span class="built_in">abs</span>(a[l]-b[i]),<span class="built_in">abs</span>(a[l<span class="number">-1</span>]-b[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="24-蓝桥杯-23省b-冶炼金属">2.4. 蓝桥杯 23省b 冶炼金属</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P9240">P9240 [蓝桥杯 2023 省 B] 冶炼金属 </a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 存储每次投入的金属数量</span></span><br><span class="line"><span class="type">int</span> b[N]; <span class="comment">// 存储每次冶炼出的特殊金属数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_1</span><span class="params">(<span class="type">int</span> mid)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]/mid&gt;b[i])	</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_2</span><span class="params">(<span class="type">int</span> mid)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]/mid&lt;b[i])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> mmax=INT_MIN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]);	</span><br><span class="line">		mmax=max(mmax,a[i]); <span class="comment">// 最大的普通金属数量</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;最大值是&quot;&lt;&lt;mmax&lt;&lt;endl;</span></span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>; <span class="comment">// 转换率最小为1,有多少转换多少</span></span><br><span class="line">	<span class="type">int</span> r=mmax; <span class="comment">// 最小只能转换出一个</span></span><br><span class="line">	<span class="comment">// 找最小值,压缩右边界,答案在l上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=(ll)l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check_1(mid)) &#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	l=<span class="number">1</span>,r=mmax;</span><br><span class="line">	<span class="comment">// 找最大值,压缩左边界,答案在r上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=(ll)l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check_2(mid)) &#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-浮点二分">3. 浮点二分</span></h2><h3><span id="31-acwing-790-数的三次方根">3.1. AcWing 790. 数的三次方根</span></h3><blockquote>
<p>题目链接：<a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根 - AcWing题库</a></p>
</blockquote>
<ul>
<li>对于开二次方根，因为开出来一定是正数，所以可以设置$l&#x3D;0$，$r&#x3D;x$，但是三次方根可能有负数，不能单纯的取 $l&#x3D;-x$，$r&#x3D;x$，这样的话输入的$x$是正数，范围是$[-x,x]$，输入的数是负数，范围是$[x,-x]$就会出大问题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> x;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="comment">// 因为是开三次方根,所以要考虑负数的情况</span></span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">	<span class="type">double</span> l=<span class="number">-100000</span>,r=<span class="number">100000</span>;</span><br><span class="line">	<span class="comment">// 保留6位小数就1e-8(基于经验),同理保留4位就1e-6</span></span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>) &#123;</span><br><span class="line">		<span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid*mid*mid&gt;=x)</span><br><span class="line">			r=mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;fixed&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-加深理解">4. 加深理解</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;下标:&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;数值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">10</span>; <span class="comment">// 下标边界</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 1)找第一个大于等于3的元素的下标,看是3还是4呢?</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&gt;=<span class="number">3</span>) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1)找第一个大于等于3的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 找最小值,答案是l,r一定是l-1</span></span><br><span class="line">	<span class="comment">// 2)找第一个大于3的元素的下标,是5吧而不是6吧</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&gt;<span class="number">3</span>) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;2)找第一个大于3的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 3)找第一个大于等于2且小于等于4的元素的下标,是5而不是4吧</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>&lt;=a[mid] &amp;&amp; a[mid]&lt;=<span class="number">4</span>) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;3)找第一个大于等于2且小于等于4的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 4)找最后一个小于等于4的元素</span></span><br><span class="line">	<span class="comment">// 压缩l,答案一定在r上,此时l必为r+1</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;=<span class="number">4</span>) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;4)找最后一个小于等于4的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 5)找最后一个小于6的元素,下标为7,答案在r</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;<span class="number">7</span>) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;5)找最后一个小于6的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 6)找最后一个大于2且小于等于8的元素,值是8</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&gt;<span class="number">2</span> &amp;&amp; a[mid]&lt;=<span class="number">8</span>) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;6)找最后一个大于2且小于等于8的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2024/10/07/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="乘法逆元">乘法逆元</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9D%BF%E5%AD%90">1. 板子</a></li>
<li><a href="#2-%E6%80%A7%E8%B4%A8">2. 性质</a></li>
<li><a href="#3-%E7%BA%BF%E6%80%A7%E6%B1%82%E9%80%86%E5%85%83%E6%9D%BF%E5%AD%90">3. 线性求逆元板子</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>同余式：如果 $a,b$ 模 $m$ 的余数相同，则称 $a,b$ 模 $m$ 同余，记为 $a\equiv b$，例如：$8 \equiv 2\ (mod\ 3)$</p>
</li>
<li><p>乘法逆元：若 $a,b$ 互质，且满足同余方程 $ax\equiv 1\ (mod \ b)$，则称 $x$ 为 $a\ mod \ b$ 的乘法逆元，记作 $a^{-1}$，例如：$8x \equiv 1\ (mod\ 5)$，解得 $x&#x3D;2,7,12…$</p>
</li>
<li><p>费马小定理：若 $p$ 为质数，且 $a,p$ 互质，则 $a^{p-1}\equiv1\ (mod\ p)$，例如：$4^{3-1}\equiv 1(mod\ 3)$</p>
</li>
<li><p>费马小定理求乘法逆元：$a^{p-1}\equiv1\ (mod\ p)$，得 $a×a^{p-2}\equiv 1\ (mod\ p)$，根据乘法逆元的定义，所以 $a^{p-2}$ 就是 $a$ 模 $p$ 的乘法逆元</p>
</li>
</ul>
<h2><span id="1-板子">1. 板子</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂取余,a^b%p</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>; <span class="comment">// 累乘因子</span></span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*a%p; <span class="comment">// 提权</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;p;</span><br><span class="line">    <span class="comment">// 快速幂计算a^(p-2),就是a%p的乘法逆元</span></span><br><span class="line">    <span class="comment">// 如果a,p互质,才有a%p乘法逆元</span></span><br><span class="line">    <span class="keyword">if</span>(a%p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qmi(a,p<span class="number">-2</span>,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-性质">2. 性质</span></h2><ul>
<li><p>$14&#x2F;4\ (mod\ 5)&#x3D;7&#x2F;2 \ (mod\ 5)&#x3D;7×3\ (mod\ 5)$，这是因为 $2×3\ mod\ 5&#x3D;1$，也可以理解为 $3$ 和 $2$ 在模 $5$ 下互为倒数</p>
</li>
<li><p>求乘法逆元的方法：$2^{-1} \ mod\ 7$，模  $7$ 下 $2$ 的乘法逆元是，求谁乘以 $2$ 再模 $7$ 等于 $1$，很容易口算得到 $4×2\ (mod\ 7)&#x3D;1$</p>
<ul>
<li>通过费马小定理计算，$a^{p-2}$ 即 $2^{7-2}&#x3D;32$</li>
<li>模 $n$ 下互为乘法逆元，一般只考虑比 $n$ 小的，所以 $32$ 对 $7$ 取模得到 $4$，那么模 $7$ 下 $2$ 的乘法逆元是 $4$</li>
</ul>
</li>
<li><p>$a$ 在模 $n$ 内的乘法逆元 $a^{-1}\ (1&lt;&#x3D;a^{-1}&lt;n)$ 是唯一的，比如模 $5$ 下 $2$ 和 $3$ 互为乘法逆元，除此外再无别的逆元</p>
</li>
<li><p>$1$  不管模谁都是余 $1$</p>
</li>
<li><p>$a$ 的乘法逆元的乘法逆元是 $a$，$z&#x3D;a^{-1},\ z^{-1}&#x3D;(a^{-1})^{-1}&#x3D;a$</p>
</li>
<li><p><strong>什么时候用乘法逆元？当题目中推导出来的公式带有除法，并且要让结果对某个数作模运算时</strong>，应用乘法逆元把除法变为乘法，一直除再作模运算是会出错的，可以这样想，加减乘都是从低位起开始运算，只有除法是从高位开始运算，而模运算又是取低几位，所以应该把除法转换为乘法</p>
</li>
</ul>
<h2><span id="3-线性求逆元板子">3. 线性求逆元板子</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">3e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="comment">// 给定n,p,计算1~n中所有整数在模p意义下的乘法逆元</span></span><br><span class="line"><span class="comment">// a模p的乘法逆元定义为 a*a_inv等价于1(mod p),去找a_inv是多少</span></span><br><span class="line"><span class="comment">// 线性求逆元</span></span><br><span class="line"><span class="type">int</span> inv[maxn]; <span class="comment">// 存储每个数字的逆元</span></span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,p;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p; <span class="comment">// n是范围,p是模数</span></span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">// 1的逆元是1, (1*1)mod p=1</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;inv[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		inv[i]=-(p/i)*inv[p%i]; <span class="comment">// x_inv=-k*r_inv (怎么推导的···看b站视频吧)</span></span><br><span class="line">		inv[i]=(inv[i]%p+p)%p; <span class="comment">// 防止负数产生</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;inv[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>乘法逆元</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>图论最短路</title>
    <url>/2024/10/04/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="图论最短路">图论最短路</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF">1. 单源最短路</a><ul>
<li><a href="#11-%E6%89%80%E6%9C%89%E8%BE%B9%E6%9D%83%E9%83%BD%E6%98%AF%E6%AD%A3%E6%95%B0">1.1. 所有边权都是正数</a><ul>
<li><a href="#111-%E6%9C%B4%E7%B4%A0-dijkstra-%E7%AE%97%E6%B3%95">1.1.1. 朴素 $Dijkstra$ 算法</a></li>
<li><a href="#112-%E5%A0%86%E4%BC%98%E5%8C%96-dijkstra">1.1.2. 堆优化 $Dijkstra$</a></li>
</ul>
</li>
<li><a href="#12-%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%9D%83%E8%BE%B9">1.2. 存在负权边</a><ul>
<li><a href="#121-bellman-ford">1.2.1. Bellman-Ford</a></li>
<li><a href="#122-spfa">1.2.2. SPFA</a></li>
<li><a href="#123-spfa%E5%88%A4%E8%B4%9F%E7%8E%AF">1.2.3. SPFA判负环</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%A4%9A%E6%BA%90%E6%B1%87%E6%9C%80%E7%9F%AD%E8%B7%AF">2. 多源汇最短路</a><ul>
<li><a href="#21-floyd%E7%AE%97%E6%B3%95">2.1. Floyd算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-单源最短路">1. 单源最短路</span></h2><blockquote>
<p>从一个点到其他所有点的最短距离</p>
</blockquote>
<ul>
<li>对于单源最短路径问题的时间复杂度和空间复杂度如下，对于空间复杂度需强调：对于稀疏图（边较少），倾向于使用<strong>邻接表</strong>和<strong>链式前向星</strong>，如果使用邻接矩阵容易爆内存；对于稠密图（边多），倾向于使用邻接矩阵，因为邻接表每个元素都是一个结点，占用的内存可能比邻接矩阵中的一格大，使用邻接矩阵反而内存占用更少。</li>
<li>注意，无向图是一种特殊的有向图，所以我们背板子的时候不用特别区分有向图和无向图。</li>
<li>对于<strong>稠密图</strong>（边的数量接近于顶点数量的平方），使用邻接矩阵的时间复杂度通常更低，因为你可以在 $O(1)$ 的时间内访问任何边。然而，邻接矩阵的空间复杂度是 $O(V^2)$ ，这可能会导致内存超限。</li>
<li>对于<strong>稀疏图</strong>（边的数量远小于顶点数量的平方），使用邻接表的时间复杂度通常更低，因为你只需要遍历与每个顶点相连的边。邻接表的空间复杂度是 $O(E)$ ，这通常比邻接矩阵更节省空间。</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231018161346568.png" alt="image-20231018161346568" style="zoom:67%;">



<h3><span id="11-所有边权都是正数">1.1. 所有边权都是正数</span></h3><h4><span id="111-朴素-dijkstra-算法">1.1.1. 朴素 $Dijkstra$ 算法</span></h4><blockquote>
<p>时间复杂度 $O(n²)$：$n$ 表示点的数量，和边数无关，适合稠密图，空间复杂度 $O(n^2)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素dijkstra</span></span><br><span class="line"><span class="comment">// 1:初始化距离,dist[1]=0,dist[v]=+inf,s是当前已经确定最短距离的点</span></span><br><span class="line"><span class="comment">// 2:for v in [1,n]:①不在s中的距离最近的点;②t→s;③用t更新其他点的距离</span></span><br><span class="line"><span class="comment">// 3:循环n次后,已经求出每个点到第一个点的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稠密图→邻接矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span><span class="number">+5</span>; </span><br><span class="line"><span class="comment">// 点最大是500*500=2.5*10^5&gt;题目给的m最大值</span></span><br><span class="line"><span class="comment">// 注意:存在重边和自环</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 每个点到第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 每个点的访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先把距离初始化为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 第一个点到自身的距离为0</span></span><br><span class="line">	<span class="comment">// 对于每一个结点,我们每遍历一次就把一个点加入到已经找到最短路径的队列中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="number">-1</span>; <span class="comment">// 初始化t为-1,t用于记录当前未被访问的结点中距离源节点最近的结点</span></span><br><span class="line">		<span class="comment">// 遍历所有结点,找到每个结点距离自己最近且尚未加入&quot;已经找到最短路径&quot;点集的结点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="comment">// !st[j]:结点j未被访问,t为-1,或者t到源节点的距离小于j到源节点的距离</span></span><br><span class="line">			<span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">				t=j;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果当前结点的最近结点就是n,那么直接跳出(优化意义不明显)</span></span><br><span class="line">		<span class="keyword">if</span>(t==n)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		st[t]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 以t为跳板,更新所有结点到源节点的最短距离</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不存在最短路返回-1,存在则返回最大距离值</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 初始化邻接矩阵为互不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=<span class="built_in">min</span>(g[a][b],c); <span class="comment">// 去除重边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="112-堆优化-dijkstra">1.1.2. 堆优化 $Dijkstra$</span></h4><blockquote>
<p>时间复杂度 $O(mlogn)$：$n$ 表示点的数量、$m$ 表示边的数量，适合稀疏图，空间复杂度 $O(m+n)$</p>
</blockquote>
<ul>
<li>该代码可以解决带有重边和自环的有向图、无向图。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// h:每个结点的第一条边</span></span><br><span class="line"><span class="comment">// e:每条边的下一个结点</span></span><br><span class="line"><span class="comment">// ne:每条边的下一条边</span></span><br><span class="line"><span class="comment">// w:每条边的权重</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 邻接表存储最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第idx条边指向节点b,第idx边边权为c,第idx条的下一条边是a的起始边(头插法思想),起始边更新为当前边编号,编号自增</span></span><br><span class="line">	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化互不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 编号为1的点到自己距离为0</span></span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; <span class="comment">// 小根堆</span></span><br><span class="line">	heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;); <span class="comment">// 距离为0,点编号为1(第一关键字存储距离,小根堆默认从小到大排序;第二关键字存储编号)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 队列不为空</span></span><br><span class="line">	<span class="keyword">while</span>(heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// 取出头结点</span></span><br><span class="line">		<span class="keyword">auto</span> t=heap.<span class="built_in">top</span>();</span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// v:取出头结点的编号</span></span><br><span class="line">		<span class="comment">// distance:到源节点的距离</span></span><br><span class="line">		<span class="type">int</span> v=t.second;</span><br><span class="line">		<span class="comment">// 如果已访问过,则跳过</span></span><br><span class="line">		<span class="keyword">if</span>(st[v])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		st[v]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 遍历该结点的所有边,-1是尾边(因为用的是头插法)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[v];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果距离更短,则更新</span></span><br><span class="line">			<span class="keyword">if</span>(dist[j]&gt;dist[v]+w[i]) &#123;</span><br><span class="line">				dist[j]=dist[v]+w[i];</span><br><span class="line">				<span class="comment">// 节点j的距离和编号加入队列</span></span><br><span class="line">				heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果不可达,返回-1</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n]; <span class="comment">// 否则范围到节点n的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="comment">// add(b,a,c); // 无向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-存在负权边">1.2. 存在负权边</span></h3><ul>
<li><p>$SPFA$ 一般比贝尔曼福特快，如果想求不超过 $k$ 条边的最短路，只能用贝尔曼福特算法来做。需要注意一点，如果存在负权回路，那么最短路是不一定存在的，贝尔曼福特算法可以求出是否存在负权回路，<strong>如果存在负权回路，贝尔曼福特可能求不出最短路径</strong></p>
</li>
<li><p>需要注意的是：$SPFA$ 的使用条件是，<strong>一定不存在负环，SPFA本质上是对Bellman-Ford的优化，也可以用于找负环</strong></p>
</li>
<li><p>$80%$ 的正权图也能用 $SPFA$ 来做，且时间效率会比 $dijkstra$ 更快，但是如果 $SPFA$ 被卡了，$SPFA$ 的平均时间复杂度是$O(m)$，最坏的情况是$O(nm)$，数据给的差是可能达到最坏情况的，如果被卡了，就换成堆优化的 $dijkstra$</p>
</li>
</ul>
<h4><span id="121-bellman-ford">1.2.1. Bellman-Ford</span></h4><blockquote>
<p>时间复杂度 $O(nm)$，题目链接：<a href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bellman-Ford算法,注意该算法存边随便存,只要能遍历所有边即可</span></span><br><span class="line"><span class="comment">// for循环n次,每一次循环所有边a,b,w,更新最短距离(三角不等式)</span></span><br><span class="line"><span class="comment">// 迭代k次后,dist数组代表的含义:从1号点经过,不超过k条边走到每个点的最短距离</span></span><br><span class="line"><span class="comment">// 如果第n次迭代后dist数组有更新的话,说明一定存在负环,SPFA也可以找负环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SPFA一般在任何情况都优于Bellman-fort</span></span><br><span class="line"><span class="comment">// 但是如果有边数限制,如AcWing853,最多经过不超过k条边的最短路径,必须用Bellman-fort</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k; <span class="comment">// 点/边/最短路边限制</span></span><br><span class="line"><span class="type">int</span> dist[N],backup[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;	</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 结点1到自身距离为0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 走k步路</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="comment">// 把dist写进backup</span></span><br><span class="line">		<span class="comment">// 每次复制上一次的状态,因为要求在k步路内的最短距离,所以不能直接更新</span></span><br><span class="line">		<span class="built_in">memcpy</span>(backup,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			<span class="type">int</span> a=edges[j].a,b=edges[j].b,w=edges[j].w;</span><br><span class="line">			dist[b]=<span class="built_in">min</span>(dist[b],backup[a]+w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为什么这里不是0x3f3f3f3f呢?</span></span><br><span class="line">	<span class="comment">// 因为如果两个点对于点1都是不可达,但相互可达,则可能在更新时变成不是0x3f3f3f3f的数</span></span><br><span class="line">	<span class="comment">// 所以这里用一个类似于极大值的数来替代</span></span><br><span class="line">	<span class="comment">// 如果没有最短路径,返回0x3f3f3f3f,不返回-1是因为有可能最短距离就是-1</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,w;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">		edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">bellman_ford</span>();</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="122-spfa">1.2.2. SPFA</span></h4><blockquote>
<p>时间复杂度 一般 $O(m)$，最坏 $O(nm)$，以下模板无视重边和自环，题目链接：<a href="https://www.acwing.com/problem/content/853/">851. spfa求最短路 - AcWing题库</a></p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPFA:长得特别像dijkstra,对于负权图,如果出题人卡SPFA的话就没办法了</span></span><br><span class="line"><span class="comment">// 只要队列不为空</span></span><br><span class="line"><span class="comment">// 弹出队头t,更新t的所有出边</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化dist为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 第一个点的距离为0</span></span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// 弹出队头</span></span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">// 更新状态</span></span><br><span class="line">		st[t]=<span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// 遍历每条边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果距离更短则更新</span></span><br><span class="line">			<span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">				dist[j]=dist[t]+w[i];</span><br><span class="line">				<span class="comment">// 如果没访问过则加入队列</span></span><br><span class="line">				<span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(j);</span><br><span class="line">					st[j]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不可达不要返回-1,因为有可能最短路径就是-1</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="123-spfa判负环">1.2.3. SPFA判负环</span></h4><blockquote>
<p>题目链接：<a href="https://www.acwing.com/problem/content/854/">852. spfa判断负环 - AcWing题库</a></p>
</blockquote>
<ul>
<li>维护一个 $cnt$ 数组，从 $[1,x]$，$cnt$ 数组记录的是在用 $SPFA$ 找$1$号点 到 $n$号点最短路径时，这个最短路中边的个数，如果 $dist[j]&gt;dist[v]+w[i]$ 说明我从 $v$ 这个点到 $j$ 的距离更短，那么从 $i$ → $j$ 就更新为 $i$ → $v$ → $j$，所以边数要 $+1$ ，即有 $cnt[j]&#x3D;cnt[v]+1$ ，如果在某一次中 $cnt[x]&gt;&#x3D;n$ 了，说明一共经历了 $n$ 条边，有$n$ 条边就有 $n+1$ 个点，但是题目中只有 $n$ 个点，说明有一个点出现了两次，即出现了环，又因为 $dist$ 是在不断减小的，所以这一定是一个负环</li>
<li>还需要注意一点，一开始我们不能直接把 $1$ 号点放进队列来找，因为题目要找的是整个图中是否存在负环，而从 $1$ 号点出发不一定能到这个负环，所以做法是把所有点都放进队列中，那么一定能找到这个负环</li>
<li>注意 $SPFA$ 判负环时间复杂度其实还蛮高的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// 判断有无负环,cnt[i]:表示遍历到第i个节点时已遍历过的节点总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 注意这里不能把1放进去,因为1可能到不了这个负环</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	q.push(1);</span></span><br><span class="line">    <span class="comment">// 把每个点都放进去判断</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		st[i]=<span class="literal">true</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		st[t]=<span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">				dist[j]=dist[t]+w[i];</span><br><span class="line">				cnt[j]=cnt[t]<span class="number">+1</span>; <span class="comment">// 遍历到节点j时遇到的节点总数+1</span></span><br><span class="line">				<span class="keyword">if</span>(cnt[j]&gt;=n) </span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 有负环</span></span><br><span class="line">				<span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(j);</span><br><span class="line">					st[j]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;	</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-多源汇最短路">2. 多源汇最短路</span></h2><blockquote>
<p>求多个起点到其他点的距离</p>
</blockquote>
<h3><span id="21-floyd算法">2.1. Floyd算法</span></h3><blockquote>
<p>时间复杂度O(n³)，dp的外表，暴力的心，题目链接：<a href="https://www.acwing.com/problem/content/856/">854. Floyd求最短路 - AcWing题库</a>，以下模板能处理重边、自环、负权边，但不能处理负权回路，因为存在负权回路时距离会不断往下越来越小，无法收敛</p>
</blockquote>
<ul>
<li>注意之所以用 $d[a][b]&gt;INF&#x2F;2$ 来判断是否是不可达是因为题目中存在负权边更新后的距离很有可能比 $INF$ 小一些，要在其他负权边存在的最短路问题中也注意一下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弗洛伊德:多源最短路,直接暴力暴暴暴就完事了</span></span><br><span class="line"><span class="comment">// 第一层循环,k从1~n,枚举i→j的中间节点</span></span><br><span class="line"><span class="comment">// 第二层循环,i从1~n</span></span><br><span class="line"><span class="comment">// 第三层循环,j从1~n</span></span><br><span class="line"><span class="comment">// d[i,j]=min(d[i][j],d[i][k]+d[k][j])</span></span><br><span class="line"><span class="comment">// 原理:d[k,i,j]=d[k-1,i,k]+d[k-1,k,j],基于dp</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,Q; <span class="comment">// Q是循环次数</span></span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">				d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q; </span><br><span class="line">	<span class="comment">// 重边和自环的处理方法:</span></span><br><span class="line">	<span class="comment">// 重边:保留最小的边</span></span><br><span class="line">	<span class="comment">// 自环:删除</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)</span><br><span class="line">				d[i][j]=<span class="number">0</span>; <span class="comment">// 自己到自己的距离为0,赋初值,后比较,去自环</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				d[i][j]=INF; <span class="comment">// 初始化邻接矩阵为互不可达</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		d[a][b]=<span class="built_in">min</span>(d[a][b],c); <span class="comment">// 去重边,保留最小边(邻接矩阵的做法)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">floyd</span>();</span><br><span class="line">	<span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(d[a][b]&gt;INF/<span class="number">2</span>) <span class="comment">// 可能会被更新得不是INF</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;d[a][b]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/2024/10/03/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="单调队列">单调队列</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">1. 单调队列</a><ul>
<li><a href="#11-%E7%BB%B4%E6%8A%A4%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC">1.1. 维护滑动窗口的最大值&#x2F;最小值</a></li>
<li><a href="#12-%E7%BB%B4%E6%8A%A4%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">1.2. 维护连续子序列的最大和</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1H5411j7o6/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">C15【模板】单调队列 滑动窗口最值_bilibili</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>用于求滑动窗口内的最小值和最大值</li>
</ul>
<h2><span id="1-单调队列">1. 单调队列</span></h2><ul>
<li>队尾进队出队，队头出队（维护子序列的单调性）的数据结构</li>
<li>队尾出队的条件：队列不空且新元素更优，队中旧元素队尾出队</li>
<li>每个元素必然从队尾进队一次</li>
<li>队头出队的条件：队头元素滑出了窗口</li>
<li>注意：队列中存储元素的下标，方便判断队头出队</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031258078.png" alt="image-20240327125322278"></p>
<h3><span id="11-维护滑动窗口的最大值x2f最小值">1.1. 维护滑动窗口的最大值&#x2F;最小值</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="comment">// 当队尾t&lt;队头h时,说明单调队列中没有元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 当前队头q[h]不在窗口[i-k+1,i]内,队头出队</span></span><br><span class="line">    <span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-k+<span class="number">1</span>) h++;</span><br><span class="line">    <span class="comment">// 当前值&gt;=队尾值,队尾出队(如果当前值比队头还大,那么会一直出队到队头出队)</span></span><br><span class="line">    <span class="keyword">while</span>(h&lt;=t &amp;&amp; a[i]&gt;=a[q[t]]) t--;</span><br><span class="line">    <span class="comment">// 当前值从队尾入队,注意入队的是下标,一直存储的都是下标</span></span><br><span class="line">    q[++t]=i;</span><br><span class="line">    <span class="comment">// 如果i&gt;=k表明起码占满一个窗口,此时队头中的是最大值</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 &#x2F;【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N]; <span class="comment">// q是队列,建议数组模拟,不开O2优化的情况下数组都比STL库更快</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 维护窗口最小值O(n)</span></span><br><span class="line">	<span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="comment">// 当队尾t&lt;队头h时,说明单调队列中没有元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; <span class="comment">// 枚举队列中所有元素</span></span><br><span class="line">		<span class="comment">// 新元素比当前队尾还小,说明新元素更优,那么把后面的全部移出去,最小的变进来</span></span><br><span class="line">		<span class="keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&gt;=a[i]) t--;</span><br><span class="line">		q[++t]=i; <span class="comment">// 注意,q存的都是下标嗷,表示把i从队尾入队</span></span><br><span class="line">		<span class="comment">// 当新元素不是最优时,也会直接执行q[++t]=i加到当前窗口的末尾</span></span><br><span class="line">		<span class="keyword">if</span>(q[h]&lt;i-k+<span class="number">1</span>) h++; <span class="comment">// i-k+1是当前窗口的左边界,如果队头下标小于i-k+1,说明窗口右移</span></span><br><span class="line">		<span class="comment">// 此时相当于队头出队</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 能输出第一个窗口的大小时</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 维护最大值的单调队列,q[h]代表队头元素的下标</span></span><br><span class="line">	h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果比队尾更优,则出队</span></span><br><span class="line">		<span class="keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&lt;=a[i]) t--;</span><br><span class="line">		<span class="comment">// 入队</span></span><br><span class="line">		q[++t]=i;</span><br><span class="line">		<span class="comment">// 滑动窗口右移</span></span><br><span class="line">		<span class="keyword">if</span>(q[h]&lt;i-k+<span class="number">1</span>) h++;</span><br><span class="line">		<span class="comment">// 输出当前窗口最大值</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基于STL</p>
</li>
<li><p>单调队列是相较于队列，队头也可以出队的数据结构，则可以用 $STL$ 库中的 $deque$ 实现【双端队列，可以入队也可以出队】</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 输出最小值,a[i]比队尾元素更优,则弹出对位并加入队列</span></span><br><span class="line">    <span class="comment">// 如果dq不为空且这个新元素更优,则去尾</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.empty() &amp;&amp; a[dq.back()]&gt;a[i]) dq.pop_back(); <span class="comment">// 去尾</span></span><br><span class="line">    dq.push_back(i); <span class="comment">// 1)去尾后将最优元素加入到队列中;2)dq为空,自然将下标入队;3)</span></span><br><span class="line">    <span class="comment">// 如果达到窗口大小</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) &#123;</span><br><span class="line">        <span class="comment">// 如果dq不为空并且队头元素下标小于等于i-k(即滑出窗口了)</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-k) dq.pop_back(); <span class="comment">// 删头</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[dq.front()]); <span class="comment">// 输出队头的元素,此时对应最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 &#x2F;【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<ul>
<li>要 $pop_back()$ 或者 $pop_front()$ 之前可以用 $dq.size()$ 检测一下是否有元素，否则可能导致 $RE$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: RE也可能是数组没开够哦</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 双端队列表示单调队列</span></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 元素个数以及窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找最小值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 输出最小值,a[i]比队尾元素更优,则弹出对位并加入队列</span></span><br><span class="line">		<span class="comment">// 如果dq不为空且这个新元素更优,则去尾</span></span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; a[dq.back()]&gt;a[i] &amp;&amp; dq.size()) dq.pop_back(); <span class="comment">// 去尾</span></span><br><span class="line">		dq.push_back(i); <span class="comment">// 1)去尾后将最优元素加入到队列中;2)dq为空,自然将下标入队;3)</span></span><br><span class="line">		<span class="comment">// 如果达到窗口大小</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) &#123;</span><br><span class="line">			<span class="comment">// 如果dq不为空并且队头元素下标小于等于i-k(即滑出窗口了)</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-k &amp;&amp; dq.size()) dq.pop_front(); <span class="comment">// 删头</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[dq.front()]); <span class="comment">// 输出队头的元素,此时对应最大值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	dq.clear();</span><br><span class="line">	<span class="comment">// 找最大值,如果a[i]比队尾大就入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; a[dq.back()]&lt;a[i] &amp;&amp; dq.size()) dq.pop_back();</span><br><span class="line">		dq.push_back(i);</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-k &amp;&amp; dq.size()) dq.pop_front();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[dq.front()]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-维护连续子序列的最大和">1.2. 维护连续子序列的最大和</span></h3><blockquote>
<p>题目链接：</p>
</blockquote>
<ul>
<li><p>基于数组</p>
</li>
<li><p>给定一个长度为n的整数序列，请找出长度不超过 $m$ 的连续子序列的最大和。例如，数组 ${2,\ -3,\ 5,\ 2,\ -4,\ -1,\ 8}$ ，$m$ 取 $3$ ，那么长度不超过 $3$ 的连续子序列的最大和为 $8$</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031258085.png" alt="image-20240327145503331"></p>
<ul>
<li>对于常规做法（左边），每次枚举一个窗口长度，再在这个窗口中枚举得到最大的连续子段和，时间复杂度是 $O(n^3)$，对于右图，表示的是前缀和数组 $s$</li>
<li>对于连续子段和（区间和），我们很容易想到预处理一个前缀和数组，这样就可以把计算连续字段和的时间从 $O(n)$ 优化到 $O(1)$，$i$ 到 $j$ 的间和计算公式是 $s[i]-s[j-1]$，我们只要找到左端点 $s[l-1]$ 的最小值，那么就可以求出 $s[i]-min(s[j]),\ j∈[i-m,i-1]$ 得到前 $i$ 项的最大连续子段和，因为要枚举求得最小值，所以时间复杂度是 $O(n^2)$</li>
<li>但是，如果我们再用单调队列维护这个最小值，就不需要再枚举求连续区间和的最小值，时间复杂度会继续下降到 $O(n)$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">// 单调队列</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和序列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k; <span class="comment">// 求的是长度不超过k的最大区间和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> h=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ans=s[<span class="number">1</span>]; <span class="comment">// 初始化区间和的答案</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 队头不在窗口[i-k,i-1]内,队头出队</span></span><br><span class="line">		<span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-k) h++; <span class="comment">// 这里因为只用看前i-k个元素,窗口右边界小了1,因此不用加1</span></span><br><span class="line">		<span class="comment">// 使用队头最小值,同样的因为队尾小了1,所以要把最小值在这里处理</span></span><br><span class="line">		ans=max(ans,s[i]-s[q[h]]);</span><br><span class="line">		<span class="comment">// 当前值&lt;=队尾值,队尾出队,把更小的s[i]放进队列中以维护s[i]的最小值</span></span><br><span class="line">		<span class="keyword">while</span>(h&lt;=t &amp;&amp; s[i]&lt;=s[q[t]]) t--;</span><br><span class="line">		<span class="comment">// 从队尾正常入队</span></span><br><span class="line">		q[++t]=i; <span class="comment">// 放进去的仍然是下标哈</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">7 3</span></span><br><span class="line"><span class="comment">2 -3 5 2 -4 -1 8</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>另一种写法，本人暂时还没验证是否正确，在维护滑动窗口最大值和最小值的基础上只改动了最后一步，即维护 $ans$ 的代码，因为 $s[i]-s[q[h]]$ 中 $s[q[h]]$ 已经前 $i$ 项窗口大小为 $[1,k]$ 的滑动窗口中前缀和的最小值，所以相减即可得到最大区间和</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=s[<span class="number">1</span>];</span><br><span class="line">h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;=t &amp;&amp; s[i]&lt;=s[q[t]]) t--;</span><br><span class="line">    q[++t]=i;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-k) h++;</span><br><span class="line">    ans=max(ans,s[i]-s[q[h]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果窗口大小是从 $[st,en]$（用户手动输入），那么模板可改为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 枚举每个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 对于区间长度在[st,en]之间,当i&gt;=st才计算</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=st) &#123; </span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t &amp;&amp; s[i-st]&lt;=s[q[t]]) t--;</span><br><span class="line">        q[++t]=i-st; <span class="comment">// 偏移量是i-st</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-en) h++;</span><br><span class="line">   	ans=max(ans,s[i]-s[q[h]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基于STL</p>
</li>
<li><p>关键点，$dq.fonrt()&lt;i-k$ 此时代表窗口大于 $k$ 了，因为窗口大小是 $≤k$ 所以没有设限 $if(i&gt;&#x3D;k)$</p>
</li>
<li><p>对于 $dq.empty()$ 即是最初的状态，即没有任何元素，此时只会添加 $s[1]$ 进去，其他情况会进入 $s[i]-s[dq.front()]$ 表示 $[0,i-1]$ 中的最小值</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=INT_MIN; <span class="comment">// 找最大值</span></span><br><span class="line">dq.push_back(<span class="number">0</span>); </span><br><span class="line"><span class="comment">// 枚举到第i个元素,则从前[0,i-1]中找最小值s[j](前缀和),用s[i]-s[j]即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 因为窗口大小是小于等于k,所以一旦dq.front&lt;i-k代表窗口大小大于k了</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;i-k) dq.pop_front(); <span class="comment">// 删头</span></span><br><span class="line">    <span class="keyword">if</span>(dq.empty()) ans=max(ans,s[i]); <span class="comment">// 对应最初状态,这里只会添加s[1],其他情况下队列起码有一个元素</span></span><br><span class="line">    <span class="keyword">else</span> ans=max(ans,s[i]-s[dq.front()]); <span class="comment">// 此时dq中的是0~s[i-1]中的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.back()&gt;=s[i]) dq.pop_back();</span><br><span class="line">    dq.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 单调队列</span></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 长度不超过k的子序列最大和</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=INT_MIN; <span class="comment">// 找最大值</span></span><br><span class="line">	dq.push_back(<span class="number">0</span>); </span><br><span class="line">	<span class="comment">// 枚举到第i个元素,则从前[0,i-1]中找最小值s[j](前缀和),用s[i]-s[j]即可</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 因为窗口大小是小于等于k,所以一旦dq.front&lt;i-k代表窗口大小大于k了</span></span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;i-k) dq.pop_front(); <span class="comment">// 删头</span></span><br><span class="line">		<span class="keyword">if</span>(dq.empty()) ans=max(ans,s[i]); <span class="comment">// 对应最初状态,这里只会添加s[1],其他情况下队列起码有一个元素</span></span><br><span class="line">		<span class="keyword">else</span> ans=max(ans,s[i]-s[dq.front()]); <span class="comment">// 此时dq中的是0~s[i-1]中的最小值</span></span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.back()&gt;=s[i]) dq.pop_back();</span><br><span class="line">		dq.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析及常用技巧</title>
    <url>/2024/10/03/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="复杂度分析及常用技巧">复杂度分析及常用技巧</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">1. 时间复杂度</a></li>
<li><a href="#2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2. 空间复杂度</a></li>
<li><a href="#3-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7">3. 常用技巧</a></li>
<li><a href="#4-debug%E6%8A%80%E5%B7%A7">4. Debug技巧</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-时间复杂度">1. 时间复杂度</span></h2><ul>
<li>C++语言1秒钟可以执行的操作次数是 10^7^~10^8^</li>
<li>时间复杂度的常数怎么理解？可以理解为代码的指令行数，如果循环内部指令行数&gt;&#x3D;10条一般认为常数比较大</li>
<li>根据题目给定的范围，反推应该使用什么样时间复杂度的算法：</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031243416.png" alt="image-20240111214332856" style="zoom:80%;">



<h2><span id="2-空间复杂度">2. 空间复杂度</span></h2><ul>
<li>C++中最大空间限制为2147483647，即5e8（对int型），如果数据范围超过5e8就不要用数组</li>
<li>对64MB的存储空间，开一个n×n的int型二维数组，其n最大为8172</li>
</ul>
<h2><span id="3-常用技巧">3. 常用技巧</span></h2><ol>
<li><p>a&#x2F;b向上取整，可以用ceil(a&#x2F;b)，但是这个函数的返回值是double类型的，所以需要强转，即int(ceil(a&#x2F;b))，这样写非常繁琐，不如用 $a+b-1&#x2F;b$ 表示向上取整</p>
</li>
<li><p>类似的技巧还有 a%b 如何把余数限制为正数？只需要 (a%b+b)%b 就可以了，保证模数不变的同时使结果都变为正数</p>
</li>
<li><p>优化输入输出速度，但速度依然不及scanf和printf</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); <span class="comment">// 优化输入输出(取消关联)</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); <span class="comment">// 加快输入</span></span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>); <span class="comment">// 加快输出</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>cin后面不能马上跟getline，因为cin读不了换行符，而换行符是getline的结束符，所以要忽略换行符，用语句，或者getchar()读走这个换行符</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>万能头文件(蓝桥杯也可用，前提是开C++11)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>图论无穷大：0x3f3f3f3f</li>
</ol>
<ul>
<li>在图论中，将距离数组初始化为0x3f3f3f3f是为了表示无穷大。这是因为0x3f3f3f3f的十进制值是1061109567，它是一个很大的数，但又不会溢出。这个值被用来表示无穷大，因为两个0x3f3f3f3f的和只比int类型的最大值小一点，这样在两个无穷相加时能够保证不会溢出，对于long long类型，则用0x3f3f3f3f3f3f3f3f。需要注意的是，用memset函数进行初始化时，只需要memset(dis, 0x3f, sizeof dis)即可，因为memset函数是按照字节来赋值的，所以这条语句默认赋值0x3f3f3f3f</li>
</ul>
<ol start="7">
<li>行数不固定的输入</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)</span><br></pre></td></tr></table></figure>



<h2><span id="4-debug技巧">4. Debug技巧</span></h2><ol>
<li>Segmentation Fault：段错误，多为数组越界导致的，且不输出任何额外的信息，此时可以借助exit(0)函数：在程序的任何位置直接退出，来排除是哪一步的问题</li>
<li>CE：编译错误，</li>
<li>RE：运行错误，数组越界或爆栈</li>
<li>TLE：时间超限</li>
<li>MLE：内存超限</li>
<li>PE：格式错误</li>
<li>OLE：输出超限，通常为没有删除调试语句</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>前置知识</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2024/10/05/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="字典树">字典树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li>
<li><a href="#2-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">2. 插入操作</a></li>
<li><a href="#3-%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C">3. 查询操作</a></li>
<li><a href="#4-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">4. 完整代码</a><ul>
<li><a href="#41-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">4.1. 字符数组</a></li>
<li><a href="#42-%E5%AD%97%E7%AC%A6%E4%B8%B2">4.2. 字符串</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1yA4y1Z74t/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F06 字典树(Trie)</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>是快速插入和查询字符串的多叉树结构，根节点编号为0，其余节点标识路径，还可以标记单词插入的次数，边表示字符。</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240303203511065.png" alt="image-20240303203511065" style="zoom:80%;">



<h2><span id="1-数据结构">1. 数据结构</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="comment">// 每次输入的字符串,N是每个单词的最大长度</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>]; <span class="comment">// ch[p][j]:从节点p沿着j这条边走到的子节点,边为26个小写字母映射值为0~25</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[p]:以节点p结尾的单词的插入次数</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 遍历因子</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-插入操作">2. 插入操作</span></h2><ul>
<li>insert函数，插入单个单词并建立字典树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s:单词(字符串)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 根节点编号为0</span></span><br><span class="line">	<span class="comment">// 枚举字符串每个字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到0~25</span></span><br><span class="line">		<span class="comment">// 如果这个字符不是儿子节点,创建儿子,p指针再走到儿子</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 节点编号+1</span></span><br><span class="line">		<span class="comment">// 如果这个字符是儿子节点,p指针走到儿子节点</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词插入的次数+1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240303235131060.png" alt="image-20240303235131060"></p>
<h2><span id="3-查询操作">3. 查询操作</span></h2><ul>
<li>query函数，得到一个单词被插入的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某个单词出现的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始查</span></span><br><span class="line">	<span class="comment">// 扫描字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 转换为映射值</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果找不到返回0</span></span><br><span class="line">		<span class="comment">// 有字母s[i],则走下来</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果能走到词尾,则返回插入次数</span></span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-完整代码">4. 完整代码</span></h2><h3><span id="41-字符数组">4.1. 字符数组</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 节点表示数字,边表示字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="comment">// 每次输入的字符串,N是每个单词的最大长度</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>]; <span class="comment">// ch[p][j]:从节点p沿着j这条边走到的子节点,边为26个小写字母映射值为0~25</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[p]:以节点p结尾的单词的插入次数</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 遍历因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s:单词(字符串)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始插</span></span><br><span class="line">	<span class="comment">// 枚举字符串每个字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到0~25</span></span><br><span class="line">		<span class="comment">// 如果这个字符不是儿子节点,创建儿子,p指针再走到儿子</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 节点编号+1</span></span><br><span class="line">		<span class="comment">// 如果这个字符是儿子节点,p指针走到儿子节点</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词插入的次数+1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询某个单词出现的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始查</span></span><br><span class="line">	<span class="comment">// 扫描字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 转换为映射值</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果找不到返回0</span></span><br><span class="line">		<span class="comment">// 有字母s[i],则走下来</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果能走到词尾,则返回插入次数</span></span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,&amp;op,s);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(s);</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="42-字符串">4.2. 字符串</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 节点表示数字,边表示字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件总长度不超过32K,所以总字符不超过:32K=32*1024</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">32</span>*<span class="number">1024</span><span class="number">+10</span>; </span><br><span class="line"><span class="type">char</span> s[N]; <span class="comment">// 每次输入的字符串,N是每个单词的最大长度</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>]; <span class="comment">// ch[p][j]:从节点p沿着j这条边走到的子节点,边为26个小写字母映射值为0~25</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[p]:以节点p结尾的单词的插入次数</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 遍历因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s:单词(字符串)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始插</span></span><br><span class="line">	<span class="comment">// 枚举字符串每个字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;A&#x27;</span>; <span class="comment">// a~z映射到0~25</span></span><br><span class="line">		<span class="comment">// 如果这个字符不是儿子节点,创建儿子,p指针再走到儿子</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 节点编号+1</span></span><br><span class="line">		<span class="comment">// 如果这个字符是儿子节点,p指针走到儿子节点</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词插入的次数+1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询某个单词出现的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始查</span></span><br><span class="line">	<span class="comment">// 扫描字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 转换为映射值</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果找不到返回0</span></span><br><span class="line">		<span class="comment">// 有字母s[i],则走下来</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果能走到词尾,则返回插入次数</span></span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	while(scanf(&quot;%s&quot;,s)) &#123;</span></span><br><span class="line"><span class="comment">//		insert(s);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;s) &#123;</span><br><span class="line">		<span class="built_in">insert</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;idx<span class="number">+1</span>; <span class="comment">// 加上根节点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2024/10/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="字符串哈希">字符串哈希</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li>
<li><a href="#2-%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC">2. 求字符串哈希值</a></li>
<li><a href="#3-%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC">3. 求字符串字串的哈希值</a></li>
<li><a href="#4-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%90%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C">4. 判断两个子串是否相同</a></li>
<li><a href="#5-%E4%BE%8B%E9%A2%98%E6%B4%9B%E8%B0%B7-p3370">5. 【例题】洛谷 P3370</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.788&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F02 字符串哈希 bilibili</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>字符串哈希即把不同的字符串映射成不同的整数</li>
</ul>
<ol>
<li><p>把字符串映射成一个 $p$ 进制数字，对于一个长度为 $n$ 的字符串 $s$</p>
<ul>
<li>定义其 $Hash$ 函数为：$ h(s)&#x3D;\sum_{i&#x3D;1}^n s[i]×p^{i-1}(mod M)$</li>
<li>如：字符串 $abc$ ，哈希函数值为 $ap^2+bp^1+c&#x3D;97×131^2+98×131^1+99$</li>
</ul>
</li>
<li><p>如果两个字符串不一样但 $Hash$ 函数值一样，这样的现象被称作哈希碰撞</p>
</li>
<li><p>解决哈希碰撞的方法（极大程度减少哈希碰撞次数，但还是有可能碰撞）</p>
<ul>
<li>巧妙设置 $p$ 和 $M$ 的值，保证 $p$ 和 $M$ 互质</li>
<li>$p$ 通常为：$131$ 或 $13331$</li>
<li>$M$ 通常取大整数 $2^{64}$，把哈希函数值 $h$ 定义为 $ULL$，对于无符号数，超过则自动溢出，等价于取模了</li>
</ul>
</li>
</ol>
<h2><span id="1-数据结构">1. 数据结构</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 最大字符串的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1.5e3</span><span class="number">+10</span>; <span class="comment">// 题目中字符串的最大长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>; <span class="comment">// 131,13331不容易哈希碰撞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p[i]:表示p的i次方</span></span><br><span class="line"><span class="comment">// h[i]:表示s[1~i]的哈希值,如h[2]表示字符串s前两个字符组成字符串的哈希值</span></span><br><span class="line">ULL p[N],h[N];</span><br><span class="line"><span class="type">char</span> s[M]; <span class="comment">// 存储字符串</span></span><br><span class="line"><span class="type">int</span> n;</span><br></pre></td></tr></table></figure>



<h2><span id="2-求字符串哈希值">2. 求字符串哈希值</span></h2><ul>
<li>求一个字符串的哈希值相当于求前缀和</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240312215219122.png" alt="image-20240312215219122"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理hash函数的前缀和,时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// p^0=1,空串哈希值为0</span></span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>,h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		p[i]=p[i<span class="number">-1</span>]*P;	</span><br><span class="line">		h[i]=h[i<span class="number">-1</span>]*P+s[i]; <span class="comment">// 前缀和计算公式</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-求字符串字串的哈希值">3. 求字符串字串的哈希值</span></h2><ul>
<li>求字符串字串的哈希值相当于求区间和</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240312220823283.png" alt="image-20240312220823283"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算s[l~r](子串)的hash值,时间复杂度O(1)</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>]; <span class="comment">// 区间和计算字串的hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-判断两个子串是否相同">4. 判断两个子串是否相同</span></h2><ul>
<li>直接计算这两个子串的哈希值即可，若相等说明子串相同，反之亦然</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断两个子串是否相同</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">substr</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l2,<span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-例题洛谷-p3370">5. 【例题】洛谷 P3370</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希 - 洛谷</a></p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240312221054653.png" alt="image-20240312221054653"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 字符串数量上界</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1.5e3</span><span class="number">+10</span>; <span class="comment">// 单个字符串最大长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>; <span class="comment">// 131,13331不容易哈希碰撞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h[i]:表示s[1~i]的哈希值,如h[2]表示字符串s前两个字符组成字符串的哈希值</span></span><br><span class="line">ULL h[N]; </span><br><span class="line"><span class="type">char</span> str[M]; <span class="comment">// 存储字符串</span></span><br><span class="line">set&lt;ULL&gt; s; <span class="comment">// 存储每个字符串的哈希值,集合自动去重</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串s的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">Hash</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">	h[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">// 空串哈希值为0</span></span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(str<span class="number">+1</span>); <span class="comment">// 计算长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">		h[i]=h[i<span class="number">-1</span>]*P+str[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h[len]; <span class="comment">// 返回此串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%str&quot;</span>,str<span class="number">+1</span>); <span class="comment">// 从下标1开始存</span></span><br><span class="line">		s.<span class="built_in">insert</span>(<span class="built_in">Hash</span>(str)); <span class="comment">// 存储答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂数论</title>
    <url>/2024/10/07/%E5%A4%8D%E6%9D%82%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="复杂数论">复杂数论</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E8%B4%A8%E6%95%B0%E5%88%A4%E6%96%AD">1. 质数判断</a></li>
<li><a href="#2-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0">2. 分解质因数</a><ul>
<li><a href="#21-%E8%AF%95%E9%99%A4%E6%B3%95">2.1. 试除法</a></li>
<li><a href="#22-%E6%9E%9A%E4%B8%BE%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96">2.2. 枚举次数优化</a></li>
</ul>
</li>
<li><a href="#3-%E8%B4%A8%E6%95%B0%E7%AD%9B">3. 质数筛</a><ul>
<li><a href="#31-%E6%9C%B4%E7%B4%A0%E6%B3%95">3.1. 朴素法</a></li>
<li><a href="#32-%E5%9F%83%E5%8F%8A%E7%AD%9B">3.2. 埃及筛</a></li>
<li><a href="#33-%E6%AC%A7%E6%8B%89%E7%AD%9B">3.3. 欧拉筛</a></li>
</ul>
</li>
<li><a href="#4-%E7%BA%A6%E6%95%B0">4. 约数</a><ul>
<li><a href="#41-%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0">4.1. 试除法求约数个数</a></li>
<li><a href="#42-%E5%85%AC%E5%BC%8F%E6%B1%82%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0">4.2. 公式求约数个数</a></li>
<li><a href="#43-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C">4.3. 约数之和</a></li>
</ul>
</li>
<li><a href="#4-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">4. 最大公约数</a></li>
<li><a href="#5-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">5. 欧拉函数</a><ul>
<li><a href="#51-%E5%AE%9A%E4%B9%89%E6%B3%95">5.1. 定义法</a></li>
<li><a href="#52-%E7%AD%9B%E6%B3%95">5.2. 筛法</a></li>
<li><a href="#53-%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">5.3. 欧拉定理</a></li>
</ul>
</li>
<li><a href="#6-%E5%BF%AB%E9%80%9F%E5%B9%82">6. 快速幂</a><ul>
<li><a href="#61-%E5%BF%AB%E9%80%9F%E5%B9%82">6.1. 快速幂</a></li>
<li><a href="#62-%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83">6.2. 快速幂求逆元</a></li>
</ul>
</li>
<li><a href="#7-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">7. 扩展欧几里得算法</a><ul>
<li><a href="#71-%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86">7.1. 裴蜀定理</a></li>
<li><a href="#72-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97">7.2. 扩展欧几里得</a></li>
<li><a href="#73-%E5%BA%94%E7%94%A8%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B">7.3. 【应用】线性同余方程</a></li>
<li><a href="#74-%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86">7.4. 【应用】中国剩余定理</a></li>
</ul>
</li>
<li><a href="#8-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83">8. 高斯消元</a><ul>
<li><a href="#81-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84">8.1. 高斯消元解线性方程组</a></li>
<li><a href="#82-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%BC%82%E6%88%96%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84">8.2. 高斯消元解异或线性方程组</a></li>
</ul>
</li>
<li><a href="#9-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6">9. 组合数学</a><ul>
<li><a href="#91-%E7%BB%84%E5%90%88%E6%95%B0">9.1. 组合数</a><ul>
<li><a href="#911-%E6%9C%B4%E7%B4%A0%E6%B3%95">9.1.1. 朴素法</a></li>
<li><a href="#912-%E5%BF%AB%E9%80%9F%E5%B9%82">9.1.2. 快速幂</a></li>
<li><a href="#913-%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86">9.1.3. 卢卡斯定理</a></li>
<li><a href="#914-%E7%BA%BF%E6%80%A7%E7%AD%9B%E9%AB%98%E7%B2%BE%E4%B9%98">9.1.4. 线性筛+高精乘</a></li>
</ul>
</li>
<li><a href="#92-%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0">9.2. 卡特兰数</a></li>
</ul>
</li>
<li><a href="#10-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86">10. 容斥原理</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>最没有自信的一章哈哈😅</p>
</blockquote>
<h2><span id="1-质数判断">1. 质数判断</span></h2><blockquote>
<p>时间复杂度 $O(n)→O(\sqrt n)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:朴素试除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2:枚举次数优化→sqrt:这个函数本身速度较慢,不推荐</span></span><br><span class="line"><span class="comment">// 包括 i*i&lt;=n 这种写法也不推荐,因为i*i可能小于等于n,但是(i+1)*(i+1)可能会溢出int型最大值,如果溢出了就会变成一个负数,从而影响最终答案的判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3:最佳写法应该是i&lt;=n/i,速度快并且不会溢出</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++) &#123;	</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-分解质因数">2. 分解质因数</span></h2><blockquote>
<p>质因数的底数和指数：底数指质数的基数，比如分解12&#x3D;2×2×3时，2和3就是底数，而指数指的是各个基数出现的次数，2的指数是2，3的指数是1</p>
</blockquote>
<h3><span id="21-试除法">2.1. 试除法</span></h3><blockquote>
<p>时间复杂度 $O(n)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divede</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 先找到这个质数</span></span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 再求质数出现的次数</span></span><br><span class="line">			<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 当n%i不等于0了,说明不再被整除,指数求完了</span></span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">				n/=i;</span><br><span class="line">				s++;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-枚举次数优化">2.2. 枚举次数优化</span></h3><ul>
<li>对上述算法进行优化，我们可以证明n中最多包含一个大于sqrt(n)的质因子（假设有两个的话，两个大于sqrt(n)的质因子相乘的结果就大于n了，所以不成立），所以可以和优化求质数时一样的做法来减少枚举次数。</li>
</ul>
<blockquote>
<p>时间复杂度 $[O(log(n)),\ O(sqrt(n))]$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divede</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">				n/=i;</span><br><span class="line">				s++;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因为我们证明了大于sqrt(n)的数最多只有一个</span></span><br><span class="line">	<span class="comment">// 那么n如果还&gt;1,说明没除完,那剩下的那个必定就是大于sqrt(n)的质因子</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">		cout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-质数筛">3. 质数筛</span></h2><h3><span id="31-朴素法">3.1. 朴素法</span></h3><blockquote>
<p>时间复杂度约等于 $O(nln^n)&lt;O(nlog^n)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>; <span class="comment">// 筛选1~1e6+10中的质数</span></span><br><span class="line"><span class="comment">// primes:记录质数小于等于N的所有质数,cnt:记录质数个数</span></span><br><span class="line"><span class="comment">// primes中下标为0~cnt-1存储的就是所有小于等于N的质数</span></span><br><span class="line"><span class="type">int</span> primes[N],cnt; </span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 记录每个数的访问状态,为true的说明不是质数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从2开始遍历数字,并把其对应倍数的数字全部设置成已访问</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果没有访问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			primes[cnt++]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从i*2开始,只要是i的倍数都设置成已访问</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=n;j+=i)</span><br><span class="line">			st[j]=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-埃及筛">3.2. 埃及筛</span></h3><blockquote>
<p>枚举优化，时间复杂度 $O(nlg^{lg^n})$，约等于 $O(n)$</p>
</blockquote>
<ul>
<li>质数定理：1~n当中有 $n&#x2F;ln(n)$ 个质数，我们在遍历的时候只把质数选出来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			<span class="comment">// 再选出基础数的基础上直接在此遍历筛质数</span></span><br><span class="line">			primes[cnt++]=i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=n;j+=i)</span><br><span class="line">				st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="33-欧拉筛">3.3. 欧拉筛</span></h3><blockquote>
<p>时间复杂度 $O(n)$，真正意义上的线性筛</p>
</blockquote>
<ul>
<li>线性筛法就在欧拉筛的基础上改进了一个东西，$n$ 只会被最小质因子筛掉，欧拉筛、埃及筛都是建立在2是公认的最小的质数上做的，建议疯狂看注释理解嗷</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])</span><br><span class="line">			primes[cnt++]=i;</span><br><span class="line">		<span class="comment">// primes[j](质数)*i&lt;=n,遍历primes[j]即为:primes数组中当前的所有质数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++) &#123;</span><br><span class="line">			<span class="comment">// primes[j]一定是i的最小质因子,primes[j]一定也是primes[j]*i的最小质因子</span></span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 对于一个合数x,假设primes[j]是x的最小质因子,当i枚举到x/primes[j]时就break</span></span><br><span class="line">			<span class="comment">// 啥子意思,就是说我i是个合数的话就只筛一遍,这样才能达到近似O(n)的效果</span></span><br><span class="line">			<span class="comment">// 比如i=6时,质数集中有2,3,5这三个数,那么我只筛2*6=12,3*6和5*6不筛</span></span><br><span class="line">			<span class="comment">// 为什么不筛?因为我在算3*6=18时,i=9,9*2也为18,其实也筛掉了</span></span><br><span class="line">			<span class="comment">// 所以对于合数,我们只用其最小质因子来筛,提前break就可以避免重复筛</span></span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-约数">4. 约数</span></h2><h3><span id="41-试除法求约数个数">4.1. 试除法求约数个数</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求取约数的函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="comment">// 枚举优化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/i;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="comment">// 如果i和n/i是同一个数字,那么只用放一遍</span></span><br><span class="line">			<span class="keyword">if</span>(i!=n/i)</span><br><span class="line">				res.<span class="built_in">push_back</span>(n/i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>()); <span class="comment">// 从小到大排序</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="42-公式求约数个数">4.2. 公式求约数个数</span></h3><ul>
<li>基于算术基本定理，$N$ 的约数的个数就和 $[β_1,β_k]$ 的取法是一模一样的；所以 $[β_1,β_k]$ 就是 $α_1$ 的选法，共 $(α_1+1)$ 种，也表示 $α2$ 的选法，共 $(α_2+1)$ 种，根据乘法定理，所以：对于一个数 $N$，约数个数一定是 $(α_1+1)×(α_2+1)×(α_3+1)×···(α_k+1)$</li>
<li>只要我们能求解出一个数分解质因数的结果，就能求出其约数个数</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231201152205955.png" alt="image-20231201152205955"></p>
<ul>
<li>PS：int范围内，约数个数最多的数的约数个数大概是1500左右。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把因式分解每个基数的底数和指数存到一个map中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 求n个数乘积的约数的个数,并对mod取余</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; primes;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>) &#123;</span><br><span class="line">				x/=i;</span><br><span class="line">				<span class="comment">// 对这n个数的约数都用primes来存,最后统一算出约数个数</span></span><br><span class="line">				primes[i]++; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果x还大于1,把剩下大的那个质因数给加上</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">			primes[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// primes中存储了所有的底数和其对应的指数</span></span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes)</span><br><span class="line">		res=res*(prime.second<span class="number">+1</span>)%mod;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="43-约数之和">4.3. 约数之和</span></h3><ul>
<li>只要我们能求解出一个数分解质因数的结果，就能求得其约数之和，把n的所有约数展开，公式就是下图：</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231201152853841.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把因式分解每个基数的底数和指数存到一个map中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 求n个数乘积的约数的个数,并对mod取余</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; primes;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>) &#123;</span><br><span class="line">				x/=i;</span><br><span class="line">				<span class="comment">// 对这n个数的约数都用primes来存,最后统一算出约数个数</span></span><br><span class="line">				primes[i]++; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果x还大于1,把剩下大的那个质因数给加上</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">			primes[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// primes中存储了所有的底数和其对应的指数</span></span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes) &#123;</span><br><span class="line">		<span class="type">int</span> p=prime.first; <span class="comment">// 底数</span></span><br><span class="line">		<span class="type">int</span> a=prime.second; <span class="comment">// 指数</span></span><br><span class="line">		ll t=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 每一次提一个p出来</span></span><br><span class="line">        <span class="comment">// 1+p1(p1^0+p1^1+···+p1^(α1-1))</span></span><br><span class="line">		<span class="keyword">while</span>(a--)</span><br><span class="line">			t=(t*p<span class="number">+1</span>)%mod;</span><br><span class="line">		res=res*t%mod; <span class="comment">// 结果同样对mod取余</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-最大公约数">4. 最大公约数</span></h2><ul>
<li><p>欧几里得算法，也叫辗转相除法</p>
</li>
<li><p>如果a能除d，b能除d，那么(a+b)也能整除d，比如6能被2整除，14能被2整除，那么20能被2整除，甚者还有 a·x+b·y 能被d整除</p>
</li>
<li><p>根据辗转相除法，a和b的最大公约数就等于b和a mod b的最大公约数。怎么推的？</p>
</li>
<li><p>$a%b&#x3D;a-floor(a&#x2F;b)×b$ ，写成 $a-c×b$，那么 $(a,b)&#x3D;(b, a - c × b)$</p>
</li>
<li><p>对于左侧，$(a,b)$，假设 $d$ 能整除 $a$ ，$d$ 也能整除 $b$，对于右侧，$d$ 能整除 $b$，现在只需要证明 $d$ 也能整除 $a$ ，就能说明左右两侧等价了，$d$ 能整除 $a - c × b$，只需要在右侧加上一个 $c × b$ (相当于 $a×x+b×y$ )，就能说明 $d$ 能整除 $a$ 了，所以左右两侧等价。证毕，$(a,b)&#x3D;(b,a%b)$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当b=0时,(a,0)的最大公约数一定是a,所以返回值的第二项是a</span></span><br><span class="line">	<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-欧拉函数">5. 欧拉函数</span></h2><blockquote>
<p>时间复杂度$O(sqrt(n))$，来源于分解质因数的$O(sqrt(n))$</p>
</blockquote>
<h3><span id="51-定义法">5.1. 定义法</span></h3><ul>
<li>$φ(n)$表示1~n中与n互质的个数，比如$φ(6)$，$[1,6]$ 中有1,5与6互质（互质：公约数只有1的两个整数，叫做互质整数），所以$φ(6)$&#x3D;2</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231201162530871.png" alt="image-20231201162530871"></p>
<ul>
<li>根据容斥原理可以推导，容斥原理：</li>
</ul>
<ol>
<li><p>从 $[1,N]$ 中去掉 $p_1, p_2, … , p_k$ 的所有倍数，而 $[1,N]$ 当中 $p_k$ 的倍数等于$N-N&#x2F;p_1-N&#x2F;p_2-···-N&#x2F;p_k$，此时有些数可能既是$p_1$的倍数，也是$p_2$的倍数，就多去除了一次，所以此时进行第二步；</p>
</li>
<li><p>加上所有$p_i×p_j$的倍数，i和j是1~K中任意两个数，得到下式：</p>
<p>$N-N&#x2F;p_1-N&#x2F;p_2-···-N&#x2F;p_k+N&#x2F;p_1×p_2+N&#x2F;p_1×p_3+···N&#x2F;p_{k-1})×p_k$</p>
</li>
<li><p>这时候又会遇到一个问题，如果一个数既是$p_1$、$p_2$，也是$p_3$的倍呢？它就会被p1减一次，p2减一次，p3再减一次，再在第二步中加上三次，所以第三步；这个时候相当于加回来了，而我们是想把它删去，所以还要减去所有pi×pj×pk的倍数，得到下式：$N-N&#x2F;p1-N&#x2F;p2-···-N&#x2F;pk+N&#x2F;p1×p2+N&#x2F;p1×p3+···N&#x2F;p(k-1)×pk-N&#x2F;p1×p2×p3-N&#x2F;p1×p2×p4-···-N&#x2F;p(k-2)×p(k-1)×pk$，以此类推，最后得到的公式其实就是下面这个函数的展开，所以欧拉函数其实就是容斥原理的展开：</p>
</li>
</ol>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231201163755176.png" alt="image-20231201163755176"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_ola</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res=n;</span><br><span class="line">   	<span class="comment">// 找n的所有质因子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// res=res*(1-1/a):这是欧拉公式</span></span><br><span class="line">			<span class="comment">// 像下面这个公式一样转换是为了避免出现小数,因为这是一个整数运算,保证只有整数</span></span><br><span class="line">			res=res/i*(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">				n/=i;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">		res=res/n*(n<span class="number">-1</span>);</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="52-筛法">5.2. 筛法</span></h3><ul>
<li>在某些情况下需要求出 $[1,N]$ 中每一个数的欧拉函数，这种情况下用公式就非常的慢，可以借助之前线性筛的思想，用 $O(n)$ 的时间复杂度求出每个数的欧拉函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> phi[N]; <span class="comment">// phi[i]:1~i中有多个数和i互斥</span></span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线性筛的过程中求欧拉函数</span></span><br><span class="line"><span class="function">ll <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">// 1~1中和1互斥的只有自己</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			primes[cnt++]=i;</span><br><span class="line">			<span class="comment">// 如果i是质数,那么前i-1个数都和i互质</span></span><br><span class="line">			phi[i]=i<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++) &#123;</span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// i mod pj==0时说明pj是i的质因子</span></span><br><span class="line">				<span class="comment">// phi(pj*i)就等于pj*phi(i)</span></span><br><span class="line">				phi[primes[j]*i]=primes[j]*phi[i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// i mod pj!=0, pj 一定是 i*pj 的质因子</span></span><br><span class="line">			<span class="comment">// phi(pj*i)就等于p(j-1)*phi(i)</span></span><br><span class="line">			phi[primes[j]*i]=phi[i]*(primes[j]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		res+=phi[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 求1~n中每个数的欧拉函数之和</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">get_eulers</span>(n)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="53-欧拉定理">5.3. 欧拉定理</span></h3><ul>
<li>如果 $a$ 与 $n$ 互质，那么 $a^phi(n)\ mod\ n$ 同余 $1$，例如：$a&#x3D;5$, $n&#x3D;6$ 时有：$5^phi(6) &#x3D; 5^2 &#x3D;25，25 mod 6 &#x3D;1</li>
</ul>
<p>​		欧拉定理推论：若 a^phi(p) mod p &#x3D;1，假设p是质数，则有 a^(p-1) mod p&#x3D;1，这也是费马(小)定理。如果n&#x3D;5，那我们可以把1和6视为同样的值，因为1%5 &#x3D;&#x3D; 6%5 &#x3D;&#x3D; 1。</p>
<h2><span id="6-快速幂">6. 快速幂</span></h2><blockquote>
<p>能在 $O(log^k)$ 的时间下快速求出 $a^k\ mod\ p$ 的结果，其中 $a,\ p,\ k&lt;&#x3D;10^9$</p>
</blockquote>
<ul>
<li>对于 $a^k\ mod\ p$，快速幂就是预计算出 $a^{(2^0)}\ mod\ p$ 的结果、 $a^{(2^1)}\ mod\ p$ 的结果、… 、 $a^{2^{(log^k)}}\ mod\ p$ 的结果，一共 $log^k$ 个数，如果要把 $a^k$ 组合出来，其实就是一种二进制优化</li>
<li>比如我们要计算 $4^5\ mod\ 10$ ，就预算出 $4^{2^0}\ mod\ 10$、 $4^{2^1}\ mod\ 10$、 $4^{2^2}\ mod\ 10$ 的结果，$5$ 的二进制又等于 $(101)_2$，所以就是 $4^ {2^0} mod 10 × 4^{2^2}\ mod\ 10$</li>
</ul>
<h3><span id="61-快速幂">6.1. 快速幂</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="comment">// 取2进制最后一位,如果为1,则乘以这一位的位权</span></span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">			res=(ll)res*a%p;</span><br><span class="line">		<span class="comment">// 去掉最后一位</span></span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		a=(ll)a*a%p; <span class="comment">// 位权提升</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="62-快速幂求逆元">6.2. 快速幂求逆元</span></h3><blockquote>
<p>$a&#x2F;b &#x3D; a×x\ (mod\ m)$，找到这个 $x$ ，就可以把除法变为乘法，等式两端约去 $a$，得到 $b×x&#x3D;1(mod\ m)$，即只要找到数字 $x$ ，使得 $b×x\ mod\ m$ 的值等于 $1$，$x$ 就是逆元。</p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231205080313203.png" alt="image-20231205080313203"></p>
<ul>
<li>如果 $p$ 是质数，那么这个式子会变成一个费马定理，所以 $b^{p-1}&#x3D;1(mod p)$，把 $b^(p-1)$ 写成 $b×b^(p-2)$ ， 那么 $b^(p-2)$ 就是 $b\ mod\ p$ 的逆元，又因为最小的质数是 $2$ ，所以 $p-2$ 一定是 $≥0$ 的，所以成立。所以题目变成一个快速幂，求取 $b^{p-2}\ mod\ p$</li>
<li>注意：如果 $p$ 和 $b$ 之间存在倍数关系（不互质）的话，那么 $b×x\ mod\ p$ 一定等于 $0$ ，此时逆元无解；当没有倍数关系时，一定是有解的。<strong>只有当保证 $p$ 是质数时，才能使用快速幂求逆元！</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="comment">// 取2进制最后一位,如果为1,则乘以这一位的位权</span></span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line">			res=(ll)res*a%p;</span><br><span class="line">		<span class="comment">// 去掉最后一位</span></span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		a=(ll)a*a%p; <span class="comment">// 位权提升</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> a,p;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;p;</span><br><span class="line">		<span class="type">int</span> res=<span class="built_in">qmi</span>(a,p<span class="number">-2</span>,p);</span><br><span class="line">		<span class="comment">// 如果a是p的倍数,则没有逆元,因为 a*x mod p一定等于0</span></span><br><span class="line">		<span class="keyword">if</span>(a%p)</span><br><span class="line">			cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="7-扩展欧几里得算法">7. 扩展欧几里得算法</span></h2><h3><span id="71-裴蜀定理">7.1. 裴蜀定理</span></h3><ul>
<li>对于任意一对正整数 $a,b$ ，那么一定存在非零整数 $x,y$ ，使得 $a×x+b×y&#x3D;gcd(a,b)$ ，并且 $a$ 和 $b$ 的最大公约数是 $a$ 和 $b$ 凑出来的最小的正整数</li>
<li>如何证明？$gcd(a,b)$ 是 $a$ 和 $b$ 的最大公约数，那么 $a$ 和 $b$ 的线性组合一定是最大公约数的倍数，那么最小的倍数就是 $1$ 倍呗，所以一定能凑出：$a×x+b×y&#x3D;gcd(a,b)$</li>
</ul>
<h3><span id="72-扩展欧几里得">7.2. 扩展欧几里得</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果b=0,那么gcd(a,b)==a,线性组合即是(1,0)</span></span><br><span class="line">	<span class="keyword">if</span>(!b) &#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	<span class="comment">// ①b*y+(a mod b)*x=gcd(a,b)</span></span><br><span class="line">	<span class="comment">// ②又 a mod b=a-floor(a/b)*b→证明:假设r是a mod b的余数,现在我们要求这个r,a/b=floor(a/b)+r,∴r=a-floor(a/b)*b	</span></span><br><span class="line">	<span class="comment">// 二式相结合,有: a*x+b*(y-floor(a/b)*x)=gcd(a,b),即x的系数不变,但是y要减去那一坨</span></span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,x,y;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">		cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;y&lt;&lt;endl; <span class="comment">// 注意:x和y不唯一</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="73-应用线性同余方程">7.3. 【应用】线性同余方程</span></h3><blockquote>
<p>给定 $a,b,m$，求整数 $x$ 使得  $a×x\ mod\ m&#x3D;b$（如果 $b$ 为 $1$ 就是求逆元了是吧，如果 $m$ 再为质数，就可以用快速幂了），注意 $x$ 的解不唯一。</p>
</blockquote>
<p>$$<br>ax\equiv b(mod\ m) \ 等价于存在整数y∈Z,\ st. \ ax&#x3D;m*y+b \ ,即m的若干倍再加上b<br>\<br>化简得\ ax-my&#x3D;b, \ 把-y令成y’，即有\ ax+my’&#x3D;b, \ 就变成了扩展欧几里得的方程<br>\<br>所以根据扩展欧几里得算法可以求出一组系数x,y’使得ax+my’&#x3D;b, \ d是最大公约数<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b) &#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="comment">// a*x mod m =b</span></span><br><span class="line">		<span class="type">int</span> a,b,m;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="type">int</span> d=<span class="built_in">exgcd</span>(a,m,x,y);</span><br><span class="line">		<span class="comment">// 如果b不是d的倍数方程无解,因为a*x无法通过%m同余等于b</span></span><br><span class="line">		<span class="keyword">if</span>(b%d)</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// 注意这个解不唯一</span></span><br><span class="line">			<span class="comment">// 当b是d的倍数时,方程两边同时初一d,得到 a/d*x=b/d(mod m/d),由于</span></span><br><span class="line">			<span class="comment">// a/d和m/d是互质的,可以找到a/d的逆元x&#x27;,使得(a/b)*x&#x27;=1(mod m/d)</span></span><br><span class="line">			<span class="comment">// 所以让 b/d乘以这个米远x&#x27;得到x*(b/d),这就是x的一个特解</span></span><br><span class="line">			cout&lt;&lt;(ll)x*(b/d)%m&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="74-应用中国剩余定理">7.4. 【应用】中国剩余定理</span></h3><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231205095348192.png" alt="image-20231205095348192"></p>
<ul>
<li>注意：$m_1,\ ···\ ,m_n$ 之间是两两互质的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)&#123;</span><br><span class="line">		x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LL d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	LL x=<span class="number">0</span>,m1,a1;</span><br><span class="line">	cin&gt;&gt;a1&gt;&gt;m1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		LL m2,a2;</span><br><span class="line">		cin&gt;&gt;a2&gt;&gt;m2;</span><br><span class="line">		LL k1,k2;</span><br><span class="line">		LL d=<span class="built_in">exgcd</span>(a1,a2,k1,k2);</span><br><span class="line">		<span class="keyword">if</span>((m2-m1)%d)&#123;</span><br><span class="line">			x=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新状态</span></span><br><span class="line">		k1*=(m2-m1)/d;</span><br><span class="line">		LL t=a2/d;</span><br><span class="line">		<span class="comment">// 将解变成一个最小的正整数解</span></span><br><span class="line">		k1=(k1%t+t)%t;</span><br><span class="line">		</span><br><span class="line">		x=k1*a1+m1;</span><br><span class="line">		<span class="comment">// 更新a和m,k只是个变量,不用管,取余的时候会自动消失</span></span><br><span class="line">		m1=k1*a1+m1;</span><br><span class="line">		a1=<span class="built_in">abs</span>(a1/d*a2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(x!=<span class="number">-1</span>) x=(m1%a1+a1)%a1;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="8-高斯消元">8. 高斯消元</span></h2><h3><span id="81-高斯消元解线性方程组">8.1. 高斯消元解线性方程组</span></h3><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231205234751191.png" alt="image-20231205234751191"></p>
<ul>
<li>这种题一般有 $SPJ$ 优化，即 $0.00$ 和 $-0.00$ 都认为是 $0$，即都认为是相同的内容，因为在数学上 $+0$ 和 $-0$ 代表的概念和意义都是一样的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> <span class="comment">// fabs() = float abs = 浮点数的绝对值，相对应的，整数的绝对值即为abs()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯消元的四部操作:</span></span><br><span class="line"><span class="comment">// 1:找到绝对值最大的一行(为了代码的稳定性)</span></span><br><span class="line"><span class="comment">// 2:将该行移到最上面</span></span><br><span class="line"><span class="comment">// 3:将改行第一个数变为1</span></span><br><span class="line"><span class="comment">// 4:将最上面一行下面的所有行的第c列变为0</span></span><br><span class="line"><span class="comment">// 以上4步均可用初等行变换完成</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>; <span class="comment">// 防止出现精度问题</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(; c &lt; n; c++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = r;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ ) <span class="comment">// 第一步，找绝对值最大的行</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">				t = i; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>; <span class="comment">// 代表这一列已经被处理过了</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = c; i &lt;= n; i++) <span class="comment">// 第二步 </span></span><br><span class="line">			<span class="built_in">swap</span>(a[t][i], a[r][i]); <span class="comment">// 将这一行调到最上面</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= c; i--) <span class="comment">// 第三步</span></span><br><span class="line">			a[r][i] /= a[r][c]; <span class="comment">// 要倒着算，否则会影响后面的数</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 第四步</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; eps)  <span class="comment">// 如果是0就不用操作了</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= c; j--)</span><br><span class="line">				&#123;</span><br><span class="line">					a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(r &lt; n) <span class="comment">// 方程数 &lt; n</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n]) &gt; eps) <span class="comment">// 0 != 0</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无数解, 0=0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="comment">// 有解从下往上回代</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j ++ )</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="number">0</span>)  <span class="comment">// 有唯一解</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 最后输出的就是每个未知解的值:&gt;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n]) &lt; eps) a[i][n] = <span class="number">0.00</span>; <span class="comment">// 避免输出-0.00</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>); <span class="comment">// 无数解</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>); <span class="comment">// 无解</span></span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3><span id="82-高斯消元解异或线性方程组">8.2. 高斯消元解异或线性方程组</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231205235928312.png" alt="image-20231205235928312" style="zoom:80%;">

<ul>
<li>系数和常数的值都为 $0$ 或 $1$ ，每个未知数的取值也为 $0$ 或 $1$ ，方程中间是异或运算：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心思想:异或→不进位的加法</span></span><br><span class="line"><span class="comment">// 等式与等式之间的异或要一起进行才能保证等式左右两边依然是相等关系</span></span><br><span class="line"><span class="comment">// a^b^c=x,d^f=y,则有a^b^d^c^f=x^y</span></span><br><span class="line"><span class="comment">// 1. 左下角消0</span></span><br><span class="line"><span class="comment">// 1.1 枚举列</span></span><br><span class="line"><span class="comment">// 1.2 找第一个非零行</span></span><br><span class="line"><span class="comment">// 1.3 交换</span></span><br><span class="line"><span class="comment">// 1.4 把同列下面行消零(异或)</span></span><br><span class="line"><span class="comment">// 2. 判断3种情况</span></span><br><span class="line"><span class="comment">// 2.1 唯一解</span></span><br><span class="line"><span class="comment">// 2.2 秩&lt;n</span></span><br><span class="line"><span class="comment">// 2.2.1 有矛盾 无解</span></span><br><span class="line"><span class="comment">// 2.2.2 无矛盾 无穷多解</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>; <span class="comment">// 最多110个系数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c,r;</span><br><span class="line">	<span class="keyword">for</span>(c=<span class="number">0</span>,r=<span class="number">0</span>;c&lt;n;c++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 找主元</span></span><br><span class="line">		<span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=r;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span>(a[i][c])</span><br><span class="line">			&#123;</span><br><span class="line">				t=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 交换主元行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=c;j&lt;=n;j++) <span class="built_in">swap</span>(a[r][j],a[t][j]);</span><br><span class="line">		<span class="comment">// 左下角消</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=r<span class="number">+1</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span>(a[i][c])<span class="comment">//漏了</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=c;j--)<span class="comment">//漏了</span></span><br><span class="line">					a[i][j] ^= a[r][j];</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断</span></span><br><span class="line">	<span class="keyword">if</span>(r&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=r;i&lt;n;i++) <span class="comment">// i=r</span></span><br><span class="line">			<span class="keyword">if</span>(a[i][n])</span><br><span class="line">				<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 消右上角</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)</span><br><span class="line">			<span class="comment">//如果是0 就不用下面的a[j][j] 来^a[i][j]了</span></span><br><span class="line">			<span class="comment">//如果不是0 才需要用第j行第j列a[j][j]来^第i行第j列a[i][j] </span></span><br><span class="line">			<span class="comment">//进而进行整行row[i]^row[j] 间接导致 a[i][n]^a[j][n]</span></span><br><span class="line">			<span class="keyword">if</span>(a[i][j])</span><br><span class="line">				a[i][n]^=a[j][n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout &lt;&lt; a[i][n] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="9-组合数学">9. 组合数学</span></h2><h3><span id="91-组合数">9.1. 组合数</span></h3><h4><span id="911-朴素法">9.1.1. 朴素法</span></h4><blockquote>
<p>时间复杂度 $O(n^2)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+10</span>;</span><br><span class="line"><span class="comment">// 初始化C数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从0开始赋值,是为了让C11=C[0][0]+c[0][1]==1,正确的得到1</span></span><br><span class="line">	<span class="comment">// 其实就是把C[N][1~N]全部算出来了而已</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!j)</span><br><span class="line">				c[i][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="912-快速幂">9.1.2. 快速幂</span></h4><blockquote>
<p>时间复杂度 $O(a×log^{mod})$</p>
</blockquote>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206090536947.png" alt="image-20231206090536947" style="zoom:80%;">

<ul>
<li>三个阶乘级别的数都可以用快速幂迅速算出，在对组合数进行运算时，我们要对组合数进行模运算，直接用除法是不行的，因为除法得到的结果不一定总为整数（可能是浮点数），此时取模就没有意义，需要找到分母的乘法逆元，然后将除法转换为乘法，快速幂求逆元不就是费马小定理吗，注意<strong>模数必须是质数</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>; <span class="comment">// 这是一个质数,所以与2~1e9+6都互质</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>; <span class="comment">// 数字范围</span></span><br><span class="line">ll fac[N]; <span class="comment">// 存储阶乘,基于数组实现记忆化</span></span><br><span class="line">ll infac[N]; <span class="comment">// 存储i!的逆元,infac[i]=(i!)^(-1) mod p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂模板</span></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll k,ll p)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>==<span class="number">1</span>)</span><br><span class="line">			res=res*a%p;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		a=a*a%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	fac[<span class="number">0</span>]=infac[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 0的阶乘以及逆元都是1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">		fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		infac[i]=(ll)infac[i<span class="number">-1</span>]*<span class="built_in">qmi</span>(i,mod<span class="number">-2</span>,mod)%mod; <span class="comment">// 根据费马小定理求到i!逆元</span></span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="comment">// cab=a!/(b!)*(a-b)!</span></span><br><span class="line">		cout&lt;&lt;(ll)fac[a]*infac[b]%mod*infac[a-b]%mod&lt;&lt;endl; <span class="comment">// 通过乘法逆元转换为乘法运算</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="913-卢卡斯定理">9.1.3. 卢卡斯定理</span></h4><blockquote>
<p>时间复杂度 $O(plog_pN)$</p>
</blockquote>
<ul>
<li>对任意非负整数 $a,b$ 和**质数$p$**，有：</li>
<li>将 $m$ 和 $n$ 用 $p$ 进制表示，复杂度为 $O(log_pn)$，如果再用快速幂求逆元计算组合数，复杂度为$O(p)$，故总时间复杂度为$O(plog_pN)$，这里的 $N$ 是 $a,b$ 的时间复杂度约为$10^{18}$，如果预处理阶乘和阶乘逆元，时间复杂度能下降至$O(p+log_pN)$</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206093200137.png" alt="image-20231206093200137" style="zoom:80%;">

<ul>
<li>其证明需要用到两个重要等式，这里不再证明：</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206093244681.png" alt="image-20231206093244681" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)res = (LL)res*a%p;</span><br><span class="line">		a = (LL)a*a%p;</span><br><span class="line">		k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span><span class="comment">//自变量类型int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;a)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//漏了边界条件</span></span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=a;i&lt;=b;i++,j--)<span class="comment">//i&lt;=b而不是&lt;</span></span><br><span class="line">	&#123;</span><br><span class="line">		res = (LL)res*j%p;</span><br><span class="line">		res = (LL)res*<span class="built_in">qmi</span>(i,p<span class="number">-2</span>,p)%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对公式敲</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a,LL b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;p &amp;&amp; b&lt;p)<span class="keyword">return</span> <span class="built_in">C</span>(a,b,p);<span class="comment">//lucas递归终点是C_&#123;bk&#125;^&#123;ak&#125;</span></span><br><span class="line">	<span class="keyword">return</span> (LL)<span class="built_in">C</span>(a%p,b%p,p)*<span class="built_in">lucas</span>(a/p,b/p,p)%p;<span class="comment">//a%p后肯定是&lt;p的,所以可以用C(),但a/p后不一定&lt;p 所以用lucas继续递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		LL a,b;</span><br><span class="line">		<span class="type">int</span> p;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">lucas</span>(a,b,p) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4><span id="914-线性筛高精乘">9.1.4. 线性筛+高精乘</span></h4><blockquote>
<p>时间复杂度近似 $O(n)$</p>
</blockquote>
<ul>
<li>题目变得更加简单粗暴，实现方法：由于 $a$ 和 $b$ 的最大取值是 $5000$，所以用线性筛在 $[1,5000]$ 的范围内筛选出质数，求每个质数的次数，再用高精度乘法把所有质因子乘上：</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206144822955.png" alt="image-20231206144822955" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N],cnt; <span class="comment">// primes[N]:依次存放1~N中出现的质数</span></span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])primes[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// ==0每次漏</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对p的各个&lt;=a的次数算整除下取整倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		res+=n/p;</span><br><span class="line">		n/=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度乘</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		t += a[i] * b;</span><br><span class="line">		c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (t)</span><br><span class="line">	&#123;</span><br><span class="line">		c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// while(C.size()&gt;1 &amp;&amp; C.back()==0) C.pop_back();//考虑b==0时才有pop多余的0 b!=0不需要这行</span></span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="built_in">get_primes</span>(a);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = primes[i];</span><br><span class="line">		sum[i] = <span class="built_in">get</span>(a,p)-<span class="built_in">get</span>(a-b,p)-<span class="built_in">get</span>(b,p); <span class="comment">// 是a-b不是b-a</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ ) <span class="comment">// primes[i]的次数</span></span><br><span class="line">			res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="92-卡特兰数">9.2. 卡特兰数</span></h3><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206150423021.png" alt="image-20231206150423021"></p>
<ul>
<li>若把 $0$ 和 $1$ 置于坐标轴中，起点定于原点，若 $0$ 表示向右走，$1$ 表示向上走，那么任何前缀中 $0$ 的个数不少于 $1$ 的个数就转换为：对于路径上的任意一点，横坐标大于等于纵坐标，题目所求即为这样的合法路径数量：</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/6828_9476d97655-Catalan.png" alt="Catalan.png" style="zoom: 50%;">

<ul>
<li>由图可知，任何一条不合法的路径（黑色路径），都对应一条从 $(0,0)$ 走到 $(n-1,n+1)$ 的路径（灰色路径），而任何一条从 $(0,0)$ 走到 $(n-1,n+1)$ 的路径，也对应一条从$(0,0)$ 走到 $(n,n)$ 的不合法路径：$ ans&#x3D;C_{2n}n-C_{2n}{n-1}&#x3D;C_{2n}n&#x2F;n+1$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fact[N], infact[N]; <span class="comment">// fact[i]:i!的阶乘,infact[i]:i!阶乘逆元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % mod;</span><br><span class="line">		a = (LL)a * a % mod;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">		infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">ksm</span>(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> res = (LL)fact[<span class="number">2</span> * n] * infact[n] % mod * infact[n] % mod * <span class="built_in">ksm</span>(n + <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="10-容斥原理">10. 容斥原理</span></h2><ul>
<li>注意欧拉函数的推导运用到了容斥原理，欧拉函数求取的是 $[1,n]$ 当中与 $n$ 互质的数的个数：</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206152700721.png" alt="image-20231206152700721"></p>
<ul>
<li>比如 $n&#x3D;10,\ p1&#x3D;2,\ p2&#x3D;3$，求$[1,10]$中满足能整除 $p_1$ 或 $p_2$ 的个数即：$2,\ 3,\ 4,\ 6,\ 8,\ 9,\ 10$ 共 $7$ 个</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231206153027100.png" alt="image-20231206153027100" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> p[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; p[i];</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 枚举从1 到 1111...(m个1)的每一个集合状态,(至少选中一个集合)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">1</span>; <span class="comment">// 选中集合对应质数的乘积</span></span><br><span class="line">		<span class="type">int</span> s = <span class="number">0</span>; <span class="comment">// 选中的集合数量</span></span><br><span class="line">		<span class="comment">// 枚举当前状态的每一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">			<span class="comment">// 选中一个集合</span></span><br><span class="line">			<span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 乘积大于n,则n/t = 0,跳出这轮循环</span></span><br><span class="line">				<span class="keyword">if</span>((LL)t * p[j] &gt; n) &#123;    </span><br><span class="line">					t = <span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				s++; <span class="comment">// 有一个1,集合数量+1</span></span><br><span class="line">				t *= p[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="number">-1</span>) </span><br><span class="line">			<span class="keyword">continue</span>;  	</span><br><span class="line">		<span class="keyword">if</span>(s &amp; <span class="number">1</span>) </span><br><span class="line">			res += n / t; <span class="comment">// 选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量</span></span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			res -= n / t; <span class="comment">// 反之则为 -1</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构</title>
    <url>/2024/11/08/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="基础数据结构">基础数据结构</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8">1. 链表与邻接表</a><ul>
<li><a href="#11-%E5%8D%95%E9%93%BE%E8%A1%A8">1.1. 单链表</a></li>
<li><a href="#12-%E5%8F%8C%E9%93%BE%E8%A1%A8">1.2. 双链表</a></li>
</ul>
</li>
<li><a href="#2-%E5%8D%95%E8%B0%83%E6%A0%88">2. 单调栈</a></li>
<li><a href="#3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">3. 单调队列</a></li>
<li><a href="#4-kmp%E7%AE%97%E6%B3%95">4. KMP算法</a></li>
<li><a href="#5-trie%E6%A0%91">5. Trie树</a></li>
<li><a href="#6-%E5%B9%B6%E6%9F%A5%E9%9B%86">6. 并查集</a></li>
<li><a href="#7-%E5%A0%86">7. 堆</a><ul>
<li><a href="#71-%E5%A0%86%E6%8E%92%E5%BA%8F">7.1. 堆排序</a></li>
<li><a href="#72-%E6%A8%A1%E6%8B%9F%E5%A0%86">7.2. 模拟堆</a></li>
</ul>
</li>
<li><a href="#8-hash%E8%A1%A8">8. Hash表</a><ul>
<li><a href="#81-%E6%8B%89%E9%93%BE%E6%B3%95">8.1. 拉链法</a></li>
<li><a href="#82-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95">8.2. 开放寻址法</a></li>
<li><a href="#83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%93%88%E5%B8%8C">8.3. 字符串前缀哈希</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-链表与邻接表">1. 链表与邻接表</span></h2><h3><span id="11-单链表">1.1. 单链表</span></h3><blockquote>
<p>最主要的应用是邻接表，用于存储图和树</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="comment">// 注意90%的题都是用数组来模拟数据结构</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="comment">// head:头结点的下标</span></span><br><span class="line"><span class="comment">// e[i]:表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i]:表示节点i的下一个地址</span></span><br><span class="line"><span class="comment">// idx:存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	head=<span class="number">-1</span>; <span class="comment">// 初始时没有头结点</span></span><br><span class="line">	idx=<span class="number">0</span>; <span class="comment">// 从0号点开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx]=x,ne[idx]=head,head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> k,x;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			<span class="built_in">add_to_head</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 注意,这里是k-1是因为对于题目来说</span></span><br><span class="line">		<span class="comment">// 第k个插入的点的下标是k-1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;k;</span><br><span class="line">			<span class="keyword">if</span>(!k)</span><br><span class="line">				head=ne[head]; <span class="comment">// 如果是头结点的处理方法</span></span><br><span class="line">			<span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">			<span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">		cout&lt;&lt;e[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-双链表">1.2. 双链表</span></h3><blockquote>
<p>用于优化单链表问题的时间复杂度</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的数组表示形式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="comment">// head:头结点</span></span><br><span class="line"><span class="comment">// e[i]:存储点i的值</span></span><br><span class="line"><span class="comment">// l[i]:存储点i的左节点</span></span><br><span class="line"><span class="comment">// r[i]:存储点i的右节点</span></span><br><span class="line"><span class="comment">// idx:存储当前遍历到哪个点了</span></span><br><span class="line"><span class="type">int</span> head,e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意:在该模板中,节点0是最后一个节点,节点1是第一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 自带两个点0和1,互为左右端点</span></span><br><span class="line">	l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	r[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	idx=<span class="number">2</span>; <span class="comment">// 下一个点的编号是2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表插入节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx]=x;</span><br><span class="line">	l[idx]=a;</span><br><span class="line">	r[idx]=r[a];</span><br><span class="line">	<span class="comment">// 顺序不能反</span></span><br><span class="line">	l[r[a]]=idx;</span><br><span class="line">	r[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	r[l[a]]=r[a];</span><br><span class="line">	l[r[a]]=l[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> k,x;</span><br><span class="line">		string op;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			<span class="built_in">insert</span>(<span class="number">0</span>,x); <span class="comment">// 在最左侧插入</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			<span class="built_in">insert</span>(l[<span class="number">1</span>],x); <span class="comment">// 在最右侧插入</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为队头是1,所以第k个插入的元素的下标是</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;k;</span><br><span class="line">			<span class="built_in">remove</span>(k<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左插,直接在第k+1个元素的左节点右插即可</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;IL&quot;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">			<span class="built_in">insert</span>(l[k<span class="number">+1</span>],x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 右插直接调用insert</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">			<span class="built_in">insert</span>(k<span class="number">+1</span>,x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 只要没有遍历到头结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])</span><br><span class="line">		cout&lt;&lt;e[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-单调栈">2. 单调栈</span></h2><blockquote>
<p>用于一维数组中，找到每个元素左边所有比他小的且离它本身最近的元素的下标</p>
</blockquote>
<ul>
<li>维护一个栈，当遍历到ai的时候，栈中的元素就是 $a_,\ a_2,\ …\ ,a_{i-1}$，如果对于 $[a_1~a_{i-1}]$ 中的元素，假设有 $a_x$ 和$a_y$ ，其中 $x&lt;&#x3D;y$ 且 $a_x&gt;&#x3D;a_y$ ，则可以将 $a_x$ 这个元素从栈中删去，即可得到一个单调栈</li>
<li>所以，每次弹出栈顶，只要栈顶是 $&gt;&#x3D;a_i$ 的，就可以删掉，直到找到一个 $stack[tt]&lt;a_i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> stk[N],tt; <span class="comment">// tt:栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 比赛建议用scanf和printf</span></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="comment">// 只要栈顶非空且栈顶&gt;=x,则弹出并删除此栈顶</span></span><br><span class="line">		<span class="keyword">while</span>(tt&amp;&amp;stk[tt]&gt;=x)</span><br><span class="line">			tt--;</span><br><span class="line">		<span class="keyword">if</span>(tt)</span><br><span class="line">			cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 找不到呗</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 把数据放进stk</span></span><br><span class="line">		stk[++tt]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-单调队列">3. 单调队列</span></h2><blockquote>
<p>用于求滑动窗口中的最大值和最小值</p>
</blockquote>
<ul>
<li>只要队列中存在前一个数比后一个数大，那么前一个数一定没有用，这样去掉过后就会形成一个严格单调上升的序列，每一次弹出队头即可。</li>
<li>注意99%的情况下比赛方不开 $O2$ 优化，如果不开 $O2$ 优化的话$STL$ 库就会比数组的模拟慢一些。自我感觉比单调栈、$KMP$ 算法都还要难理解。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N]; <span class="comment">// q:单调队列</span></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// n:元素个数,k:窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>; <span class="comment">// 队头队尾初始化为0和-1</span></span><br><span class="line">	<span class="comment">// 处理每一个窗口</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="comment">// 检查队列的头部是否已经滑出窗口,如果是,则将队列头部向前移动一位</span></span><br><span class="line">		<span class="comment">// hh&lt;=tt:队列不存在,i-k+1&gt;q[hh]:</span></span><br><span class="line">		<span class="comment">// 因为每次只能前进一格,所以不用while循环</span></span><br><span class="line">		<span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k<span class="number">+1</span>&gt;q[hh])</span><br><span class="line">			hh++;</span><br><span class="line">		<span class="comment">// 队列非空且队尾元素小于当前元素,将队尾出队</span></span><br><span class="line">		<span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&lt;=a[i])</span><br><span class="line">			tt--;</span><br><span class="line">		<span class="comment">// 当前元素入队</span></span><br><span class="line">		q[+tt]=i;</span><br><span class="line">		<span class="comment">// 在窗口满时,输出窗口的最大值</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)</span><br><span class="line">			cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-kmp算法">4. KMP算法</span></h2><blockquote>
<p>仔细理解next数组的含义，想加强理解看AcWing数据结构(一)的2:30:50开始</p>
</blockquote>
<ul>
<li>$next[i]&#x3D;j$，表明的是对于子串 $p$ ，$p[1,\ …\ , j]$ 的元素等于 $p[i-j+1,\ …\ , i]$ 的元素，其中 $i$ 是源串 $s$ 的指针，$j$ 是子串 $p$ 的指针，即 $next$ 函数仅于自身这个子串有关，而与源串无关。其实就是找到，以 $j$ 这个点为终点的，后缀与前缀的最大公共长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>,M=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// i不用回退,只遍历一遍,j回退到next[j]</span></span><br><span class="line"><span class="comment">// p:子串,s:源串,ne:子串的next数组</span></span><br><span class="line"><span class="comment">// next数组的性质:前后值最多增加1,减少没有限制</span></span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;p<span class="number">+1</span>&gt;&gt;m&gt;&gt;s<span class="number">+1</span>; <span class="comment">// char:可以+1,下标从1开始</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 求next数组过程</span></span><br><span class="line">	<span class="comment">// ne[1]=0不用算(只能回退到0),所以i从2开始</span></span><br><span class="line">	<span class="comment">// j和下面一样,是试图与i匹配的子串,即源串和子串都是本身</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 只要不匹配,退而求其次</span></span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j];</span><br><span class="line">		<span class="comment">// 对眼,前进一步</span></span><br><span class="line">		<span class="keyword">if</span>(p[i]==p[j<span class="number">+1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">// 填充next数组</span></span><br><span class="line">		ne[i]=j;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kmp匹配过程</span></span><br><span class="line">	<span class="comment">// i枚举的是当前的s[i],j从0开始</span></span><br><span class="line">	<span class="comment">// p中和当前s试图匹配的是p[j+1],因为j从0开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="comment">// 1:回退</span></span><br><span class="line">		<span class="comment">// 只要j没有退回起点(不用重新匹配)</span></span><br><span class="line">		<span class="comment">// 并且当前s[i]不能和当前p[j+1]匹配的话</span></span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s[i]!=p[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j];</span><br><span class="line">		<span class="comment">// 匹配了则直接找下一位</span></span><br><span class="line">		<span class="keyword">if</span>(s[i]==p[j<span class="number">+1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">// 输出所有出现位置的起始下标</span></span><br><span class="line">		<span class="keyword">if</span>(j==n) &#123;</span><br><span class="line">			<span class="comment">// 匹配成功,i减去子串长度,即是起始下标(从0开始)</span></span><br><span class="line">			cout&lt;&lt;i-n&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			j=ne[j]; <span class="comment">// 更新ne[j],下次可以回退到这里</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-trie树">5. Trie树</span></h2><blockquote>
<p>高效存储和查找字符串集合的数据结构</p>
</blockquote>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/31041_aed49a42ad-Trie2.PNG" alt="Trie2.PNG" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数,如英文字母等等</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>; <span class="comment">// 字符串总长度不超过1e5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// son[i][j]=2: i是第几层,根节点从0开始,j代表字母如&#x27;a&#x27;=0,2是当前记录到的哪个点的编号</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>]; <span class="comment">// 只包含小写字母,所以每个最多向外延申26个节点,每个节点的儿子是什么</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// 以当前这个点结尾的单词有多少个</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">char</span> str[N]; <span class="comment">// 每次的字符串</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 将a~z映射到0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!son[p][u])</span><br><span class="line">			son[p][u]=++idx; <span class="comment">// 没有该子节点就创建一个</span></span><br><span class="line">		p=son[p][u]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取字符串,查询其在字符串集合中出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!son[p][u])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 该节点不存在,字符串不存在</span></span><br><span class="line">		p=son[p][u]; <span class="comment">// 如果找到了继续往下查询</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p]; <span class="comment">// 返回字符串出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;str;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">			<span class="built_in">insert</span>(str);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(str)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="6-并查集">6. 并查集</span></h2><blockquote>
<p>快速的执行以下操作：将两个集合合并、询问两个元素是否存在一个集合中，时间近乎 $O(1)$</p>
</blockquote>
<ul>
<li><p>基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，fa[x]表示x的父节点。</p>
</li>
<li><p>Q1：如何判断树根？ </p>
<ul>
<li>A1：<code>if(fa[x]==x)</code></li>
</ul>
</li>
<li><p>Q2：如何求x的集合编号？</p>
<ul>
<li>A2：<code>while(fa[x]!=x) x=fa[x]</code>，每次都要用一个while循环来找很麻烦，直接路径压缩，让所有点都指向自己的祖先节点就行了</li>
</ul>
</li>
<li><p>Q3：如何合并两个区间？fa[x]是x的集合编号，fa[y]是y的集合编号？</p>
<ul>
<li>A3：fa[x]&#x3D;y 或者 fa[y]&#x3D;x 都可</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// 返回x的祖先节点</span></span><br><span class="line"><span class="comment">// 路径压缩版</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果父节点不是本身</span></span><br><span class="line">	<span class="keyword">if</span>(fa[x]!=x)</span><br><span class="line">		<span class="comment">// 把父节点更新成自己的父节点</span></span><br><span class="line">		fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">	<span class="comment">// 返回父节点的编号</span></span><br><span class="line">	<span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接a/b两个节点所在的集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">// a的祖先节点变成b的祖先节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 初始时所有点都自成集合</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		fa[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">			<span class="built_in">merge</span>(a,b);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="7-堆">7. 堆</span></h2><ol>
<li>插入一个数，<code>heap[++size]=x, up(size)</code></li>
<li>求集合中的最小值，<code>heap[1]</code></li>
<li>删除最小值，<code>heap[1]=heap[size], size--, down(1)</code> ：用最后一个元素覆盖第一个元素，再把size减1，再维护根节点</li>
<li>删除任意一个元素，<code>heap[k]=heap[size], size--, down(k), up(k)</code>：删除一个元素，可能上升可能下降，down和up虽然都写但只会执行其中的一个</li>
<li>修改任意一个元素，<code>heap[k]=x, down(k), up(k)</code></li>
</ol>
<ul>
<li>STL库中的堆只能实现前三个，堆是一棵完全二叉树，在模板中用一维数组来维护这棵完全二叉树</li>
</ul>
<h3><span id="71-堆排序">7.1. 堆排序</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆的down操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t=u;</span><br><span class="line">	<span class="comment">// 如果左孩子比父节点更小,则记录</span></span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>&lt;=sz &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t])</span><br><span class="line">		t=u*<span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 如果右孩子比父节点更小,则记录</span></span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=sz &amp;&amp; h[u*<span class="number">2</span><span class="number">+1</span>]&lt;h[t])</span><br><span class="line">		t=u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 说明需要交换节点</span></span><br><span class="line">	<span class="keyword">if</span>(u!=t) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">		<span class="built_in">down</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 比较简单,因为u节点只用跟父节点相比较</span></span><br><span class="line">	<span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u]) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(h[u/<span class="number">2</span>],h[u]);</span><br><span class="line">		u/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;h[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	sz=n;</span><br><span class="line">	<span class="comment">// 只用进行log(n)次down操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i;i--)</span><br><span class="line">		<span class="built_in">down</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		cout&lt;&lt;h[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 把最小值弹出</span></span><br><span class="line">		<span class="comment">// 删除头结点的方法:</span></span><br><span class="line">		h[<span class="number">1</span>]=h[sz]; <span class="comment">// 用最后一个节点覆盖头结点,再把sz--</span></span><br><span class="line">		sz--;</span><br><span class="line">		<span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">// 再down一下即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="72-模拟堆">7.2. 模拟堆</span></h3><blockquote>
<p>实现以上物种操作</p>
</blockquote>
<ul>
<li>讲道理，感觉不用理解得特别深</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// ph[k]:第k个插入点,在堆内的下标是什么,ph[j]=k,第j个插入的点在堆内的下标是k</span></span><br><span class="line"><span class="comment">// hp[k]:堆内的某个点,是第几个插入点,hp[k]=j,堆里面下标是j的点对应的在ph中的下标是j</span></span><br><span class="line"><span class="comment">// p:下标(指针),h:(heap)堆,hp和ph是数组指针和堆之间的双向映射</span></span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要完成操作4和操作5,必须构建ph和hp之间的映射关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构交换两个点之间的元素的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">	<span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">	<span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t=u;</span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span>&lt;=sz &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t])</span><br><span class="line">		t=u*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(u*<span class="number">2</span><span class="number">+1</span>&lt;=sz &amp;&amp; h[u*<span class="number">2</span><span class="number">+1</span>]&lt;h[t])</span><br><span class="line">		t=u*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(u!=t) &#123;</span><br><span class="line">		<span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">		<span class="built_in">down</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u]) &#123;</span><br><span class="line">		<span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">		u/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> m; <span class="comment">// 记录第几个插入的数</span></span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		string op;</span><br><span class="line">		<span class="type">int</span> k,x;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			sz++;</span><br><span class="line">			m++;</span><br><span class="line">			ph[m]=sz,hp[sz]=m;</span><br><span class="line">			h[sz]=x;</span><br><span class="line">			<span class="built_in">up</span>(sz);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;PM&quot;</span>) &#123;</span><br><span class="line">			cout&lt;&lt;h[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;DM&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">heap_swap</span>(<span class="number">1</span>,sz);</span><br><span class="line">			sz--;</span><br><span class="line">			<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">			cin&gt;&gt;k;</span><br><span class="line">			k=ph[k];</span><br><span class="line">			<span class="built_in">heap_swap</span>(k,sz);</span><br><span class="line">			sz--;</span><br><span class="line">			<span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">			k=ph[k];</span><br><span class="line">			h[k]=x;</span><br><span class="line">			<span class="built_in">down</span>(k),<span class="built_in">up</span>(k); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="8-hash表">8. Hash表</span></h2><blockquote>
<p>存储结构：开放寻址法、拉链法，另一个应用是字符串哈希方式</p>
</blockquote>
<ul>
<li>Hash表也称散列表，有两种处理地址冲突的方法，所以也有两种数据结构来存储，分别是开放寻址法和拉链法</li>
<li>Hash表的算法时间复杂度一般都是 $O(1)$ 的，所以一般不手动排序，这样时间复杂度反而会扩大成 $O(nlog^n)$</li>
<li>STL库中的哈希表数据结构是 $unorder_map$，通常不使用，因为会比手写的 $Hash$ 表慢 $3$ 倍左右。</li>
</ul>
<h3><span id="81-拉链法">8.1. 拉链法</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/51d73ae3b6e94aea880ac82ff4ca85e5.png" alt="在这里插入图片描述" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希:取模这个数要尽量取质数,并且离2的n次方尽可能远,这样冲突的概率才最小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+3</span>; <span class="comment">// 大于1e5的第一个质数</span></span><br><span class="line"><span class="comment">// h[i]:哈希表的第i槽,是一个邻接表</span></span><br><span class="line"><span class="comment">// e[i]:第i个节点的值</span></span><br><span class="line"><span class="comment">// ne[i]:下一条边的下标</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 注意x最小可以取10^-9,所以先%N,再加上N才会一定得到一个正数</span></span><br><span class="line">	<span class="comment">// 把x映射到0~1e5+3之间</span></span><br><span class="line">	<span class="comment">// x%N有可能得到负数,所以+N变回正数</span></span><br><span class="line">	<span class="type">int</span> k=(x%N+N)%N;</span><br><span class="line">	<span class="comment">// 链式前向星头插法</span></span><br><span class="line">	e[idx]=x,ne[idx]=h[k],h[k]=idx++;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k=(x%N+N)%N; <span class="comment">// 求得x的映射地址</span></span><br><span class="line">	<span class="comment">// 去这条链上找目标值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(e[i]==x)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	string op;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>)</span><br><span class="line">			<span class="built_in">insert</span>(x);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(x))</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="82-开放寻址法">8.2. 开放寻址法</span></h3><ul>
<li>实际上用的更多的哈希表做法，也更好理解，因为只用开一个数组，但是这个一维数组开的空间大小一般是题目范围的2~3倍。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为第一个大于2e5(1e5*2,这是一个经验值)的质数是2e5+3</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> null=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x在哈希表中已存在,返回x所在的位置</span></span><br><span class="line"><span class="comment">// 如果x在哈希表中不存在,返回它应该存储的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k=(x%N+N)%N; <span class="comment">// k是x预期存储的地址</span></span><br><span class="line">	<span class="comment">// 如果有人占用了这个位置并且占用这个位置的不是我自己的话</span></span><br><span class="line">	<span class="keyword">while</span>(h[k]!=null &amp;&amp; h[k]!=x) &#123;</span><br><span class="line">		k++; <span class="comment">// 就向下找下一个位置</span></span><br><span class="line">		<span class="comment">// 如果找满了都找不到,则赋值又从第一个位置开始找</span></span><br><span class="line">		<span class="comment">// 并且这个过程是一定会停止的,因为坑比人多</span></span><br><span class="line">		<span class="keyword">if</span>(k==N) </span><br><span class="line">			k=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1:因为N是1e5,先找大于2e5的第一个质数是多少</span></span><br><span class="line"><span class="comment">//	for(int i=2e5;;i++) &#123;</span></span><br><span class="line"><span class="comment">//		bool flag=true;</span></span><br><span class="line"><span class="comment">//		for(int j=2;j*j&lt;=i;j++) &#123;</span></span><br><span class="line"><span class="comment">//			if(i%j==0) &#123;</span></span><br><span class="line"><span class="comment">//				flag=false;</span></span><br><span class="line"><span class="comment">//				break;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		if(flag) &#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//			break;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		string op;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&quot;I&quot;</span>)</span><br><span class="line">			h[<span class="built_in">find</span>(x)]=x; <span class="comment">// 插入一个值</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(h[<span class="built_in">find</span>(x)]==null)</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="83-字符串前缀哈希">8.3. 字符串前缀哈希</span></h3><blockquote>
<p>h[i] 代表前i个字符的哈希值</p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231124144802886.png" alt="image-20231124144802886"></p>
<ul>
<li><p>对于一个字符串”ABCD”，我们可以把四个数字看成p进制的1234，那么ABCD就可以从p进制转换成十进制，得到的结果应该是 $1×p^3 + 2×p^2 + 3×p^1 + 4×p^0$，再mod一个Q，就可以把任意一个字符串的值映射到$[0,Q-1]$的数值。</p>
</li>
<li><p>注意一般情况下，1）不能把一个字母映射成0，比如把字母A映射成0，那么AA的值也是0，这样多个字符就可能被映射成一个值；2）假设人品足够好，不存在冲突，设置$p&#x3D;131$或$13331$，$Q&#x3D;2^{64}$，在这种情况下99%情况下不会冲突；3）对于h中的每一个元素都要模上$Q&#x3D;2 ^{64}$，可以用$unsigned\ long\ long$这种数据类型来开h数组，通过自然溢出的方式来等价于取模运算。</p>
</li>
<li><p>假设想求字符串的子串从$[L,R]$这个子串的哈希值，已知$h[R]$和$h[L-1]$，让$h[L-1]×p^{(k-L+1)}$就可以使h[L]和h[R]对齐，所以转换公式是$h[R]-h[l] × p^{(k-L+1)}$，预处理前缀哈希值就应该是：$h[i]&#x3D;h[i-1]×p+str[i]$。</p>
</li>
<li><p>字符串哈希有一个KMP算法都无法做到的操作：给一个字符串，给两个区间，问这两个子串是否是相同的，并且只用 $O(1)$ 的时间就能解决</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231124151032942.png" alt="image-20231124151032942" style="zoom:80%;">
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/2024/11/07/%E5%8C%BA%E9%97%B4DP/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="区间dp">区间DP</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6">1. 石子合并</a></li>
<li><a href="#2-%E7%8E%AF%E5%BD%A2%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6">2. 环形石子合并</a></li>
<li><a href="#3-%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE">3. 能量项链</a></li>
<li><a href="#4-%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%BD%A2%E5%88%92%E5%88%86">4. 凸多边形的最优三角形划分</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-石子合并">1. 石子合并</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1775">P1775 石子合并（弱化版） - 洛谷 </a>，推荐学习视频：<a href="https://www.bilibili.com/video/BV1gz4y1y7Rv/?spm_id_from=333.999.0.0">E28【模板】区间DP 石子合并_bilibili</a></p>
</blockquote>
<ul>
<li>如果石子可以不相邻，那么很显然是一个哈夫曼树，直接贪心即可，但是石子必须相邻取，情况太多了我们无法预知哪种取法是最优的</li>
<li>区间 $dp$ 的思想也很简单，第一层枚举区间长度，第二层枚举区间起点，区间起点和区间长度共同决定了区间终点，第三层枚举的是分割点，分割点的取值是 $[区间起点，区间终点]$，以空间换时间动态求得最小值，如果要求最大值只需要把 $min$ 改为 $max$ 即可，注意如果要求最小值则初始化 $f$ 数组为极大值，再对边界赋初始值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 如果可以不相邻,那么贪心就是哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[l,r]:把l到r合并成一堆的最小代价</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i]; <span class="comment">// 便于求解合并的区间和</span></span><br><span class="line">		f[i][i]=<span class="number">0</span>; <span class="comment">// 合并自身初值为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 区间DP</span></span><br><span class="line">	<span class="comment">// 1) 枚举区间长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举区间起点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++) &#123;</span><br><span class="line">			<span class="type">int</span> r=l+len<span class="number">-1</span>; <span class="comment">// 区间终点</span></span><br><span class="line">			<span class="comment">// 3) 枚举分割点</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++) &#123;</span><br><span class="line">				f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-环形石子合并">2. 环形石子合并</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷 </a>，推荐学习视频：<a href="https://www.bilibili.com/video/BV1oK4y1j7W3/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E29 区间DP 环形石子合并_bilibili</a></p>
</blockquote>
<ul>
<li><p>和上一题比起来只改变了一个条件，那就是石子是环形摆放的，比如 ${4,\ 5,\ 9,\ 4}$ 队列首尾两个 $4$ 是相邻的，上一题是链式石子合并</p>
</li>
<li><p>基础思路：我们可以在环形石子中定义一个缺口，如按照下图的模式划分，则会将环形石子变成一个链式石子，就可以用上一个模板，我们额外添加一层循环来枚举这个缺口，当有 $n$ 个石子的时候可以枚举的缺口数是 $n$ 个，再从每种方案中枚举求到最大值，这样能做，但是时间复杂度上升为 $O(n^4)$，显然会 $TLE$</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426095023268.png" alt="image-20240426095023268"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 枚举缺口</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 2) 枚举区间长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line">		<span class="comment">// 3) 枚举区间起点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++) &#123;</span><br><span class="line">			<span class="type">int</span> r=l+len<span class="number">-1</span>; <span class="comment">// 区间终点</span></span><br><span class="line">			<span class="comment">// 4) 枚举分割点</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++) &#123;</span><br><span class="line">				f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以不妨换一个做法，如果我们把数组复制一份使长度变为 $2n$，就可以在不改变时间复杂度的情况下模拟得到相同的效果，将 ${4,\ 5,\ 9,\ 4}$ 复制为 ${4,\ 5,\ 9,\ 4,\ 4,\ 5,\ 9,\ 4}$，区间长度依然从 $2$ 枚举到 $4$，区间左端点从 $1$ 到 $4$，即可得到长链 ${4,\ 5,\ 9,\ 4}$、${5,\ 9,\ 4,\ 4}$、${9,\ 4,\ 4,\ 5}$、${4,\ 4,\ 5,\ 9}$，限制右端点 $l+len-1&lt;&#x3D;2n$，即可在上一个模板中仅改变区间左端点的枚举范围解出环形石子 $DP$ 问题的答案</li>
<li>注意最大值需要从 $f[1][n],\ f[2][n+1],\ …\ ,f[n][2×n-1]$ 中枚举打擂得到，因为有这么多条链</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"><span class="comment">// 环形→链型</span></span><br><span class="line"><span class="comment">// 对于环形,我们从任意一个石子后对其切割得到链型,此时就能用链式区间DP,不过枚举缺口需要O(n),总时间复杂度是O(n^4)</span></span><br><span class="line"><span class="comment">// 所以将链型再复制一份,比如 1 4 2 5 3 变成 1 4 2 5 3 1 4 2 5 3, </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2</span>*(<span class="number">2e2</span>+<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 每堆石子数量</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// 环形石子DP最小值</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 环形石子DP最大值</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="comment">// 复制一边区间</span></span><br><span class="line">		a[i+n]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f); <span class="comment">// 找最大</span></span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> g); <span class="comment">// 找最小</span></span><br><span class="line">	<span class="comment">// 预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		g[i][i]=<span class="number">0</span>,f[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 状态计算(除了区间左端点,其他都不变)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line">		<span class="comment">// 区间起点枚举范围扩展到2n</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=<span class="number">2</span>*n;l++) &#123;</span><br><span class="line">			<span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++) &#123;</span><br><span class="line">				f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">				g[l][r]=max(g[l][r],g[l][k]+g[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 目标输出</span></span><br><span class="line">	<span class="type">int</span> minv=INT_MAX,maxv=INT_MIN;</span><br><span class="line">	<span class="comment">// 必须枚举每一种状态,直接输出f[1][n]的不是最大值因为不连续</span></span><br><span class="line">	<span class="comment">// 计算的时候是 f[1][n],f[2][n+1],...,f[n][2*n-1]这样来算的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		minv=min(minv,f[i][i+n<span class="number">-1</span>]); <span class="comment">// f[1,n],f[2,n+1],...,f[n,2*n-1]</span></span><br><span class="line">		maxv=max(maxv,g[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;minv&lt;&lt;<span class="built_in">endl</span>&lt;&lt;maxv&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-能量项链">3. 能量项链</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006 提高组] 能量项链 - 洛谷 </a>，推荐学习视频：<a href="https://www.bilibili.com/video/BV19t4y1a7xF/?spm_id_from=333.999.0.0">E30 区间DP 能量项链_bilibili</a></p>
</blockquote>
<ul>
<li>题目非常长，从样例入手，$4$ 颗珠子中，前一颗珠子的尾标记是下一颗石子的头标记，现在给出 $4$ 颗珠子的头标记为 ${2,\ 3,\ 5,\ 10}$，实则告诉我们 $4$ 颗珠子为 $(2,3),(3,5),(5,10),(10,2)$，要合并两颗珠子的代价类似于线代中的矩阵乘法，如合并 $1,2$ 两颗珠子释放的能量就是 $2×3×5&#x3D;30$，现在题目要让我们找一种释放能量最大的方法，那么就和环形石子 $DP$ 是相当类似的</li>
<li>不过要用环形石子 $DP$ 模板之前我们还要讨论一下区间长度、区间左端点、分割点是否还相同？</li>
<li>$n$ 颗珠子只需要合并 $n-1$ 次就能得到最终的一颗珠子，比如 $2×3×5$ 合并 $1,2$ 颗珠子后得到珠子 $(2,5),(5,10),(10,2)$ 此时释放的能量是 $30$，继续合并得到 $(2,10),(10,2)$ 此时释放的总能量是 $2×5×10+30&#x3D;130$，继续合并得到 $(2,2)$ 此时释放总能量是 $2×10×2+130&#x3D;170$，我们会发现 $2$ 这个数字在运算中用到了两次，所以我们区间 $DP$ 的数字是  ${2,\ 3,\ 5,\ 10,\ 2}$，即区间长度是 $n+1$</li>
<li>我们仍然对数组进行一次复制，左端点区间枚举范围是 $for(int\ l&#x3D;1;l+len-1&lt;&#x3D;2×n;l++)$，$dp$ 数组 $f[l][r]$ 的状态转移方程是 $f[l][k]+f[k][r]+a[i]×a[k]×a[r]$，即先将 $[l,k]$ 的珠子合并，再把 $[k,r]$ 的珠子合并，最后将 $[l,r]$ 合并，为什么不是 $f[k+1][r]$ 呢？因为计算乘法的时候 $k$ 这个数字会被用到两次</li>
<li>同样的最后枚举得到最终结果，可以说这道题就是环形石子 $DP$ 的变形</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 聚会后释放的能量数有点像矩阵乘法,类似环形石子DP</span></span><br><span class="line"><span class="comment">// 若有 2 3 5 10,则有四颗珠子为(2,3),(3,5),(5,10),(10,2)</span></span><br><span class="line"><span class="comment">// 相邻两颗珠子合并后释放能量 2*3*5,并合并为(2,5),同样的复制为 2 3 5 10 2 3 5 10</span></span><br><span class="line"><span class="comment">// 模拟一下可知需要合并n+1次,所以len最大为n+1,右端点最多枚举到2*n,l&lt;k&lt;r</span></span><br><span class="line"><span class="comment">// k=2,表明珠子1~珠子2先合并,珠子3~珠子n先合并,最后合并这两个大珠子,用分治的思想来理解</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2</span>*(<span class="number">2e2</span>+<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// a[i]:第i颗珠子的头标记,第i-1颗珠子的尾标记(i&gt;=2)</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[l,r]:合并[l,r]得到的能量最大值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i+n]=a[i]; <span class="comment">// 环形石子DP复制一份</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 状态计算,注意len为n+1,模拟一遍就知道了</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">3</span>;len&lt;=n+<span class="number">1</span>;len++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=<span class="number">2</span>*n;l++) &#123;</span><br><span class="line">			<span class="type">int</span> r=l+len<span class="number">-1</span>;</span><br><span class="line">			<span class="comment">// 中间的数字会被用到两次,所以这里是f[l][k]和f[k][r]</span></span><br><span class="line">			<span class="comment">// 这道题里和自己合并是非法的</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l+<span class="number">1</span>;k&lt;r;k++) &#123;</span><br><span class="line">				f[l][r]=max(f[l][r],f[l][k]+f[k][r]+a[l]*a[k]*a[r]); <span class="comment">// 合并代价i,j,k</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 枚举找最大值</span></span><br><span class="line">	<span class="type">int</span> res=INT_MIN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=max(res,f[i][i+n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2 3 5 10</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">710</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2><span id="4-凸多边形的最优三角形划分">4. 凸多边形的最优三角形划分</span></h2><ul>
<li>用两个不相邻的顶点之间组成的弦可以把一个凸多边形划分成两个多边形</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426142014884.png" alt="image-20240426142014884"></p>
<ul>
<li>用多条弦就可以把一个凸多边形划分为互不相交的三角形，那么把多边形分割为互不相交的三角形的弦的集合，就叫做凸多边形的三角剖分</li>
<li>每一组弦的集合会把凸多边形切割成不同的三角形，这些三角形的周长之和就是我们的代价，那么能使这个代价最小的一组弦的集合，就是凸多边形的最优三角形划分</li>
<li>我们可以推导一下代价的计算公式，对于下面的两幅图，很容易看出，各个三角形的周长之和，其实就是每条 $蓝色的弦的长度 \ ×2 \ + 凸多边形的周长$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426142114525.png" alt="image-20240426142114525"></p>
<ul>
<li>初始化：因为最少三个点才能组成三角形，$len&#x3D;3$ 时就是最底层最初始的状态，$f[1][3],k&#x3D;2$ 实则就为顶点 $v1,v2,v3$ 构成的三角形的周长，当然这一步不用特地初始化，可以在区间 $DP$ 时直接计算作为底层状态了，真正的初始化是把 $len&#x3D;1\ || \ len&#x3D;2$ 时的各个状态下的 $f$ 定义为 $0$，因为此时根本无法构成三角形，所以第一层枚举区间长度的时候直接从 $len&#x3D;3$ 开始</li>
<li>这个问题其实和分治法很类似，可以从最外层 $f[1][6]$ 来看，找到合适的分割点 $k&#x3D;4$ 可以切割为 $f[1][4]$ 和 $[5][6]$，后者无法构成三角形在最初初始化的时候已然为 $0$，对于前者 $f[1][4]$ 在之前 $len&#x3D;4$ 的时候已然被计算过了，他也有最佳切割点 $k&#x3D;3$，那么又可以切割为 $f[1][3]$ 和 $f[3][4]$ 以此类推，<strong>所以我们可以把区间 $DP$ 理解为分治法 $+$ 递推</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路:</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="comment">// 状态表示</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:从顶点vi~vj构成的多边形的最优三角剖分的最小值</span></span><br><span class="line"><span class="type">int</span> s[N][N]; <span class="comment">// s[i][j]:满足f[i][j]最小的分割点k的值,即方案</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// g[i][j]:邻接矩阵,记录vi到vj的距离</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 vx,vy,vz 三个点构成的三角形的边长</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_val</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> g[x][y]+g[x][z]+g[y][z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v; <span class="comment">// 保存点集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯求解出划分点集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> &#123;</span><br><span class="line">	<span class="type">int</span> k=s[l][r]; <span class="comment">// 这一步的切割点</span></span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 若k=0了说明走到边界了</span></span><br><span class="line">	<span class="comment">// k&gt;l+1为了只输出弦</span></span><br><span class="line">	<span class="keyword">if</span>(k&gt;l+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// k+1&lt;r是为了只输出弦</span></span><br><span class="line">	<span class="keyword">if</span>(k+<span class="number">1</span>&lt;r) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(l,k);</span><br><span class="line">	backtrack(k+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="comment">// 输入邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		f[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//		f[i-1][i]=0;</span></span><br><span class="line">		s[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 两个点的情况</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		f[i][i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">1</span>][n]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 区间dp</span></span><br><span class="line">	<span class="comment">// 1) 第一层枚举区间长度</span></span><br><span class="line"><span class="comment">//	int ans=INT_MAX; // 记录最终结果,最小的边权和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">3</span>;len&lt;=n;len++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举左端点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++) &#123;</span><br><span class="line">			<span class="type">int</span> r=l+len<span class="number">-1</span>; <span class="comment">// 区间长度和左端点决定右端点</span></span><br><span class="line">			<span class="comment">// 3) 枚举分割点</span></span><br><span class="line">			f[l][r]=INT_MAX; <span class="comment">// 这里设置为最大值,一旦找到更小值就可以对其进行替换</span></span><br><span class="line">			s[l][r]=l+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=l+<span class="number">1</span>;k&lt;r;k++) &#123;</span><br><span class="line">				<span class="comment">// 区间dp第三步,</span></span><br><span class="line">				<span class="type">int</span> tmp=f[l][k]+f[k][r]+get_val(l,k,r);</span><br><span class="line">				<span class="keyword">if</span>(tmp&lt;f[l][r]) &#123;</span><br><span class="line">					f[l][r]=tmp; <span class="comment">// 更新为最小值</span></span><br><span class="line">					s[l][r]=k; <span class="comment">// 记录方案</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 从1~n中选出 v1,vn,以及一个点vk,此时最小的权值和</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最后选出点的集合是 v1, v4, v6, v3</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;g[<span class="number">1</span>][<span class="number">4</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;g[<span class="number">4</span>][<span class="number">6</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;g[<span class="number">1</span>][<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(g[<span class="number">1</span>][<span class="number">4</span>]+g[<span class="number">4</span>][<span class="number">6</span>]+g[<span class="number">1</span>][<span class="number">3</span>])*<span class="number">2</span>+g[<span class="number">1</span>][<span class="number">2</span>]+g[<span class="number">1</span>][<span class="number">6</span>]+g[<span class="number">2</span>][<span class="number">3</span>]+g[<span class="number">3</span>][<span class="number">4</span>]+g[<span class="number">4</span>][<span class="number">5</span>]+g[<span class="number">5</span>][<span class="number">6</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][<span class="number">4</span>]+f[<span class="number">4</span>][<span class="number">6</span>]+get_val(<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出f数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;f[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 输出s策略数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	backtrack(<span class="number">1</span>,n); <span class="comment">// 找切割点集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:v) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">0 2 3 1 5 6</span></span><br><span class="line"><span class="comment">2 0 3 4 8 6</span></span><br><span class="line"><span class="comment">3 3 0 10 13 7</span></span><br><span class="line"><span class="comment">1 4 10 0 12 5</span></span><br><span class="line"><span class="comment">5 8 13 12 0 3</span></span><br><span class="line"><span class="comment">6 6 7 5 3 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>动态规划</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2024/10/03/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="差分">差分</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86">1. 一维差分</a></li>
<li><a href="#2-%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86">2. 二维差分</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>复习一下前缀和吧：<a href="https://blog.csdn.net/qq_63586399/article/details/136780044?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22136780044%22,%22source%22:%22qq_63586399%22%7D">【C++算法模板】预处理算法：一维前缀和、二维前缀和总结，详解带例题-CSDN博客</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>差分的推导也比较简单，因此本博客重点在于知识点归纳而不在于证明</li>
</ul>
<h2><span id="1-一维差分">1. 一维差分</span></h2><ul>
<li>给定一个一维序列，定义它的差分序列 $b$ 为，计算差分序列的时间复杂度为 $O(n)$<ul>
<li>$b[1]&#x3D;a[1]\ (i&#x3D;1)$</li>
<li>$b[i]&#x3D;a[i]-a[i-1]\ (2&lt;&#x3D;i&lt;&#x3D;n)$</li>
</ul>
</li>
<li>为原序列 $[l,r]$ 区间分别加上 $c$ 等价于：$b[l]+&#x3D;c,\ b[r+1]-&#x3D;c$，对差分序列 $b$ 做一维前缀和得到操作后的原序列，时间复杂度 $O(1)$</li>
</ul>
<blockquote>
<p>【例题】AcWing 797，链接：<a href="https://www.acwing.com/problem/content/799/">797. 差分 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N]; <span class="comment">// a:原序列,b:差分序列</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 对b求前缀和</span></span><br><span class="line"><span class="type">int</span> l,r,c;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入规模超过1e5,推荐使用scanf</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		b[i]=a[i]-a[i<span class="number">-1</span>]; <span class="comment">// 前缀和和差分下标都从1开始,否则容易有边界问题</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">		b[l]+=c;</span><br><span class="line">		b[r+<span class="number">1</span>]-=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用新数组s计算差分序列b的前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+b[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用累加的思想,在差分序列本身上做前缀和,节省空间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-二维差分">2. 二维差分</span></h2><ul>
<li>在一维差分中我们对差分序列 $b$ 求前缀和可以得到原序列 $a$，由此可以看出差分是前缀和的逆运算</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031227790.png" alt="image-20240317085114587"></p>
<ul>
<li>则我们可由二维前缀和计算公式轻松推导出二维差分序列的计算公式，时间复杂度 $O(n^2)$<ul>
<li>二维前缀和的计算公式 $s[i][j]&#x3D;\sum_{i&#x3D;1}^i\sum_{j&#x3D;1}^ja[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$</li>
<li>将 $a[i]$ 单独移至等号一边，对 $s$ 合并同类项，得到 $a[i][j]&#x3D;s[i][j]-s[i-1][j]-s[i][j-1]+s[i-1][j-1]$</li>
<li>由于 $b$ 的前缀和是 $a$，所以将 $a$ 替换成 $b$，将 $s$ 替换成 $a$，得到二位差分计算公式</li>
<li>$b[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$，其物理含义是：在下标 $[i][j]$ 位置上的差分等于原序列 $[i][j]$ 上的元素减去上边 $[i-1][j]$ 和左边 $[i][j-1]$ 上的元素并加上左上角 $[i-1][j-1]$ 的元素</li>
</ul>
</li>
<li>对原序列 $a$ 区间 $(x_1,y_1)$ 到 $(x_2,y_2)$ 之间的元素加上 $c$，等价于其差分序列 $b$ 的点 $(x_1,y_1)$ 加 $c$，点 $(x_1,y_{2}+1)$ 减 $c$，点 $(x_2+1,y1)$ 减 $c$，点 $(x_2+1,y_2+1)$ 加 $c$，时间复杂度 $O(1)$，最后对差分序列 $b$ 求二维前缀和即可得到操作过后的原序列</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031227796.png"></p>
<blockquote>
<p>【例题】AcWing 798，链接：<a href="https://www.acwing.com/problem/content/800/">798. 差分矩阵 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 逐行差分和逐行求和的思路</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,k; <span class="comment">// n:矩阵行数,m:矩阵列数,k:操作次数</span></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> b[N][N]; <span class="comment">// 差分矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N][N]; <span class="comment">// 对b求二维前缀和得到操作后的原序列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">			b[i][j]=a[i][j]-a[i<span class="number">-1</span>][j]-a[i][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">// 差分是前缀和的逆运算</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出差分数组看一看</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;输出差分数组:&gt;\n&quot;;</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++,puts(&quot;&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=m;j++) &#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;b[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">	<span class="keyword">while</span>(k--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">		b[x1][y1]+=c;</span><br><span class="line">		b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">		b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">		b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 求前缀和保存到s里面</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i][j];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 直接在b本身上进行前缀和得到操作后的a</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;b[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>预处理</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/10/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="并查集">并查集</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li>
<li><a href="#2-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">2. 核心函数</a><ul>
<li><a href="#21-find%E5%87%BD%E6%95%B0">2.1. find函数</a></li>
<li><a href="#22-join%E5%87%BD%E6%95%B0">2.2. join函数</a></li>
</ul>
</li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF">3. 模板</a></li>
<li><a href="#4-%E7%BB%B4%E6%8A%A4%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86">4. 维护信息的并查集</a><ul>
<li><a href="#41-%E7%BB%B4%E6%8A%A4%E5%90%84%E9%9B%86%E5%90%88%E4%B8%AD%E5%85%83%E7%B4%A0%E6%80%BB%E6%95%B0">4.1. 维护各集合中元素总数</a></li>
<li><a href="#42-%E7%BB%B4%E6%8A%A4%E6%80%BB%E9%9B%86%E5%90%88%E4%B8%AA%E6%95%B0">4.2. 维护总集合个数</a></li>
</ul>
</li>
<li><a href="#5-%E5%AE%8C%E5%A4%87%E5%B9%B6%E6%9F%A5%E9%9B%86">5. 完备并查集</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>并查集是用于处理不相交集合的合并与查询的树形数据结构</li>
</ul>
<h2><span id="1-数据结构">1. 数据结构</span></h2><ul>
<li>准备一个数组用于存储所有点的连通分量（父节点）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br></pre></td></tr></table></figure>



<h2><span id="2-核心函数">2. 核心函数</span></h2><h3><span id="21-find函数">2.1. find函数</span></h3><ul>
<li>用于查询某个元素的父节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所在集合的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点</span></span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">//	return find(fa[x]); // 递归查找父节点的父节点</span></span><br><span class="line">	<span class="comment">// 带路径压缩的查找(有效降低递归的时间复杂度)</span></span><br><span class="line">	<span class="comment">// 在返回的路上,顺带修改各节点的父节点为根</span></span><br><span class="line">	<span class="comment">// 这句代码的意思是:fa[x]=find(fa[x]),return fa[x]</span></span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031254549.png" alt="image-20240410144829099"></p>
<ul>
<li>带路径压缩的查找和普通查找的区别仅仅在于在递归的过程中把每个子节点的父节点更新为根</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031253600.png" alt="image-20240410144851687"></p>
<h3><span id="22-join函数">2.2. join函数</span></h3><ul>
<li>用于连接两个并查集</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// b的根作为a的根</span></span><br><span class="line">    fa[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">// b的父节点作为a原本的父节点的父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-模板">3. 模板</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷</a></p>
</blockquote>
<ul>
<li>1）初始化时将每个节点的父节点初始化为自己</li>
<li>2）如果 $a$ 和 $b$ 的根相同，则表明二者处于同一并查集中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+4</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn]; <span class="comment">// 记录每个节点的父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) </span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// 路径压缩</span></span><br><span class="line">		<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">find</span>(l)]=<span class="built_in">find</span>(r); <span class="comment">// x的父节点的父节点变为y的父节点(合并)</span></span><br><span class="line">    <span class="comment">// 即把l的集合的根节点的父亲设置为r集合的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> op,l,r; <span class="comment">// op是操作,l和r是合并或判断关系的两个并查集</span></span><br><span class="line">	<span class="comment">// 1. 初始化每个结点的父节点都是自己</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">join</span>(l,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(l)==<span class="built_in">find</span>(r)) <span class="comment">// 在同一并查集中</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Y\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;N\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-维护信息的并查集">4. 维护信息的并查集</span></h2><h3><span id="41-维护各集合中元素总数">4.1. 维护各集合中元素总数</span></h3><ul>
<li>只需要在合并时进行计算即可，将子集合中的元素个数加等到父集合的元素个数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[i]:以i为根节点的集合的元素个数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护集合总数的合并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> x=find(a);</span><br><span class="line">	<span class="type">int</span> y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	fa[x]=y; <span class="comment">// a所在集合根节点作为b所在集合根节点的儿子节点</span></span><br><span class="line">	<span class="comment">// 如果遇到重复的语句,那么此时x==y成立,所以不再重复计数</span></span><br><span class="line">	cnt[y]+=cnt[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="42-维护总集合个数">4.2. 维护总集合个数</span></h3><ul>
<li>有多少个集合即是看有多少个节点的 $x&#x3D;&#x3D;fa[x]$ 即有多少个根节点，无需维护，$O(n)$ 遍历一遍即可</li>
</ul>
<h2><span id="5-完备并查集">5. 完备并查集</span></h2><ul>
<li>非常好用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完备并查集</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">	<span class="comment">// fa:每个结点的父结点</span></span><br><span class="line">	<span class="comment">// p:每个集合的结点数量</span></span><br><span class="line">	<span class="comment">// e:每个集合边的数量</span></span><br><span class="line">	<span class="comment">// f:记录集合中是否存在自环</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; fa,p,e,f; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化一个并查集</span></span><br><span class="line">	DSU(<span class="type">int</span> n) &#123;</span><br><span class="line">		<span class="comment">// 大小为n+1,下标从0~n,我们可以从1开始使用</span></span><br><span class="line">		</span><br><span class="line">		fa.resize(n+<span class="number">1</span>); <span class="comment">// 大小调整为n+1 </span></span><br><span class="line">		<span class="comment">// fa从起始位置到结束位置,从0开始递增赋值,即父结点为自己</span></span><br><span class="line">		<span class="comment">// 即fa[0]=0,fa[1]=1,...,fa[n]=n</span></span><br><span class="line">		iota(fa.begin(),fa.end(),<span class="number">0</span>); </span><br><span class="line">		p.resize(n+<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// 每个结点单独成为一个集合,大小为1</span></span><br><span class="line">		e.resize(n+<span class="number">1</span>); <span class="comment">// 初始时每个集合没有边</span></span><br><span class="line">		f.resize(n+<span class="number">1</span>); <span class="comment">// 初始时没有自环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找x所在集合的根节点</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="comment">// 找x的根节点,并作路径压缩</span></span><br><span class="line">		<span class="keyword">while</span>(x!=fa[x]) &#123;</span><br><span class="line">			x=fa[x]=fa[fa[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 假设x所在集合为A,假设y所在集合为B,合并A和B</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="comment">// 设x是y的祖先</span></span><br><span class="line">		<span class="keyword">if</span>(x==y) f[get(x)]=<span class="number">1</span>; <span class="comment">// 如果自己和自己合并,则存在自环</span></span><br><span class="line">		x=get(x),y=get(y);</span><br><span class="line">		e[x]++; <span class="comment">// 集合A边数+1</span></span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;y) swap(x,y); <span class="comment">// 指定将编号小的合并到编号大的上</span></span><br><span class="line">		fa[y]=x; <span class="comment">// 集合B父结点变为x</span></span><br><span class="line">		<span class="comment">// 若B有自环,则合并后A有自环,或运算是一起看,有1则1</span></span><br><span class="line">		<span class="comment">// A加上B中边的数量和结点数量</span></span><br><span class="line">		f[x]|=f[y],p[x]+=p[y],e[x]+=e[y];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断x和y是否在同一集合中</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> get(x)==get(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断x所在集合是否存在自环</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f[get(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出集合中点的数量</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">size</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p[get(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出集合中边的数量</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">E</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e[get(x)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 用完备并查集解板子题</span></span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	DSU <span class="title function_">dsu</span><span class="params">(n)</span>; <span class="comment">// 创建并查集</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> op,a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			dsu.merge(a,b); <span class="comment">// 合并a,b所在集合</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(dsu.same(a,b)) &#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;N&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索</title>
    <url>/2024/10/04/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="广度优先搜索">广度优先搜索</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E8%A1%A8">1. 基于邻接表</a></li>
<li><a href="#2-%E5%9F%BA%E4%BA%8E%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F">2. 基于链式前向星</a></li>
<li><a href="#3-%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9B%BE">3. 基于二维数组（地图）</a><ul>
<li><a href="#31-%E5%8D%95%E6%BA%90bfs">3.1. 单源BFS</a><ul>
<li><a href="#311-%E8%B1%A1%E6%A3%8B%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86">3.1.1. 象棋马的遍历</a></li>
<li><a href="#312-%E8%BF%B7%E5%AE%AB%E6%9C%80%E7%9F%AD%E8%B7%AF">3.1.2. 迷宫最短路</a></li>
<li><a href="#313-%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B">3.1.3. 抓住那头牛</a></li>
</ul>
</li>
<li><a href="#32-%E5%A4%9A%E6%BA%90bfs">3.2. 多源BFS</a><ul>
<li><a href="#321-%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5">3.2.1. 距离矩阵</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>广搜是基于队列实现的从根开始向下逐层扩展逐层访问的搜索遍历方法</li>
</ul>
<h2><span id="1-基于邻接表">1. 基于邻接表</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240510202644636.png" alt="image-20240510202644636"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// e[1]:结点1的相邻结点</span></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">// vis[1]:结点1的访问状态,true:访问过了,false:未访问</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">// 假设结点1是根节点</span></span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d 出队\n&quot;</span>,x);</span><br><span class="line">		<span class="comment">// 扩展其儿子结点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y:e[x]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>; <span class="comment">// 避免反复入队</span></span><br><span class="line">			vis[y]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d 入队\n&quot;</span>,y);</span><br><span class="line">			q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 每个结点扩展的边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">// n个结点,.条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b; <span class="comment">// 父在前</span></span><br><span class="line">		<span class="comment">// 无向图双向建边</span></span><br><span class="line">		e[a].push_back(b);</span><br><span class="line">		e[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-基于链式前向星">2. 基于链式前向星</span></h2><ul>
<li>注意，因为链式前向星是头插，所以入队和出队顺序和基于邻接表（尾插）不太一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大结点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span>+<span class="number">5</span>)*<span class="number">2</span>; <span class="comment">// 最大边数(无向图)</span></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:结点i的起始边编号</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:第i条边到达的结点</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:第i条边的下一条边的编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建边因子</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">// 每个结点的访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a];</span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 每个结点扩展的边数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 维护序列的队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d 出队\n&quot;</span>,x);</span><br><span class="line">		<span class="comment">// 遍历连接x的所有边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i]; <span class="comment">// 取出第i条边所达结点</span></span><br><span class="line">			<span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[j]=<span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d 入队\n&quot;</span>,j);</span><br><span class="line">			q.push(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">// n个结点,.条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b; <span class="comment">// 父在前</span></span><br><span class="line">		<span class="comment">// 无向图双向建边</span></span><br><span class="line">		add(a,b);</span><br><span class="line">		add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意,因为是头插,所以入队和出队顺序和基于邻接表不太一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2><span id="3-基于二维数组地图">3. 基于二维数组（地图）</span></h2><h3><span id="31-单源bfs">3.1. 单源BFS</span></h3><h4><span id="311-象棋马的遍历">3.1.1. 象棋马的遍历</span></h4><blockquote>
<p>题目描述：在象棋棋盘中，马从 $(0,0)$ 跳到 $(fx,fy)$【自行输入】，已知马只能向右跳，求到达终点所需最少步长并输出其路径</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 只能向右走,说明在列方向上的变化只能是正值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 初始化为-1,也把dist当作st数组用</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 存储最短路径</span></span><br><span class="line"><span class="type">int</span> fx,fy; <span class="comment">// 终点是(fx,fy),行是m,列是n</span></span><br><span class="line"><span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">// 放的是坐标</span></span><br><span class="line"></span><br><span class="line">PII pre[N][N]; <span class="comment">// 记录路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只调用一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	dist[x][y]=<span class="number">0</span>;</span><br><span class="line">	q.push(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="comment">// 取出队头</span></span><br><span class="line">		PII t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="comment">// 一定不会往回走</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> xx=t.x+dx[i];</span><br><span class="line">			<span class="type">int</span> yy=t.y+dy[i];</span><br><span class="line">			<span class="comment">// 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(xx&lt;<span class="number">0</span> || yy&lt;<span class="number">0</span> || xx&gt;fx || yy&gt;fy) <span class="keyword">continue</span>;</span><br><span class="line">			q.push(<span class="built_in">make_pair</span>(xx,yy));</span><br><span class="line">			dist[xx][yy]=dist[t.x][t.y]+<span class="number">1</span>;</span><br><span class="line">			pre[xx][yy]=<span class="built_in">make_pair</span>(t.x,t.y); <span class="comment">// [xx,yy]的前驱是[t.x,t.y]</span></span><br><span class="line">			<span class="comment">// 找到终点了</span></span><br><span class="line">			<span class="keyword">if</span>(xx==fx &amp;&amp; yy==fy) &#123;</span><br><span class="line">				<span class="keyword">return</span> dist[xx][yy];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 找不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;fx&gt;&gt;fy;</span><br><span class="line">	<span class="type">int</span> sx=<span class="number">0</span>,sy=<span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs(sx,sy);</span><br><span class="line">	<span class="type">int</span> x=fx,y=fy; <span class="comment">// 回溯路径</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;PII&gt; v; <span class="comment">// 记录正向路径</span></span><br><span class="line">	<span class="keyword">while</span>(x!=sx || y!=sy) &#123; </span><br><span class="line">		v.push_back(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">		PII prev=pre[x][y];</span><br><span class="line">		x=prev.x;</span><br><span class="line">		y=prev.y;</span><br><span class="line">	&#125;</span><br><span class="line">	v.push_back(<span class="built_in">make_pair</span>(sx, sy)); <span class="comment">// 添加起点到路径中 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=v.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123; <span class="comment">// 输出路径要倒序输出</span></span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="312-迷宫最短路">3.1.2. 迷宫最短路</span></h4><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1NU4y1R7fd/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B12 BFS 迷宫 最短路_bilibili</a><br>题目描述：$n$ 行 $n$ 列的二维地图中，$1$ 表示墙壁，$0$ 表示可走的路，只能朝上下左右四个方向走，求最短路径长度并输出这条路径</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 偏移量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 地图,01存储,兼状态数组</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// dist[i][j]:(i,j)到起点(1,1)的距离</span></span><br><span class="line"><span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">// 维护序列的队列</span></span><br><span class="line">PII pre[N][N]; <span class="comment">// pre[i][j]:(i,j)的上一步的坐标(记录最短路)</span></span><br><span class="line"><span class="type">int</span> fx,fy; <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	dist[x][y]=<span class="number">0</span>;</span><br><span class="line">	q.push(&#123;x,y&#125;); <span class="comment">// 左上角初始加入队列</span></span><br><span class="line">	g[x][y]=<span class="number">1</span>; <span class="comment">// 渲染成墙壁,表示走过了</span></span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		PII t=q.front(); <span class="comment">// 取出队头</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> xx=t.x+dx[i];</span><br><span class="line">			<span class="type">int</span> yy=t.y+dy[i];</span><br><span class="line">			<span class="comment">// 约束条件</span></span><br><span class="line">			<span class="comment">// 1) 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(xx&lt;<span class="number">1</span> || xx&gt;n || yy&lt;<span class="number">1</span> || yy&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 2) 必须为可走&amp;&amp;必须没走过</span></span><br><span class="line">			<span class="keyword">if</span>(g[xx][yy]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 占据方案</span></span><br><span class="line">			g[xx][yy]=<span class="number">1</span>;</span><br><span class="line">			dist[xx][yy]=dist[t.x][t.y]+<span class="number">1</span>; <span class="comment">// 步长+1</span></span><br><span class="line">			pre[xx][yy]=&#123;t.x,t.y&#125;; <span class="comment">// 记录上一步</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;t.x&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;t.y&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;xx&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;yy&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">if</span>(xx==fx &amp;&amp; yy==fy) <span class="keyword">return</span> dist[xx][yy];</span><br><span class="line">			q.push(&#123;xx,yy&#125;);</span><br><span class="line">			<span class="comment">// 如果找到终点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 找不到最短路</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fx=n,fy=n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 从(1,1)广搜</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dist[n][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;PII&gt; path; <span class="comment">// 存储路径</span></span><br><span class="line">	<span class="comment">// 一直回溯到起点</span></span><br><span class="line">	<span class="keyword">while</span>(fx!=<span class="number">1</span> || fy!=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)的上一个位置是(%d,%d)\n&quot;</span>,fx,fy,pre[fx][fy].first,pre[fx][fy].second);</span><br><span class="line">		path.push_back(&#123;fx,fy&#125;);</span><br><span class="line">		PII prev=pre[fx][fy];</span><br><span class="line">		fx=prev.x;</span><br><span class="line">		fy=prev.y;</span><br><span class="line">	&#125;</span><br><span class="line">	path.push_back(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	reverse(path.begin(),path.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=path.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)-&gt;&quot;</span>,path[i].first,path[i].second);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,path[i].first,path[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0 1 0 0 0</span></span><br><span class="line"><span class="comment">0 1 0 1 0</span></span><br><span class="line"><span class="comment">0 0 0 0 0 </span></span><br><span class="line"><span class="comment">0 1 1 1 0</span></span><br><span class="line"><span class="comment">0 0 0 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4><span id="313-抓住那头牛">3.1.3. 抓住那头牛</span></h4><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1KM4y1e7v1/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B15 BFS 抓住那头牛_bilibili</a><br>题目描述：人和牛在同一直线上，初始位置分别为 $x$ 和 $y$，牛不动，人每次可以前进 $1$ 步、后退 $1$ 步或者直接走到 $2×x$ 的位置，计算追上牛的最小步数</p>
</blockquote>
<ul>
<li>对于起点先加入队列，随后每次取出队头分别处理前进一步、后退一步以及 $×2$ 后的步数，因为是逐层扩展，所以第一次遍历到的时候所用到的步数一定是最小的</li>
<li>同时我们约束其上下界，下界为 $0$ ，因为题目要求 $x,y&gt;&#x3D;0$ ，上界为题目给的数据范围 $1e5$，因为 $x×2,\ x-1,\ x-1$ 不如 $x-1,x×2$ 更优，所以可以约束其上界</li>
<li>本题还需要学习的一点在于用 $dist$ 数组进行剪枝，限制第一次来到这一步才对值进行更新，根据 $BFS$ 逐层扩展的原理，这样求出来的本身也是最小值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> x,y,dist[N]; <span class="comment">// dist[i]:走到i所需要的最少步数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">-1</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[x]=<span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">	q.push(x); </span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 下面三种情况的约束条件:都是没走过(因为逐层扩展,所以第一次遇到一定最小)并且不越界</span></span><br><span class="line">		<span class="comment">// 下面的三个if是并列关系,相当于一个结点会扩展3次,前进一步/后退一步和×2</span></span><br><span class="line">		<span class="comment">// 其实dist数组的作用相当于剪枝了,因为每个结点只能被扩展一次</span></span><br><span class="line">		<span class="comment">// 易证明,x*2再-1-1,不如x-1,x*2更优,故有上界x&lt;=10^5</span></span><br><span class="line">		<span class="keyword">if</span>(x+<span class="number">1</span>&lt;N &amp;&amp; dist[x+<span class="number">1</span>]==<span class="number">-1</span>) &#123;</span><br><span class="line">			dist[x+<span class="number">1</span>]=dist[x]+<span class="number">1</span>; <span class="comment">// 前进一步</span></span><br><span class="line">			q.push(x+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 坐标范围本身(x,y)都&gt;0</span></span><br><span class="line">		<span class="keyword">if</span>(x<span class="number">-1</span>&gt;<span class="number">0</span> &amp;&amp; dist[x<span class="number">-1</span>]==<span class="number">-1</span>) &#123;</span><br><span class="line">			dist[x<span class="number">-1</span>]=dist[x]+<span class="number">1</span>; <span class="comment">// 后退一步</span></span><br><span class="line">			q.push(x<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>*x&lt;N &amp;&amp; dist[<span class="number">2</span>*x]==<span class="number">-1</span>) &#123;</span><br><span class="line">			dist[<span class="number">2</span>*x]=dist[x]+<span class="number">1</span>; <span class="comment">// 走到2*x的位置</span></span><br><span class="line">			q.push(<span class="number">2</span>*x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果走到终点</span></span><br><span class="line">		<span class="keyword">if</span>(x==y) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dist[y]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">5 17</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3><span id="32-多源bfs">3.2. 多源BFS</span></h3><h4><span id="321-距离矩阵">3.2.1. 距离矩阵</span></h4><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1GB4y1Q7bR/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B13 多源BFS 矩阵距离_bilibili</a><br>题目描述：即是说求图中每一个 $0$ 距离自己最近的 $1$ 的曼哈顿距离，从而构成一个新的矩阵 $B$</p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240512154726043.png" alt="image-20240512154726043"></p>
<ul>
<li>为了求每个 $0$ 距离自己最近的 $1$ 的曼哈顿距离，如果计算遍历到每个 $0$ 时分别去寻找距离自己最近的 $1$ 并打擂取得最小值，时间复杂度很会高</li>
<li>所以可以从每个 $1$ 做洪水覆盖，即多源 $BFS$，先来到这个点的距离一定是最短的，因为 $BFS$ 是逐层扩展</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 地图</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 存储到源点的距离,兼职判重</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n行m列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">// 多源,把每个1都放入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">-1</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 均初始化为不可达</span></span><br><span class="line">	<span class="comment">// 遍历地图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// 多源BFS,区别就是把多个源点都加入队列</span></span><br><span class="line">			<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				dist[i][j]=<span class="number">0</span>; <span class="comment">// 到自己的距离为0</span></span><br><span class="line">				q.push(&#123;i,j&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> xx=t.x+dx[i];</span><br><span class="line">			<span class="type">int</span> yy=t.y+dy[i];</span><br><span class="line">			<span class="comment">// 1) 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(xx&lt;<span class="number">1</span> || xx&gt;n || yy&lt;<span class="number">1</span> || yy&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 2) 走过则跳过</span></span><br><span class="line">			<span class="keyword">if</span>(dist[xx][yy]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dist[xx][yy]=dist[t.x][t.y]+<span class="number">1</span>; <span class="comment">// 洪泛计算距离</span></span><br><span class="line">			q.push(&#123;xx,yy&#125;);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入地图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++,<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dist[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">0 0 0 1</span></span><br><span class="line"><span class="comment">0 0 1 1</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2024/10/04/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="拓扑排序">拓扑排序</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-kahn%E7%AE%97%E6%B3%95">1. Kahn算法</a><ul>
<li><a href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.1. 数据结构</a></li>
<li><a href="#12-%E5%BB%BA%E5%9B%BE">1.2. 建图</a></li>
<li><a href="#13-kanh%E7%AE%97%E6%B3%95">1.3. Kanh算法</a></li>
</ul>
</li>
<li><a href="#2-dfs%E6%9F%93%E8%89%B2">2. DFS染色</a><ul>
<li><a href="#21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.1. 数据结构</a></li>
<li><a href="#22-%E5%BB%BA%E5%9B%BE">2.2. 建图</a></li>
<li><a href="#23-dfs">2.3. DFS</a></li>
</ul>
</li>
<li><a href="#3-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94">3. 算法对比</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98%E6%B4%9B%E8%B0%B7-b3644">4. 【例题】洛谷 B3644</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>推荐视频链接：<a href="https://www.bilibili.com/video/BV17g41197sa/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">D01 拓扑排序</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>给定一张<strong>有向无环图</strong>，排出所有顶点的一个序列 $A$ 满足：对于图中的每条有向边 $(x,y)$，$x$ 在 $A$ 中都出现在 $y$ 之前，则称 $A$ 是该图的顶点的一个拓扑序</p>
</li>
<li><p>拓扑排序 可以判断有向图中是否有环，可以生成拓扑序列</p>
</li>
<li><p>对于下图，${2,3,5,1,7,4,6}$ 和 ${3,2,1,5,7,6,4}$ 都是合法的拓扑序</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240315173326430.png" alt="image-20240315173326430"></p>
<blockquote>
<p>复习一下链式前向星吧：<a href="https://blog.csdn.net/qq_63586399/article/details/136579751?spm=1001.2014.3001.5502">【C++算法模板】图的存储-邻接表，手撕链式前向星，超详细代码注释-CSDN博客</a></p>
</blockquote>
<h2><span id="1-kahn算法">1. Kahn算法</span></h2><ul>
<li>算法核心：用队列维护一个入度为 $0$ 的节点的集合</li>
</ul>
<ol>
<li>初始化（链式前向星建图建边），队列 $q$ 压入所有入度为 $0$ 的点</li>
<li>每次从 $q$ 中取出队头 $x$ 放入数组 $tp$ ，$tp$ 数组保存出队顺序，也就是拓扑序</li>
<li>然后将 $x$ 的所有出边删除，如删除边 $(x,y)$ ，$y$ 的入度则 $-1$，如果 $y$ 的入度变为 $0$，则将 $y$ 压入 $q$ 中，其中每个顶点的入度用数组 $d$ 维护</li>
<li>不断重复 $2,3$ 过程，直到队列 $q$ 为空</li>
<li>若 $tp$ 中的元素个数等于 $n$，则有拓扑序；否则，有环</li>
</ol>
<h3><span id="11-数据结构">1.1. 数据结构</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>; <span class="comment">// 题目中最大边数,拓扑排序是有向图建边,无需×2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的入度</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 维护入度为0的顶点的队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 记录q中顶点的出队顺序(拓扑序)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 存储每个顶点起始边的编号,默认-1表示无边相连</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:编号为i的边可达的顶点编号</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:编号为i的边的下一条边的编号是ne[i]</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号,建边因子</span></span><br></pre></td></tr></table></figure>



<h3><span id="12-建图">1.2. 建图</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 头插法思想</span></span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="13-kanh算法">1.3. Kanh算法</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑序存储于tp队列中,如果能形成拓扑序返回true</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">tuopu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果入度为0则加入队列</span></span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		tp.push(x); <span class="comment">// 出队顺序即拓扑序</span></span><br><span class="line">		<span class="comment">// 遍历x的所有出边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果去掉边(i,j)后j的入度变为0,则加入队列</span></span><br><span class="line">			<span class="keyword">if</span>(--d[j]==<span class="number">0</span>) q.push(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tp.size()==n; <span class="comment">// 如果能形成一个拓扑序,返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-dfs染色">2. DFS染色</span></h2><ul>
<li>算法核心：在于<strong>染色法</strong>，每次 $dfs$ 搜索会给点变色，如果有拓扑序，每个点的颜色都会从 $0→-1→1$ 经历三次变色</li>
</ul>
<ol>
<li>初始化：将所有点染色为 $0$</li>
<li>枚举每个点，进入点 $x$，将 $x$ 染色为 $-1$，随后枚举 $x$ 的所有儿子结点 $y$，如果 $y$ 的颜色仍为 $0$，说明该点未被遍历过，则递归到下一层；如果 $y$ 的颜色为 $-1$，说明遍历到祖先节点了，即出现了环，则直接 $return$</li>
<li>如果枚举完 $x$ 的所有儿子节点都没有发现环，则把 $x$ 染色为 $1$，并把 $x$ 压入 $tp$ 数组</li>
<li>注意，因为 $DFS$ 是栈实现的，回溯的时候才把点加入 $tp$ 数组，所以需要将 $tp$ 数组逆序才能得到拓扑序</li>
</ol>
<h3><span id="21-数据结构">2.1. 数据结构</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>; <span class="comment">// 题目中最大边数,拓扑排序是有向图建边,无需×2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">// 存储每个结点的颜色</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 存储拓扑序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 存储每个顶点起始边的编号,默认-1表示无边相连</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:编号为i的边可达的顶点编号</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:编号为i的边的下一条边的编号是ne[i]</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号,建边因子</span></span><br></pre></td></tr></table></figure>



<h3><span id="22-建图">2.2. 建图</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 头插法思想</span></span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-dfs">2.3. DFS</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	c[x]=<span class="number">-1</span>; <span class="comment">// 先染色为-1</span></span><br><span class="line">	<span class="comment">// 遍历所有儿子节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i]; <span class="comment">// 取出节点编号</span></span><br><span class="line">		<span class="keyword">if</span>(c[j]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遍历到祖先节点,有环,直接return</span></span><br><span class="line">		<span class="comment">// 如果没有遍历过</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!c[j])</span><br><span class="line">			<span class="comment">// 继续往下搜,自然结束return 0</span></span><br><span class="line">			<span class="keyword">if</span>(!dfs(j))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	c[x]=<span class="number">1</span>; <span class="comment">// 如果能够正常走掉dfs流程,则染色为1</span></span><br><span class="line">	tp.push(x); <span class="comment">// 进入拓扑序数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">toposort</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 用vector存储便于反转</span></span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c); <span class="comment">// 染色初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果c没有被走过</span></span><br><span class="line">		<span class="keyword">if</span>(!c[i])</span><br><span class="line">			<span class="comment">// 如果遇到环则说明无法形成拓扑序</span></span><br><span class="line">			<span class="keyword">if</span>(!dfs(i))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(tp.begin(),tp.end());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-算法对比">3. 算法对比</span></h2><ul>
<li>在实际使用拓扑排序时只需要掌握 $Kahn$ 即可，因为更好理解，$DFS$ 染色和二分图中的匈牙利算法的思想比较类似，这里只用了解即可<ul>
<li>$Kahn$：队列维护，顺着拓扑序收集点</li>
<li>$DFS$：系统栈维护，逆着拓扑序收集点</li>
</ul>
</li>
<li>二者时间复杂度都为 $O(E+V)$，其中 $E$ 为边数，$V$ 为点数</li>
</ul>
<h2><span id="4-例题洛谷-b3644">4. 【例题】洛谷 B3644</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/B3644">B3644 【模板】拓扑排序 &#x2F; 家谱树 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>; <span class="comment">// 题目中最大边数,拓扑排序是有向图建边,无需×2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的入度</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 维护入度为0的顶点的队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 记录q中顶点的出队顺序(拓扑序)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 存储每个顶点起始边的编号,默认-1表示无边相连</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:编号为i的边可达的顶点编号</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:编号为i的边的下一条边的编号是ne[i]</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号,建边因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 头插法思想</span></span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑序存储于tp队列中,如果能形成拓扑序返回true</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tuopu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果入度为0则加入队列</span></span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">0</span>) </span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 直接输出拓扑序</span></span><br><span class="line">		tp.push(x); <span class="comment">// 出队顺序即拓扑序</span></span><br><span class="line">		<span class="comment">// 遍历x的所有出边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果去掉边(i,j)后j的入度变为0,则加入队列</span></span><br><span class="line">			<span class="keyword">if</span>(--d[j]==<span class="number">0</span>) q.push(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 链式前向星邻接表初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line">		<span class="comment">// 当j==0时退出循环</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;j &amp;&amp; j) &#123;</span><br><span class="line">			add(i,j);</span><br><span class="line">			d[j]++; <span class="comment">// 节点j的入度++</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tuopu();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5边,接下来第i行表示节点i的后代,0表示输入完毕</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">4 5 1 0</span></span><br><span class="line"><span class="comment">1 0</span></span><br><span class="line"><span class="comment">5 3 0</span></span><br><span class="line"><span class="comment">3 0</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">2 4 5 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2024/10/07/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="快速幂">快速幂</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%BA%94%E7%94%A8%E4%B8%80-%E5%B9%82%E5%8F%96%E4%BD%99%E8%AE%A1%E7%AE%97-anmod-m">1. 应用一、幂取余：计算 $a^n(mod\ m)$</a></li>
<li><a href="#2-%E5%BA%94%E7%94%A8%E4%BA%8C-%E8%AE%A1%E7%AE%97%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">2. 应用二、计算斐波那契数列的第n项【矩阵快速幂】</a></li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E4%B8%89-%E5%B0%86%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E9%87%8D%E5%A4%8D-n-%E6%AC%A1%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">3. 应用三、将线性变换重复 $n$ 次【矩阵快速幂】</a></li>
<li><a href="#4-%E5%BA%94%E7%94%A8%E5%9B%9B-%E6%9E%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E9%BE%9F%E9%80%9F%E4%B9%98">4. 应用四、极斐波那契【矩阵快速幂+龟速乘】</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726135336870.png" alt="image-20230726135336870" style="zoom:67%;">

<ul>
<li>关键在于把a的n次方中的n拆分成二进制的表示形式</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726135625768.png" alt="image-20230726135625768" style="zoom: 80%;">

<ul>
<li><p>对于 $n$ 的二进制，我们从低到高不断遍历每一位，如果遍历到的那一位是 $1$ ，就 $r×a$</p>
</li>
<li><p>伪代码中的 $n(mod\ 2)$ 可以用 $n&amp;1$ 来表示，$n&#x3D;floor(n&#x2F;2)$ 也可以用无符号右移一位来表示，即 $n&gt;&gt;2$</p>
</li>
</ul>
<h2><span id="1-应用一-幂取余计算-anmod-m">1. 应用一、幂取余：计算 $a^n(mod\ m)$</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726140139764.png" alt="image-20230726140139764" style="zoom:67%;">

<ul>
<li>只需要在快速幂算法中合适的位置上加上 $mod\ m$，即可得到幂取模的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算a的n次方模m</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ModExpFast</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	a=a%m;</span><br><span class="line">	res=<span class="number">1</span>; <span class="comment">// 乘法操作的初始值(累积变量)</span></span><br><span class="line">	<span class="keyword">while</span>(n!=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">			res=(res*a)%m;</span><br><span class="line">		&#125;</span><br><span class="line">		a=(a*a)%m;</span><br><span class="line">		n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res; <span class="comment">// 得到最终的余数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,n,m;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot;^&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; mod &quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">ModExpFast</span>(a,n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>幂取模运算在密码学和数论中有着非常重要的应用，比如，幂取模运算是RSA公钥加密的核心运算之一。</li>
</ul>
<h2><span id="2-应用二-计算斐波那契数列的第n项矩阵快速幂">2. 应用二、计算斐波那契数列的第n项【矩阵快速幂】</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726142215151.png" alt="image-20230726142215151" style="zoom:67%;">

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240207111727658.png" alt="image-20240207111727658" style="zoom:80%;">

<ul>
<li><p>以上是适用于矩阵快速幂的数据范围</p>
</li>
<li><p>只需要计算出 $[1\ 1; 1\ 0]$ 的 $n$次方和已知 $F0$ 与 $F1$，就可以计算出第 $n$ 项</p>
</li>
<li><p>以下是一个利用矩阵快速幂计算第 $n$ 项并维护前 $n$ 项和的矩阵快速幂模板</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 矩阵快速幂求斐波那契数列,[fn, fn+1] × [0 1; 1 1]= f[n+1, fn+2]</span></span><br><span class="line"><span class="comment">// 这道题还要求斐波那契数列前n项的和,所以除了fn以外还需要维护Sn</span></span><br><span class="line"><span class="comment">// [fn, fn+1, sn] × [0 1 0; 1 1 0; 0 1 1] = f[n+1, fn+2, sn+1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3</span>; <span class="comment">// 矩阵3×3</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 本题要求计算出前n项和mod m的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维×二维两重循环,c=a*b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[],<span class="type">int</span> a[],<span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">			temp[i]=(temp[i]+(ll)a[j]*b[j][i])%m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意:传进来的指针和本身的指针有区别(形参),如果这里sizeof c</span></span><br><span class="line">	<span class="comment">// 传回来的是指针的长度,而不是数组的长度,所以sizeof temp</span></span><br><span class="line">	<span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维×二维三重循环,c=a*b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N],<span class="type">int</span> a[][N],<span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;N;k++) &#123;</span><br><span class="line">				temp[i][j]=(temp[i][j]+(ll)a[i][k]*b[k][j])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> f1[N]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">// f1,f2,s1;存储答案,f1[2]就是Sn</span></span><br><span class="line">	<span class="comment">// 推导出来的幂矩阵</span></span><br><span class="line">	<span class="type">int</span> a[N][N]= &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 计算f1×a^n</span></span><br><span class="line">	<span class="comment">// 迭代计算,类似于滚动数组,没有利用额外的空间</span></span><br><span class="line">	n--; <span class="comment">// 调整斐波那契数列的起始位置</span></span><br><span class="line">	<span class="comment">// 快速幂思想</span></span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="built_in">mul</span>(f1,f1,a); <span class="comment">// res=res*a,调用一维矩阵×二维矩阵的mul方程</span></span><br><span class="line">		<span class="built_in">mul</span>(a,a,a); <span class="comment">// a=a*a,调用二维矩阵×二维矩阵的mul方程</span></span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f1[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-应用三-将线性变换重复-n-次矩阵快速幂">3. 应用三、将线性变换重复 $n$ 次【矩阵快速幂】</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726142534642.png" alt="image-20230726142534642" style="zoom:67%;">



<h2><span id="4-应用四-极斐波那契矩阵快速幂龟速乘">4. 应用四、极斐波那契【矩阵快速幂+龟速乘】</span></h2><ul>
<li>对我来说有难度，暂时不上代码</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2024/10/02/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="排序">排序</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">1. 快速排序</a></li>
<li><a href="#2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">2. 归并排序</a></li>
<li><a href="#3-%E6%A1%B6%E6%8E%92%E5%BA%8F">3. 桶排序</a></li>
<li><a href="#4-%E5%A0%86%E6%8E%92%E5%BA%8F">4. 堆排序</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-快速排序">1. 快速排序</span></h2><blockquote>
<p>时间复杂度：$O(nlog^n)$，最坏 $O(n^2)$ ，不稳定</p>
</blockquote>
<ul>
<li>基于分治法实现：</li>
</ul>
<ol>
<li>确定分界点</li>
<li>调整区间</li>
<li>递归处理左右两段</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序模板</span></span><br><span class="line"><span class="comment">// l:左端点</span></span><br><span class="line"><span class="comment">// r:右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 无符号右移一位等于除2</span></span><br><span class="line">	<span class="type">int</span> x=arr[l+r&gt;&gt;<span class="number">1</span>]; <span class="comment">// 找中间值</span></span><br><span class="line">	<span class="comment">// 遍历因子</span></span><br><span class="line">	<span class="type">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> j=r<span class="number">+1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">        <span class="comment">// 把下面两个while中的&quot;&lt;&quot;和&quot;&gt;&quot;换一下就是从大到小排序</span></span><br><span class="line">		<span class="keyword">while</span>(arr[++i]&lt;x);</span><br><span class="line">		<span class="keyword">while</span>(arr[--j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">			<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分治法</span></span><br><span class="line">	<span class="built_in">quick_sort</span>(arr,l,j); <span class="comment">// 排序左侧</span></span><br><span class="line">	<span class="built_in">quick_sort</span>(arr,j<span class="number">+1</span>,r); <span class="comment">// 排序右侧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-归并排序">2. 归并排序</span></h2><blockquote>
<p>时间复杂度妥妥的：$O(nlog^2)$，稳定</p>
</blockquote>
<ul>
<li>基于分治法实现：</li>
</ul>
<ol>
<li>确定分界点</li>
<li>递归把数据分成两段</li>
<li>合二为一</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序模板</span></span><br><span class="line"><span class="comment">// arr[]:待排序数组</span></span><br><span class="line"><span class="comment">// l:排序左区间</span></span><br><span class="line"><span class="comment">// r:排序右区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 传入数据有误</span></span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 递归将数据分成两段,回来时排序</span></span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,l,mid);</span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">// 回来时的操作</span></span><br><span class="line">	<span class="comment">// k:temp数组的遍历因子/</span></span><br><span class="line">	<span class="comment">// i:第一段的最左端</span></span><br><span class="line">	<span class="comment">// j:第二段的最左端</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 从小到大排序</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">			temp[k++]=arr[i++]; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[k++]=arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把未排好的直接添加到temp末尾,下面两种情况二选一</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++]=arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">		temp[k++]=arr[j++];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此时l和r是形参传递过来的l和r</span></span><br><span class="line">	<span class="comment">// j:temp的遍历因子,目的是赋值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) &#123;</span><br><span class="line">		arr[i]=temp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷</a></p>
</blockquote>
<ul>
<li>该题为利用归并排序求解逆序对的问题，携带了如何输出逆序对，但是没有解决以字典顺序输出逆序对的问题，可能要用其他算法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> arr[maxn];</span><br><span class="line"><span class="type">int</span> temp[maxn]; <span class="comment">// 辅助数组</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res; <span class="comment">// n=5e5,最大对数可能超过1e10*2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 先分</span></span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,l,mid);</span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">// 合并</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">			temp[k++]=arr[i++];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 输出逆序对</span></span><br><span class="line"><span class="comment">//			for(int m=i;m&lt;=mid;m++) &#123;</span></span><br><span class="line"><span class="comment">//				cout&lt;&lt;&quot;&lt;&quot;&lt;&lt;arr[m]&lt;&lt;&quot;,&quot;&lt;&lt;arr[j]&lt;&lt;&quot;&gt;&quot;&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			temp[k++]=arr[j++];</span><br><span class="line">			<span class="comment">// 如果arr[i]比arr[j]大了,那么arr[i]右边的也比它大</span></span><br><span class="line">			res+=(mid-i<span class="number">+1</span>); <span class="comment">// 一共mid-i+1个</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++]=arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">		temp[k++]=arr[j++];</span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) &#123;</span><br><span class="line">		arr[i]=temp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="comment">// test</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,<span class="number">1</span>,n);</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;arr[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-桶排序">3. 桶排序</span></h2><blockquote>
<p>时间复杂度：$O(n+k)$，$n$ 是输入数据量，$k$ 是桶的个数；空间复杂度：$O(k)$，额外分配的内存就是 $k$ 个桶的空间</p>
</blockquote>
<ol>
<li>装桶</li>
<li>倒桶</li>
</ol>
<ul>
<li>注意：桶排序容易超出最大值（字典思想），通常每个值都特别限定的范围时用桶排序，如每个值都限定在 $[0,50]$ 之间。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NUM=<span class="number">1e8</span>; <span class="comment">// 最大值不能超过1e8</span></span><br><span class="line"><span class="type">int</span> sum[MAX_NUM]; <span class="comment">// 值域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 字典装桶</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		sum[arr[i]]++; <span class="comment">// 把数组的值装进桶</span></span><br><span class="line">	<span class="comment">// 倒出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 当sum[i]&gt;=1时才进入while</span></span><br><span class="line">		<span class="keyword">while</span>(sum[i]--)</span><br><span class="line">			arr[j++]=i; <span class="comment">// 下标即是值,对arr重新赋值排序后的结果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>桶排序完整案例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+4</span>; <span class="comment">// 数字最大1e4个</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv=<span class="number">1e4</span><span class="number">+4</span>; <span class="comment">// 每个数字的值最大1e4</span></span><br><span class="line"><span class="type">int</span> arr[maxv]; <span class="comment">// 桶</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">// 字典装桶</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		arr[temp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从大到小倒桶</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=maxv;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="comment">// 该字符打印arr[i]次,如果j=0则不进入</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr[i];j++) <span class="comment">// 注意这层循环的遍历次数由i来决定,所以这两层循环的时间复杂度都取决于i</span></span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-堆排序">4. 堆排序</span></h2><blockquote>
<p>时间复杂度：$O(nlog^n)$</p>
</blockquote>
<ul>
<li>堆（完全二叉树）：有大根堆和小根堆之分。</li>
</ul>
<ol>
<li>求堆最小值：$q[1]$</li>
<li>删除最小值：$q[1]&#x3D;q[size]$，$down(1)$</li>
<li>输出堆顶，删除堆顶，长度减一，$down(1)$</li>
</ol>
<ul>
<li>注：$down$ 是调整堆的操作，即与自己的孩子比较，将自己的值与其中最小且比自身更小的值交换。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序模板</span></span><br><span class="line"><span class="comment">// sz:当前堆大小</span></span><br><span class="line"><span class="comment">// t:当前堆</span></span><br><span class="line"><span class="type">int</span> sz; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t=u; </span><br><span class="line">	<span class="comment">// 如果左孩子在范围内且值更小</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">2</span>*u&lt;=sz &amp;&amp; arr4[t]&gt;arr4[<span class="number">2</span>*u])</span><br><span class="line">		t=<span class="number">2</span>*u;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">2</span>*u<span class="number">+1</span>&lt;=sz &amp;&amp; arr4[t]&gt;arr4[<span class="number">2</span>*u<span class="number">+1</span>])</span><br><span class="line">		t=<span class="number">2</span>*u<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(t!=u) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr4[t],arr4[u]);</span><br><span class="line">		<span class="built_in">down</span>(t); <span class="comment">// 递归调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数部分：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试堆排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    cin&gt;&gt;arr4[i];</span><br><span class="line">&#125;</span><br><span class="line">sz=n; <span class="comment">// 初始堆大小</span></span><br><span class="line"><span class="comment">// 建立小根堆</span></span><br><span class="line"><span class="comment">// n/2是最后一个有孩子的节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i;i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    cout&lt;&lt;arr4[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 输出堆顶</span></span><br><span class="line">    arr4[<span class="number">1</span>]=arr4[sz--]; <span class="comment">// 调整堆顶</span></span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">// 调整堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索开关问题</title>
    <url>/2024/10/05/%E6%90%9C%E7%B4%A2%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="搜索开关问题">搜索开关问题</span></h1><!-- toc -->

<ul>
<li><a href="#%E4%BE%8B1-%E7%BF%BB%E7%A1%AC%E5%B8%81">[例1]. 翻硬币</a></li>
<li><a href="#%E4%BE%8B2-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3">[例2]. 费解的开关</a></li>
<li><a href="#%E4%BE%8B3-%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F">[例3]. 飞行员兄弟</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>开关问题是RoysterCDD自己取的名字，表示一类用位运算解决的搜索变种问题</p>
</blockquote>
<h2><span id="例1-翻硬币">[例1]. 翻硬币</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211111035470.png" alt="image-20240211111035470" style="zoom:80%;">

<ul>
<li>本题的思路是直接用两个字符数组$start$和$finish$来存储初始状态和结束状态，因为题目说一定有解，所以对比两个数组，出现状态不同，则翻转该硬币和相邻硬币即可，假设每两个硬币间存在一个开关，按下该开关即可翻转相邻两枚硬币的状态</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 给你一个初始状态,一个目标状态,还有某种操作,最常用做法:BFS,同样的题目还有八数码</span></span><br><span class="line"><span class="comment">// 但是BFS时间复杂度比较高,局面很多的话应考虑其他做法,可以考虑和费解的开关相同的做法</span></span><br><span class="line"><span class="comment">// 假设每两个灯泡之间中间有一个开关,这个开关按下后可以翻转其两侧灯泡的亮灭状态</span></span><br><span class="line"><span class="comment">// 这样的话想从初始状态到最终状态(假设每个开关只摁一次)只有唯一的一组解</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> start[N],finish[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start[i]==<span class="string">&#x27;*&#x27;</span>) start[i]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> start[i]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;start&gt;&gt;finish;</span><br><span class="line">	n=<span class="built_in">strlen</span>(start); <span class="comment">// 初始状态的长度,即硬币的总个数</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 如果状态不相同,则翻转该硬币和相邻硬币的状态</span></span><br><span class="line">		<span class="keyword">if</span>(start[i]!=finish[i]) &#123;</span><br><span class="line">			<span class="built_in">turn</span>(i),<span class="built_in">turn</span>(i<span class="number">+1</span>);</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="例2-费解的开关">[例2]. 费解的开关</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211100922703.png" alt="image-20240211100922703"></p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211104635922.png" alt="image-20240211104635922" style="zoom:67%;">

<ul>
<li>题目的思路：输入图的状态后，我们对第一行灯的操作，实际上就能够确定剩下四行我们应该对灯进行什么操作，所以枚举第一行的每种操作，从$00000$到$11111$，$1$表示翻转，$0$表示不翻转，$[0,31]$共$32$种情况，所以枚举$op&#x3D;[0,31]$，用位运算的方式判断每一位是否为$1$</li>
<li>当第一行的操作确定后，比如$g[0,2]&#x3D;&#x3D;0$，那我们就要去点亮第二行的$g[1,2]$，用上下左右的上方向去点亮第一行未被点亮的灯，对于剩余行的操作都是一样的，遍历完后如果我们发现最后一行有未被点亮的灯或者操作数多于6次，那么就无法达到，输出$-1$即可</li>
<li>对于每种第一行的操作，我们用$res&#x3D;min(res,step)$来更新最小的答案，本题的技巧还有位运算的技巧、二进制状态表示、准备一个备份数组$backup[N][N]$用于状态复原等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6</span>;</span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N]; <span class="comment">// 图和备份</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;; <span class="comment">// 五个方位(0,0表示本身这个点)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a=x+dx[i], b=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=<span class="number">5</span> || b&lt;<span class="number">0</span> || b&gt;=<span class="number">5</span>) <span class="keyword">continue</span>; <span class="comment">// 越界处理</span></span><br><span class="line">		<span class="comment">// 因为0和1的ASCII码表示分别为48(110000和49(110001)</span></span><br><span class="line">		<span class="comment">// 所以只需要亦或一个1,亦或0不变,亦或1反转,亦或一个1反转最后一位</span></span><br><span class="line">		g[a][b]^=<span class="number">1</span>; <span class="comment">// 即可让48-&gt;49,49-&gt;48</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 每一行开关的操作完全被前一行灯的亮灭状态所确定</span></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) cin&gt;&gt;g[i]; <span class="comment">// 输入图</span></span><br><span class="line">		<span class="type">int</span> res=<span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们枚举第一行的操作</span></span><br><span class="line">		<span class="comment">// 0~31表示的是00000到11111(遍历每一种操作,1表示我们翻转,0表示不翻转)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">32</span>;op++) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 复制g给backup,操作g</span></span><br><span class="line">			<span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 判断第一行中op共5位中哪一位是1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">				<span class="comment">// op&gt;&gt;i&amp;1:先右移i位,现在第i位变成最低位,再看是否为1</span></span><br><span class="line">				<span class="keyword">if</span>(op&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					step++; <span class="comment">// 经过一次操作</span></span><br><span class="line">					<span class="built_in">turn</span>(<span class="number">0</span>,i); <span class="comment">// 翻转为1的这一位的状态</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 所以第一行的状态影响了接下来所有行的状态</span></span><br><span class="line">			<span class="comment">// 遍历第一行到倒数第二行,如果为0的话就翻转</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						step++; <span class="comment">// 如果为0那么需要翻转一次</span></span><br><span class="line">						<span class="built_in">turn</span>(i<span class="number">+1</span>,j); <span class="comment">// 下一行的第j个元素需要翻转</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">bool</span> dark=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">				<span class="comment">// 如果最后一行有没亮的,那就别无他法了</span></span><br><span class="line">				<span class="keyword">if</span>(g[<span class="number">4</span>][i]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">					dark=<span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!dark) res=<span class="built_in">min</span>(res,step);</span><br><span class="line">			<span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g); <span class="comment">// 恢复状态</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;<span class="number">6</span>) res=<span class="number">-1</span>; <span class="comment">// 题目要求不能超过6步</span></span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="例3-飞行员兄弟">[例3]. 飞行员兄弟</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105824073.png" alt="image-20240211105824073" style="zoom:80%;">

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105917746.png" alt="image-20240211105917746"></p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105930997.png" alt="image-20240211105930997" style="zoom:80%;">

<ul>
<li>本题的思路类似，一共$16$个开关，所以方案总数是$2^{16}&#x3D;65535$种，故枚举$[0,2&lt;&lt;16]$来表示对于这$16$的开关的操作，所以这个$int$型的二进制表示中某一位的值是$1$表示我们要改变这个开关的状态，$0$则表示不改变，枚举每种操作，最后看是否能够使所有把手都打开，如果可以的话把方案加入到$vector$数组中，最后打印即可</li>
<li>技巧：$get(x,y)$函数返回的值代表二维数组中对应位置在二进制表示中的第几个开关（下标）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 本题的难点在于每个灯泡可以被很多开关所控制</span></span><br><span class="line"><span class="comment">// 用暴力法来做,只有4*4=16个开关,所以每个开关嗯的方案数是2^16=65536</span></span><br><span class="line"><span class="comment">// 枚举所有方案→0~2^16-1,用二进制表示,某位为1是摁下,为0表示不摁</span></span><br><span class="line"><span class="comment">// 按照该方案对所有灯泡进行操作,判断灯泡是不是全亮,是的话则记录方案</span></span><br><span class="line"><span class="comment">// 现在要求:步数最小/字典序最小(从小到大排序就可以了)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是(x,y)上的数是第几个开关,从上往下从左往右编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*<span class="number">4</span>+y; <span class="comment">// 从0~15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+&quot;和&quot;-&quot;翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_one</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g[x][y]==<span class="string">&#x27;+&#x27;</span>) g[x][y]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> g[x][y]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_all</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">turn_one</span>(x,i); <span class="comment">// 这一行上的数翻转状态</span></span><br><span class="line">		<span class="built_in">turn_one</span>(i,y); <span class="comment">// 这一列上的数翻转状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">turn_one</span>(x,y); <span class="comment">// 因为(x,y)在这一行和这一列交汇处,所以翻转两次相当于没有翻转,再单独翻转一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		cin&gt;&gt;g[i];</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;PII&gt; res; <span class="comment">// 存储所有的方案</span></span><br><span class="line">	<span class="comment">// 枚举每种操作情况,每个开关对应开和不开两种状态,方案数是2^16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">1</span>&lt;&lt;<span class="number">16</span>;op++) &#123;</span><br><span class="line">		vector&lt;PII&gt; temp; <span class="comment">// 每次新开一个,相当于清空了</span></span><br><span class="line">		<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 备份图</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">				<span class="comment">// 如果op在这一位上的值为1</span></span><br><span class="line">				<span class="keyword">if</span>(op&gt;&gt;<span class="built_in">get</span>(i,j)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// 向temp中记录一下操作数</span></span><br><span class="line">					temp.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">					<span class="built_in">turn_all</span>(i,j); <span class="comment">// 进行一次反转操作</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">// 判断所有灯泡是否全亮</span></span><br><span class="line">		<span class="type">bool</span> has_closed=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">					has_closed=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(has_closed==<span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(res.<span class="built_in">empty</span>()||res.<span class="built_in">size</span>()&gt;temp.<span class="built_in">size</span>()) res=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g); <span class="comment">// 还原</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 方案总数</span></span><br><span class="line">	<span class="comment">// 打印每一种方案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> op:res) cout&lt;&lt;op.x<span class="number">+1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;op.y<span class="number">+1</span>&lt;&lt;endl; <span class="comment">// 坐标+1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>搜索</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索总结</title>
    <url>/2024/10/05/%E6%90%9C%E7%B4%A2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="搜索总结">搜索总结</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs">1. 深度优先搜索DFS</a><ul>
<li><a href="#11-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98">1.1. 全排列问题</a></li>
<li><a href="#12-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">1.2. n皇后问题</a></li>
</ul>
</li>
<li><a href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs">2. 广度优先搜索BFS</a><ul>
<li><a href="#21-%E8%B5%B0%E8%BF%B7%E5%AE%AB">2.1. 走迷宫</a></li>
<li><a href="#22-%E5%85%AB%E6%95%B0%E7%A0%81">2.2. 八数码</a></li>
</ul>
</li>
<li><a href="#3-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8">3. 树和图的存储</a><ul>
<li><a href="#31-%E6%9C%89%E5%90%91%E5%9B%BE">3.1. 有向图</a><ul>
<li><a href="#311-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">3.1.1. 邻接矩阵</a></li>
<li><a href="#312-%E9%82%BB%E6%8E%A5%E8%A1%A8">3.1.2. 邻接表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">4. 树和图的遍历</a><ul>
<li><a href="#41-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">4.1. 深度优先遍历</a></li>
<li><a href="#42-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">4.2. 广度优先遍历</a></li>
<li><a href="#43-%E6%A8%A1%E6%9D%BF">4.3. 模板</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-深度优先搜索dfs">1. 深度优先搜索DFS</span></h2><blockquote>
<p>数据结构 stack，空间复杂度O(n)，不具有最短性，深搜问题没有模板</p>
</blockquote>
<ul>
<li>关键在于：剪枝和回溯</li>
</ul>
<h3><span id="11-全排列问题">1.1. 全排列问题</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[maxn]; <span class="comment">// 每一步填的数字</span></span><br><span class="line"><span class="type">bool</span> st[maxn]; <span class="comment">// 遍历状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 跳出条件</span></span><br><span class="line">	<span class="keyword">if</span>(u==n) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">			cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果还没有填满,从数字1开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			path[u]=i;</span><br><span class="line">			st[i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 进入下一层</span></span><br><span class="line">			<span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">			<span class="comment">// 回溯</span></span><br><span class="line">			st[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-n皇后问题">1.2. n皇后问题</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 皇后个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">9</span>; <span class="comment">// 最大皇后个数</span></span><br><span class="line"><span class="type">int</span> x[maxn<span class="number">+1</span>]; <span class="comment">// 存放皇后位置,x[i]表示第i个皇后的在第几列</span></span><br><span class="line"><span class="type">int</span> res; <span class="comment">// n皇后的可行解个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第i个皇后放置在x[i]列是否会发生冲突</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">place</span><span class="params">(<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// j=1~i-1是已经放置了皇后的行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;j;i++) &#123;</span><br><span class="line">		<span class="comment">// x数组的物理性质决定两个皇后不会发生行冲突</span></span><br><span class="line">		<span class="comment">// x[j]==x[i]:发生列冲突</span></span><br><span class="line">		<span class="comment">// abs(i-j)==abs(x[i]-x[j]):发生对角线冲突,可画图推导</span></span><br><span class="line">		<span class="keyword">if</span>(x[j]==x[i] || <span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(x[i]-x[j]))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 冲突就返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	res++; <span class="comment">// 答案+1</span></span><br><span class="line">	<span class="comment">// 遍历每个皇后</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 遍历每一列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="comment">// 如果皇后所在列就是j,打印&#x27;Q&#x27;</span></span><br><span class="line">			<span class="keyword">if</span>(x[i]==j)</span><br><span class="line">				cout&lt;&lt;<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放置每个皇后的深度优先搜索函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 遍历第1列到n列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">		<span class="comment">// 先把皇后放到第j列</span></span><br><span class="line">		x[u]=j;</span><br><span class="line">		<span class="comment">// 如果第u个皇后放在这列不冲突</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">place</span>(u)) &#123;</span><br><span class="line">			<span class="comment">// 找到了一个可行解,直接打印</span></span><br><span class="line">			<span class="keyword">if</span>(u==n)</span><br><span class="line">				<span class="built_in">print</span>();</span><br><span class="line">			<span class="comment">// 向下递归</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 从第一个皇后开始</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;可行解一共有 &quot;</span>&lt;&lt;res&lt;&lt;<span class="string">&quot; 个&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-广度优先搜索bfs">2. 广度优先搜索BFS</span></h2><blockquote>
<p>数据结构 queue，空间复杂度O(2^n)，最短路，宽搜问题有模板</p>
</blockquote>
<h3><span id="21-走迷宫">2.1. 走迷宫</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 地图范围</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图的情况</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 每个点到初始点的距离</span></span><br><span class="line">PII q[N*N]; <span class="comment">// BFS的队列</span></span><br><span class="line">PII Prev[N][N]; <span class="comment">// 记录遍历的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// hh:队头,当前要处理元素的下标</span></span><br><span class="line">	<span class="comment">// tt:队尾,最后一个入队元素的下标</span></span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化,表示害没有任何点经过</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">	d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 向量表示四个方向</span></span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt) &#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q[hh++]; <span class="comment">// 取出队头</span></span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">			<span class="comment">// 如果没有超出地图范围且g[x][y]=0且没有到过</span></span><br><span class="line">			<span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; g[x][y]==<span class="number">0</span> &amp;&amp; d[x][y]==<span class="number">-1</span>) &#123;</span><br><span class="line">				d[x][y]=d[t.first][t.second]<span class="number">+1</span>; <span class="comment">// 距离加1</span></span><br><span class="line">				Prev[x][y]=t; <span class="comment">// 记录上一步</span></span><br><span class="line">				q[++tt]=&#123;x,y&#125;; <span class="comment">// 把x,y放进队头</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出路径</span></span><br><span class="line"><span class="comment">//	int x=n-1,y=m-1;</span></span><br><span class="line"><span class="comment">//	// [0,1] [1,0]都可以输出</span></span><br><span class="line"><span class="comment">//	while(x||y) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		auto t=Prev[x][y];</span></span><br><span class="line"><span class="comment">//		x=t.first,y=t.second;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回距离</span></span><br><span class="line">	<span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			cin&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-八数码">2.2. 八数码</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 八重码:类似于一个数字华容道嘛,求移动的最少步数(BFS)</span></span><br><span class="line"><span class="comment">// 难点在于状态表示比较复杂,每个状态是一个3*3的小矩阵</span></span><br><span class="line"><span class="comment">// 问题一:队列,如果把每个状态放进队列中 &quot;12345678x&quot;</span></span><br><span class="line"><span class="comment">// 问题二:如何计算每个状态的距离 &quot;queue&lt;string&gt;,unordered_map&lt;string,int&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">queue&lt;string&gt; q; <span class="comment">// 定义队列</span></span><br><span class="line"><span class="comment">// 让字符串映射到int类型的值</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; d; <span class="comment">// 通过哈希表来让字符串变化时和移动的距离数值关联</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(st); <span class="comment">// 将字符串入队</span></span><br><span class="line">	d[st]=<span class="number">0</span>; <span class="comment">// 将初始状态的字符串的哈希值设定为0</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">// 定义四个方向向量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5在一维数组中的下标是4</span></span><br><span class="line">	string end=<span class="string">&quot;12345678x&quot;</span>; <span class="comment">// 定义宽度优先搜素的终止状态</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) <span class="comment">// 循环终止状态</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q.<span class="built_in">front</span>(); <span class="comment">// 将队列中存着的字符串赋值给t</span></span><br><span class="line">		q.<span class="built_in">pop</span>(); <span class="comment">// 队头元素弹出</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(t==end) </span><br><span class="line">			<span class="keyword">return</span> d[t]; <span class="comment">// 如果当前字符串等于终止状态搜索结束返回该字符串对应的哈希值</span></span><br><span class="line">		<span class="comment">//此处的哈希函数值对应于字符串移动的次数    </span></span><br><span class="line">		<span class="type">int</span> distance = d[t]; <span class="comment">// 定义一个临时变量distance存储形成t字符串当前的移动次数</span></span><br><span class="line">		<span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// k表示&#x27;x&#x27;字符在字符串当前的下标</span></span><br><span class="line">		<span class="comment">// 把&#x27;x&#x27;所在的下标转换成二维数组的形式,比如&quot;12345678x&quot;,x就是8,8/3=2,8%3=2,所以是第三行第三列</span></span><br><span class="line">		<span class="type">int</span> x = k/<span class="number">3</span>,y = k%<span class="number">3</span>; <span class="comment">// 由于字符串当前是一维的将一维下标转化为二维坐标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">// 分别遍历四个方向</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// 遍历&#x27;x&#x27;可以走的四个方向</span></span><br><span class="line">			<span class="type">int</span> a=x+dx[i],b=y+dy[i]; <span class="comment">//将下一个搜索位置的x,y坐标表示</span></span><br><span class="line">			<span class="comment">// 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">3</span>&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;<span class="number">3</span>) <span class="comment">//当二维坐标满足位于3X3矩阵中时</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将搜索位置和&#x27;x&#x27;相交换,a*3+b变回一维数组索引</span></span><br><span class="line">				<span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]); <span class="comment">//将字符串中的搜索位置与字符&#x27;x&#x27;交换</span></span><br><span class="line">				<span class="comment">// d.count(t)是统计d这个哈希表容器中t出现的次数,如果一次都没出现过,就放进队列,同时在dist[t]上做加减</span></span><br><span class="line">				<span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)) <span class="comment">// 如果当前的字符串的哈希值为0</span></span><br><span class="line">				&#123;</span><br><span class="line">					d[t]=distance<span class="number">+1</span>; <span class="comment">// 将该字符串对应的哈希值在原字符串对应的哈希值基础上加1</span></span><br><span class="line">					q.<span class="built_in">push</span>(t); <span class="comment">// 将该字符串入队</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]); <span class="comment">// 恢复现场,返回位置判断其他方向</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果无法移动到终止位置返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	string st;</span><br><span class="line">	<span class="comment">// 输入一个初始状态</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		st+=s; <span class="comment">//逐个输入字符串</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>(st)&lt;&lt;endl; <span class="comment">//输出宽度优先搜索的数值	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-树和图的存储">3. 树和图的存储</span></h2><blockquote>
<p>树是一种特殊的图，因此只讨论图</p>
</blockquote>
<h3><span id="31-有向图">3.1. 有向图</span></h3><h4><span id="311-邻接矩阵">3.1.1. 邻接矩阵</span></h4><ul>
<li>邻接矩阵不能存储重边，空间复杂度O(n²)，适合稠密图</li>
</ul>
<h4><span id="312-邻接表">3.1.2. 邻接表</span></h4><ul>
<li>每个结点开一个单链表，邻接表内部的顺序是无所谓的，邻接表插入新边后引入新的结点一般用头插法</li>
</ul>
<h2><span id="4-树和图的遍历">4. 树和图的遍历</span></h2><h3><span id="41-深度优先遍历">4.1. 深度优先遍历</span></h3><blockquote>
<p>时间复杂度O(n+m)，点数+边数</p>
</blockquote>
<ul>
<li>优点在于可以求出每一棵子树的大小。</li>
</ul>
<h3><span id="42-广度优先遍历">4.2. 广度优先遍历</span></h3><blockquote>
<p>时间复杂度O(n+m)，点数+边数</p>
</blockquote>
<ul>
<li>优点在于可以求出最短路径，但前提是每条路的权重相同</li>
</ul>
<h3><span id="43-模板">4.3. 模板</span></h3><blockquote>
<p>注意DFS是没有模板的，但基本可以分为终止条件、递归逻辑、剪枝、恢复现场几个步骤，在另一篇博客里给出了我自己对于DFS的模板，BFS有模板</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入输出规模在100w的时候必须用scanf</span></span><br><span class="line"><span class="comment">// 树和图的存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="comment">// h[i]:第i个结点的邻接表,头插,存储边</span></span><br><span class="line"><span class="comment">// e[j]:第j条边指向的结点</span></span><br><span class="line"><span class="comment">// ne[j]:第j条边的下一条边</span></span><br><span class="line"><span class="comment">// idx:边的编号</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 每个点的搜索状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N],d[N]; <span class="comment">// bfs队列和距离数组</span></span><br><span class="line"><span class="type">int</span> Prev[N]; <span class="comment">// 记录顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第idx条边指向的结点是b</span></span><br><span class="line">	<span class="comment">// 第idx条边的下一条边是a的单链表(头结点)</span></span><br><span class="line">	<span class="comment">// 结点a的邻接表的第一条边变为idx,idx++</span></span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs找最短路径为例:注意每条路的权重必须都相同,如这里的1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>; <span class="comment">// 队头和队尾</span></span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 头结点是1</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); <span class="comment">// 距离初始化为-1</span></span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 第1个结点到第1个结点的距离是0</span></span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt) &#123;</span><br><span class="line">		<span class="type">int</span> t=q[hh++]; <span class="comment">// 取出头结点,hh++</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果j还未访问过</span></span><br><span class="line">			<span class="keyword">if</span>(d[j]==<span class="number">-1</span>) &#123;</span><br><span class="line">				d[j]=d[j]<span class="number">+1</span>;</span><br><span class="line">				q[++tt]=j; <span class="comment">// 在队尾增加一个空位,再把j的值赋给q[tt]</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	st[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 从u的第一条边开始往下遍历每一条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="comment">// 如果还未被访问过,就继续dfs[j]</span></span><br><span class="line">		<span class="keyword">if</span>(!st[j])</span><br><span class="line">			dfs[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化为-1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>日期问题</title>
    <url>/2024/10/02/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="模拟日期">模拟日期</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F">1. 回文日期</a></li>
<li><a href="#2-%E9%A1%BA%E5%AD%90%E6%97%A5%E6%9C%9F">2. 顺子日期</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-回文日期">1. 回文日期</span></h2><ul>
<li>从这道题中主要学习的思路是：直接用int型数据模拟日期，从而进行枚举，再判断这个日期是否合法，是否满足题目的要求</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 日期问题,跟shit一样,但是做一遍找到规律就没问题了</span></span><br><span class="line"><span class="comment">// 输入一个起始日期和一个终止日期,最后返回这个日期中有多少个日期是回文的</span></span><br><span class="line"><span class="comment">// 换个思路,我们枚举所有的回文数,因为前四位确定了后四位就一定确定了</span></span><br><span class="line"><span class="comment">// 前四位&gt;=1000,又因为是四位数,所以最大9999,范围则[1000,9999]</span></span><br><span class="line"><span class="comment">// 把字符串拼接起来过后再去判断日期是否合法</span></span><br><span class="line"><span class="comment">// 如何判断一个日期是否在两个日期之间?字典序嘛,不用想复杂了</span></span><br><span class="line"><span class="comment">// 最后如何判断日期是否合法呢?用一个数组month存储每一个月的状态</span></span><br><span class="line"><span class="comment">// 对于2月,还要考虑平年和闰年的情况</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> months[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;; <span class="comment">// 1~12月的天数,平年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期是否合法,完全可以当模板</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> date)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> year=date/<span class="number">10000</span>; <span class="comment">// 取前四位</span></span><br><span class="line">	<span class="type">int</span> month=date%<span class="number">10000</span>/<span class="number">100</span>; <span class="comment">// 后四位的前两位</span></span><br><span class="line">	<span class="type">int</span> day=date%<span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果月份不合法和天数=0</span></span><br><span class="line">	<span class="keyword">if</span>(!month || month&gt;=<span class="number">13</span> || !day) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 平年下天数不合法</span></span><br><span class="line">	<span class="keyword">if</span>(month!=<span class="number">2</span> &amp;&amp; day&gt;months[month]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 月份为2,单独判断是否为闰年以及合法与否</span></span><br><span class="line">	<span class="keyword">if</span>(month==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// 四年一闰,百年不闰,四百年又闰</span></span><br><span class="line">		<span class="type">bool</span> leap= year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span> || year%<span class="number">400</span>==<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(day&gt;months[month]+leap) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> date1,date2;</span><br><span class="line">	cin&gt;&gt;date1&gt;&gt;date2; <span class="comment">// 开始和结束日期</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 只枚举年份</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> date=i,x=i;</span><br><span class="line">		<span class="comment">// 拼接成回文数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">			date=date*<span class="number">10</span>+x%<span class="number">10</span>; <span class="comment">// 取后四位的最后一位拼上来</span></span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(date1&lt;=date &amp;&amp; date&lt;=date2 &amp;&amp; <span class="built_in">check</span>(date)) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-顺子日期">2. 顺子日期</span></h2><ul>
<li>本题要学的思路是用sprintf函数将指定格式的int型的year, month, day的值输入到字符数组中制造字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: YYYYMMdd这个日期格式中若出现三个升序连续的数字,记为顺子年</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目只要求找2022年,这是一个平年</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> months[]=&#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,</span><br><span class="line">	<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,</span><br><span class="line">	<span class="number">31</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串表示日期,判断是否为顺子年</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i<span class="number">+2</span>&lt;str.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i<span class="number">+1</span>]==str[i]<span class="number">+1</span> &amp;&amp; str[i<span class="number">+2</span>]==str[i<span class="number">+1</span>]<span class="number">+1</span> &amp;&amp; str[i]!=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> year=<span class="number">2022</span>,month=<span class="number">1</span>,day=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 一年中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">365</span>;i++) &#123;</span><br><span class="line">		<span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// 用sprintf函数按照指定格式制造字符串</span></span><br><span class="line">		<span class="built_in">sprintf</span>(str,<span class="string">&quot;%04d%02d%02d&quot;</span>,year,month,day); <span class="comment">// %04d不足4位自动补0</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(str)) &#123;</span><br><span class="line">			res++;</span><br><span class="line">			cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 进月</span></span><br><span class="line">		<span class="keyword">if</span>(++day&gt;months[month]) &#123;</span><br><span class="line">			day=<span class="number">1</span>;</span><br><span class="line">			month++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>普通平衡树</title>
    <url>/2024/11/08/%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="splay-普通平衡树">Splay-普通平衡树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li>
<li><a href="#2-%E6%97%8B%E8%BD%AC-rotate">2. 旋转 rotate</a></li>
<li><a href="#3-%E4%BC%B8%E5%B1%95-splay">3. 伸展 splay</a></li>
<li><a href="#4-%E6%9F%A5%E6%89%BE-find">4. 查找 find</a></li>
<li><a href="#5-%E5%89%8D%E9%A9%B1-get_pre">5. 前驱 get_pre</a></li>
<li><a href="#6-%E5%90%8E%E7%BB%A7-get_suc">6. 后继 get_suc</a></li>
<li><a href="#7-%E5%88%A0%E9%99%A4-del">7. 删除 del</a></li>
<li><a href="#8-%E6%8F%92%E5%85%A5-insert">8. 插入 insert</a></li>
<li><a href="#9-%E6%8E%92%E5%90%8D-get_rank">9. 排名 get_rank</a></li>
<li><a href="#10-%E5%8F%96%E5%80%BC-get_val">10. 取值 get_val</a></li>
<li><a href="#11-%E4%BE%8B%E9%A2%98">11. 例题</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>二叉查找树(Binary Search Tree, BST)是一种能存储特定数据类型的容器。二叉查找树允许快速查找、插入或者删除某一个节点。重要性质：左小右大，中序遍历是有序的。</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240215072453341.png" alt="image-20240215072453341" style="zoom:80%;">

<ul>
<li>Splay（伸展树）是一种平衡二叉树，通过不断将某个节点旋转到根节点，使得整棵树仍然满足BST的性质，并且保持平衡而不至于退化为链。</li>
</ul>
<h2><span id="1-数据结构">1. 数据结构</span></h2><h2><span id="2-旋转-rotate">2. 旋转 rotate</span></h2><ul>
<li>旋转分为右旋和左旋，如下图中将x旋转上升到y的位置，右旋即沿顺时针方向旋转，x、y的父子关系发生改变，同时因为a、b本身是x的孩子，所以b旋转后变成y的孙子，a还是x的孩子。</li>
<li>特点：右旋，把x的右孩子给y；左旋，把x的左孩子给y。</li>
<li>左旋和右旋后，信息是保序且正确的，即中序遍历得到的结果是相同的。</li>
<li>pushup函数用于自下往上传递每个节点维护的子树大小。</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240215072739091.png" alt="image-20240215072739091" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从自下往上push,由子节点的信息算出父节点的信息</span></span><br><span class="line"><span class="comment">// 因为旋转后x/y两个节点对应的子树大小有所改变,所以需要更新</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 左孩子size+右孩子size+该点可能插入多次的cnt值</span></span><br><span class="line">	tr[x].size=tr[tr[x].s[<span class="number">0</span>]].size+tr[tr[x].s[<span class="number">1</span>]].size+tr[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate函数把左旋和右旋归纳到一起了,所以操纵的时候用tr[y].s[k]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> y=tr[x].p,z=tr[y].p; <span class="comment">// 取出x的父节点y以及父节点的父节点z</span></span><br><span class="line">	<span class="type">int</span> k=tr[y].s[<span class="number">1</span>]==x; <span class="comment">// 如果x是y的右儿子,那么k取1,k的值决定左旋还是右旋,k=0左旋,=1右旋</span></span><br><span class="line">	<span class="comment">// 下面两行在处理旋转后x的孩子和y的树边	</span></span><br><span class="line">	<span class="comment">// 注意,0^1=1,1^0=0,所以选择异或操作</span></span><br><span class="line">	tr[y].s[k]=tr[x].s[k^<span class="number">1</span>]; <span class="comment">// y节点的左/右(看k为多少)孩子变为x的右/左孩子,x把孩子送走,变成孙子节点</span></span><br><span class="line">	tr[tr[x].s[k^<span class="number">1</span>]].p=y; <span class="comment">// 树边是双向的,再把x的孩子的父亲变成y</span></span><br><span class="line">	<span class="comment">// 下面两行在处理旋转后x/y的树边</span></span><br><span class="line">	tr[x].s[k^<span class="number">1</span>]=y;</span><br><span class="line">	tr[y].p=x;</span><br><span class="line">	<span class="comment">// 下面两行在处理旋转后x/z的树边</span></span><br><span class="line">	tr[z].s[tr[z].s[<span class="number">1</span>]==y]=x;</span><br><span class="line">	tr[x].p=z;</span><br><span class="line">	<span class="comment">// 其他边是不受影响的</span></span><br><span class="line">	<span class="built_in">pushup</span>(y),<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-伸展-splay">3. 伸展 splay</span></h2><ul>
<li>平衡树的核心操作，每访问一个节点x，就把x旋转到根节点，有三种情况</li>
<li>对于双旋操作注意，直线型第一次转中间的y，第二次转底下的x；折线形第一次转底下的x，第二次也转x，故有直转中，折转底</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240215075040613.png" alt="image-20240215075040613" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把x旋转到k的下面,即x要当k的儿子</span></span><br><span class="line"><span class="comment">// k&gt;0时,把x转到k的下面</span></span><br><span class="line"><span class="comment">// k=0时,把x转到根</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当x的父亲等于k的时候结束</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].p!=k) &#123;</span><br><span class="line">		<span class="type">int</span> y=tr[x].p,z=tr[y].p; <span class="comment">// 取出x的父节点y和父节点的父节点z</span></span><br><span class="line">		<span class="comment">// z!=k,说明y不是根,做双旋</span></span><br><span class="line">		<span class="comment">// 折线形转底,直线型转中,可以看图例</span></span><br><span class="line">		<span class="keyword">if</span>(z!=k) </span><br><span class="line">			<span class="comment">// 如果都做左孩子/右孩子,说明直线型,旋转底下的x</span></span><br><span class="line">			<span class="comment">// 如果一个左一个右,形成折线形,旋转中间的y</span></span><br><span class="line">			(tr[y].s[<span class="number">0</span>]==x)^(tr[z].s[<span class="number">0</span>]==y) ? <span class="built_in">rotate</span>(x) : <span class="built_in">rotate</span>(y);	</span><br><span class="line">		<span class="built_in">rotate</span>(x); <span class="comment">// z!=k,则最后还要旋转x;z==k,本来也要旋转x</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k=0是一个不存在的节点,即根节点的父节点,所以相当于把x转到根,最后更新一下根节点</span></span><br><span class="line">	<span class="comment">// 因为所有操作都是基于根节点进行的,所以对根节点进行更新</span></span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) root=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-查找-find">4. 查找 find</span></h2><ul>
<li>直接看注释吧</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找,找到v(v是权值)所在节点,并把该节点转到根</span></span><br><span class="line"><span class="comment">// 如果找不到这个值,是把与这个点最接近的点转到根上去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root; <span class="comment">// 取根节点</span></span><br><span class="line">	<span class="comment">// 要么x的哪个儿子为空了(走到空节点上了),要么找的v的值已经等于x的值了,退出循环</span></span><br><span class="line">	<span class="comment">// 这个while循环是从根节点去找v这个值,如果大于他,走左子树找较小值/如果小于他,走右子树找较大值</span></span><br><span class="line">	<span class="comment">// 如果找不到这个值,是把与这个点最接近的点转到根上去</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].s[v&gt;tr[x].v]&amp;&amp;v!=tr[x].v)</span><br><span class="line">		x=tr[x].s[v&gt;tr[x].v];</span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-前驱-get_pre">5. 前驱 get_pre</span></h2><ul>
<li>直接看注释吧</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求前驱,求v的前驱,v是权值嗷,返回其节点编号</span></span><br><span class="line"><span class="comment">// 如果v在树中是不存在的,那么根据上面的find函数,我们能够成功返回一个最靠近这个不存在的v的前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_pre</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(v); <span class="comment">// 先找到这个点,转到根上去,如果不存在,找到的是略大于v的不存在的点</span></span><br><span class="line">	<span class="type">int</span> x=root;</span><br><span class="line">	<span class="comment">// 此时v已经旋转到根节点了,如果v比根节点大,那么前驱就是x</span></span><br><span class="line">	<span class="keyword">if</span>(tr[x].v&lt;v) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="comment">// 否则,去左子树上找</span></span><br><span class="line">	x=tr[x].s[<span class="number">0</span>]; <span class="comment">// 找前驱嘛,比它小且最近的那肯定在左子树上啊</span></span><br><span class="line">	<span class="comment">// 左子树上最大最靠近我们要找的前驱的值肯定在右子树上,所以沿着右子树走</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].s[<span class="number">1</span>]) x=tr[x].s[<span class="number">1</span>]; </span><br><span class="line">	<span class="comment">// 查完前驱后也旋转一次</span></span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="6-后继-get_suc">6. 后继 get_suc</span></h2><ul>
<li>直接看注释吧</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找后继</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_suc</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(v);</span><br><span class="line">	<span class="type">int</span> x=root;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].v&gt;v) <span class="keyword">return</span> x;</span><br><span class="line">	x=tr[x].s[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(tr[x].s[<span class="number">0</span>]) x=tr[x].s[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 查完后继后旋转</span></span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="7-删除-del">7. 删除 del</span></h2><ul>
<li>删除的时候用到一个技巧，比如6、8、9中欲删除8，6是8是前驱，9是8的后继，可以先找到前驱和后继再把8夹住，这样8变成叶子节点，就方便直接删除</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240215082014315.png" alt="image-20240215082014315" style="zoom:80%;">

<ul>
<li>直接看注释吧</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除(若有多个相同的数,只删除一个)</span></span><br><span class="line"><span class="comment">// 要删除一个节点找边的关系实在过于麻烦不好找,因此我们选择把前驱转到根节点</span></span><br><span class="line"><span class="comment">// 再把后继转到根节点的下面,此时要删的这个点就被夹击了,那么它只能作为叶子节点</span></span><br><span class="line"><span class="comment">// 作为叶子节点就好切割了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找前驱和后继的编号</span></span><br><span class="line">	<span class="type">int</span> pre=<span class="built_in">get_pre</span>(v);</span><br><span class="line">	<span class="type">int</span> suc=<span class="built_in">get_suc</span>(v);</span><br><span class="line">	<span class="comment">// 前驱转到根,后继到前驱的下边</span></span><br><span class="line">	<span class="built_in">splay</span>(pre,<span class="number">0</span>),<span class="built_in">splay</span>(suc,pre);</span><br><span class="line">	<span class="comment">// 这样就获取到了要删除的节点的编号</span></span><br><span class="line">	<span class="type">int</span> del=tr[suc].s[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 如果个数大于1,那么删除一个,再把del转到根,这样的目的是splay触发rotate,rotate触发pushup更新大小等</span></span><br><span class="line">	<span class="keyword">if</span>(tr[del].cnt&gt;<span class="number">1</span>)</span><br><span class="line">		tr[del].cnt--, <span class="built_in">splay</span>(del,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 如果恰好只有一个,直接把这个点清空(即切断叶子节点),把叶子节点以上的节点更新一下,所以splay(suc,0)</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tr[suc].s[<span class="number">0</span>]=<span class="number">0</span>, <span class="built_in">splay</span>(suc,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="8-插入-insert">8. 插入 insert</span></h2><ul>
<li>注意要通过insert来插入哨兵，保证最小值有前驱，最大值有后继，这样每个节点都可以看作独立且统一的了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入函数,可用于初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root, p=<span class="number">0</span>; <span class="comment">// 从跟上走,p记录其父节点</span></span><br><span class="line">	<span class="comment">// 要么x==0(走到空间点)或者已经找到这个值(重复插入多次时)</span></span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;tr[x].v!=v)</span><br><span class="line">		p=x,x=tr[x].s[v&gt;tr[x].v]; <span class="comment">// v&gt;tr[x].v走右子树,否则走左子树</span></span><br><span class="line">	<span class="keyword">if</span>(x) tr[x].cnt++; <span class="comment">// x!=0,则个数+1</span></span><br><span class="line">	<span class="comment">// 否则x是一个空节点,那么初始化一下再插入到这个树中,就是说这个点没有出现过</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		x=++idx; <span class="comment">// 给x一个新的编号</span></span><br><span class="line">		tr[p].s[v&gt;tr[p].v]=x; <span class="comment">// 建边关系</span></span><br><span class="line">		tr[x].<span class="built_in">init</span>(p,v); <span class="comment">// 更新节点信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>); <span class="comment">// 转一下,改善平衡性的同时用pushup更新大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="9-排名-get_rank">9. 排名 get_rank</span></h2><ul>
<li>直接看注释吧</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排名,查询v数的排名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rank</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 注释掉的代码改成下面的,因为有可能v这个数值是不存在的,所以先插入再删除</span></span><br><span class="line"><span class="comment">//	find(v); // v找到,转到根上去,返回左子树的大小就是排名(在中序遍历中)</span></span><br><span class="line"><span class="comment">//	return tr[tr[root].s[0]].size; // 为什么不加1?因为有哨兵,极大值和极小值</span></span><br><span class="line">	<span class="built_in">insert</span>(v);</span><br><span class="line">	<span class="type">int</span> res=tr[tr[root].s[<span class="number">0</span>]].size;</span><br><span class="line">	<span class="built_in">del</span>(v);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="10-取值-get_val">10. 取值 get_val</span></h2><ul>
<li>直接看注释吧</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取数值,查询排名为k的数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root; <span class="comment">// 取根</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> y=tr[x].s[<span class="number">0</span>]; <span class="comment">// 取左孩子</span></span><br><span class="line">		<span class="comment">// 如果左子树加上根的总大小小于k,说明k很大,应该在右子树上找,否则在左子树上找</span></span><br><span class="line">		<span class="keyword">if</span>(tr[y].size+tr[x].cnt&lt;k) &#123;</span><br><span class="line">			k-=tr[y].size+tr[x].cnt; <span class="comment">// 减去左子树大小加上根节点.cnt,求出旋转后正确的k值</span></span><br><span class="line">			x=tr[x].s[<span class="number">1</span>]; <span class="comment">// x走到右儿子上去</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// 如果tr[y].size&gt;=k了就往左子树上走</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tr[y].size&gt;=k) x=y;	</span><br><span class="line">		<span class="comment">// 既不往左子树上走,也不往根子树上找,说明已经找到这个点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每找一个树转一下</span></span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> tr[x].v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="11-例题">11. 例题</span></h2><blockquote>
<p>洛谷：P3369 【模板】普通平衡树</p>
</blockquote>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240215091357163.png" alt="image-20240215091357163" style="zoom:80%;">

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240215091405693.png" alt="image-20240215091405693" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> s[<span class="number">2</span>]; <span class="comment">// 存左右儿子,s[0]:左孩子,s[1]:右孩子</span></span><br><span class="line">	<span class="type">int</span> p; <span class="comment">// 父节点</span></span><br><span class="line">	<span class="type">int</span> v; <span class="comment">// 该节点权值</span></span><br><span class="line">	<span class="type">int</span> cnt; <span class="comment">// 权值出现的次数,cnt=1,这个树只出现过一次,cnt&gt;=1,出现过多次</span></span><br><span class="line">	<span class="type">int</span> size; <span class="comment">// 子树大小</span></span><br><span class="line">	<span class="comment">// 初始化,每插入一个节点对其初始化信息</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p1,<span class="type">int</span> v1)</span> </span>&#123;</span><br><span class="line">		p=p1,v=v1;</span><br><span class="line">		cnt=size=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> root; <span class="comment">// 根节点编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树遍历因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从自下往上push,由子节点的信息算出父节点的信息</span></span><br><span class="line"><span class="comment">// 因为旋转后x/y两个节点对应的子树大小有所改变,所以需要更新</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 左孩子size+右孩子size+该点可能插入多次的cnt值</span></span><br><span class="line">	tr[x].size=tr[tr[x].s[<span class="number">0</span>]].size+tr[tr[x].s[<span class="number">1</span>]].size+tr[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rotate函数把左旋和右旋归纳到一起了,所以操纵的时候用tr[y].s[k]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> y=tr[x].p,z=tr[y].p; <span class="comment">// 取出x的父节点y以及父节点的父节点z</span></span><br><span class="line">	<span class="type">int</span> k=tr[y].s[<span class="number">1</span>]==x; <span class="comment">// 如果x是y的右儿子,那么k取1,k的值决定左旋还是右旋,k=0左旋,=1右旋</span></span><br><span class="line">	<span class="comment">// 下面两行在处理旋转后x的孩子和y的树边	</span></span><br><span class="line">	<span class="comment">// 注意,0^1=1,1^0=0,所以选择异或操作</span></span><br><span class="line">	tr[y].s[k]=tr[x].s[k^<span class="number">1</span>]; <span class="comment">// y节点的左/右(看k为多少)孩子变为x的右/左孩子,x把孩子送走,变成孙子节点</span></span><br><span class="line">	tr[tr[x].s[k^<span class="number">1</span>]].p=y; <span class="comment">// 树边是双向的,再把x的孩子的父亲变成y</span></span><br><span class="line">	<span class="comment">// 下面两行在处理旋转后x/y的树边</span></span><br><span class="line">	tr[x].s[k^<span class="number">1</span>]=y;</span><br><span class="line">	tr[y].p=x;</span><br><span class="line">	<span class="comment">// 下面两行在处理旋转后x/z的树边</span></span><br><span class="line">	tr[z].s[tr[z].s[<span class="number">1</span>]==y]=x;</span><br><span class="line">	tr[x].p=z;</span><br><span class="line">	<span class="comment">// 其他边是不受影响的</span></span><br><span class="line">	<span class="built_in">pushup</span>(y),<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把x旋转到k的下面,即x要当k的儿子</span></span><br><span class="line"><span class="comment">// k&gt;0时,把x转到k的下面</span></span><br><span class="line"><span class="comment">// k=0时,把x转到根</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当x的父亲等于k的时候结束</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].p!=k) &#123;</span><br><span class="line">		<span class="type">int</span> y=tr[x].p,z=tr[y].p; <span class="comment">// 取出x的父节点y和父节点的父节点z</span></span><br><span class="line">		<span class="comment">// z!=k,说明y不是根,做双旋</span></span><br><span class="line">		<span class="comment">// 折线形转底,直线型转中,可以看图例</span></span><br><span class="line">		<span class="keyword">if</span>(z!=k) </span><br><span class="line">			<span class="comment">// 如果都做左孩子/右孩子,说明直线型,旋转底下的x</span></span><br><span class="line">			<span class="comment">// 如果一个左一个右,形成折线形,旋转中间的y</span></span><br><span class="line">			(tr[y].s[<span class="number">0</span>]==x)^(tr[z].s[<span class="number">0</span>]==y) ? <span class="built_in">rotate</span>(x) : <span class="built_in">rotate</span>(y);	</span><br><span class="line">		<span class="built_in">rotate</span>(x); <span class="comment">// z!=k,则最后还要旋转x;z==k,本来也要旋转x</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// k=0是一个不存在的节点,即根节点的父节点,所以相当于把x转到根,最后更新一下根节点</span></span><br><span class="line">	<span class="comment">// 因为所有操作都是基于根节点进行的,所以对根节点进行更新</span></span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) root=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找,找到v(v是权值)所在节点,并把该节点转到根</span></span><br><span class="line"><span class="comment">// 如果找不到这个值,是把与这个点最接近的点转到根上去</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root; <span class="comment">// 取根节点</span></span><br><span class="line">	<span class="comment">// 要么x的哪个儿子为空了(走到空节点上了),要么找的v的值已经等于x的值了,退出循环</span></span><br><span class="line">	<span class="comment">// 这个while循环是从根节点去找v这个值,如果大于他,走左子树找较小值/如果小于他,走右子树找较大值</span></span><br><span class="line">	<span class="comment">// 如果找不到这个值,是把与这个点最接近的点转到根上去</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].s[v&gt;tr[x].v]&amp;&amp;v!=tr[x].v)</span><br><span class="line">		x=tr[x].s[v&gt;tr[x].v];</span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求前驱,求v的前驱,v是权值嗷,返回其节点编号</span></span><br><span class="line"><span class="comment">// 如果v在树中是不存在的,那么根据上面的find函数,我们能够成功返回一个最靠近这个不存在的v的前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_pre</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(v); <span class="comment">// 先找到这个点,转到根上去,如果不存在,找到的是略大于v的不存在的点</span></span><br><span class="line">	<span class="type">int</span> x=root;</span><br><span class="line">	<span class="comment">// 此时v已经旋转到根节点了,如果v比根节点大,那么前驱就是x</span></span><br><span class="line">	<span class="keyword">if</span>(tr[x].v&lt;v) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="comment">// 否则,去左子树上找</span></span><br><span class="line">	x=tr[x].s[<span class="number">0</span>]; <span class="comment">// 找前驱嘛,比它小且最近的那肯定在左子树上啊</span></span><br><span class="line">	<span class="comment">// 左子树上最大最靠近我们要找的前驱的值肯定在右子树上,所以沿着右子树走</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].s[<span class="number">1</span>]) x=tr[x].s[<span class="number">1</span>]; </span><br><span class="line">	<span class="comment">// 查完前驱后也旋转一次</span></span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找后继</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_suc</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(v);</span><br><span class="line">	<span class="type">int</span> x=root;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].v&gt;v) <span class="keyword">return</span> x;</span><br><span class="line">	x=tr[x].s[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(tr[x].s[<span class="number">0</span>]) x=tr[x].s[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 查完后继后旋转</span></span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除(若有多个相同的数,只删除一个)</span></span><br><span class="line"><span class="comment">// 要删除一个节点找边的关系实在过于麻烦不好找,因此我们选择把前驱转到根节点</span></span><br><span class="line"><span class="comment">// 再把后继转到根节点的下面,此时要删的这个点就被夹击了,那么它只能作为叶子节点</span></span><br><span class="line"><span class="comment">// 作为叶子节点就好切割了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找前驱和后继的编号</span></span><br><span class="line">	<span class="type">int</span> pre=<span class="built_in">get_pre</span>(v);</span><br><span class="line">	<span class="type">int</span> suc=<span class="built_in">get_suc</span>(v);</span><br><span class="line">	<span class="comment">// 前驱转到根,后继到前驱的下边</span></span><br><span class="line">	<span class="built_in">splay</span>(pre,<span class="number">0</span>),<span class="built_in">splay</span>(suc,pre);</span><br><span class="line">	<span class="comment">// 这样就获取到了要删除的节点的编号</span></span><br><span class="line">	<span class="type">int</span> del=tr[suc].s[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 如果个数大于1,那么删除一个,再把del转到根,这样的目的是splay触发rotate,rotate触发pushup更新大小等</span></span><br><span class="line">	<span class="keyword">if</span>(tr[del].cnt&gt;<span class="number">1</span>)</span><br><span class="line">		tr[del].cnt--, <span class="built_in">splay</span>(del,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 如果恰好只有一个,直接把这个点清空(即切断叶子节点),把叶子节点以上的节点更新一下,所以splay(suc,0)</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tr[suc].s[<span class="number">0</span>]=<span class="number">0</span>, <span class="built_in">splay</span>(suc,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入函数,可用于初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root, p=<span class="number">0</span>; <span class="comment">// 从跟上走,p记录其父节点</span></span><br><span class="line">	<span class="comment">// 要么x==0(走到空间点)或者已经找到这个值(重复插入多次时)</span></span><br><span class="line">	<span class="keyword">while</span>(x&amp;&amp;tr[x].v!=v)</span><br><span class="line">		p=x,x=tr[x].s[v&gt;tr[x].v]; <span class="comment">// v&gt;tr[x].v走右子树,否则走左子树</span></span><br><span class="line">	<span class="keyword">if</span>(x) tr[x].cnt++; <span class="comment">// x!=0,则个数+1</span></span><br><span class="line">	<span class="comment">// 否则x是一个空节点,那么初始化一下再插入到这个树中,就是说这个点没有出现过</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		x=++idx; <span class="comment">// 给x一个新的编号</span></span><br><span class="line">		tr[p].s[v&gt;tr[p].v]=x; <span class="comment">// 建边关系</span></span><br><span class="line">		tr[x].<span class="built_in">init</span>(p,v); <span class="comment">// 更新节点信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>); <span class="comment">// 转一下,改善平衡性的同时用pushup更新大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排名,查询v数的排名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rank</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 注释掉的代码改成下面的,因为有可能v这个数值是不存在的,所以先插入再删除</span></span><br><span class="line"><span class="comment">//	find(v); // v找到,转到根上去,返回左子树的大小就是排名(在中序遍历中)</span></span><br><span class="line"><span class="comment">//	return tr[tr[root].s[0]].size; // 为什么不加1?因为有哨兵,极大值和极小值</span></span><br><span class="line">	<span class="built_in">insert</span>(v);</span><br><span class="line">	<span class="type">int</span> res=tr[tr[root].s[<span class="number">0</span>]].size;</span><br><span class="line">	<span class="built_in">del</span>(v);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数值,查询排名为k的数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x=root; <span class="comment">// 取根</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> y=tr[x].s[<span class="number">0</span>]; <span class="comment">// 取左孩子</span></span><br><span class="line">		<span class="comment">// 如果左子树加上根的总大小小于k,说明k很大,应该在右子树上找,否则在左子树上找</span></span><br><span class="line">		<span class="keyword">if</span>(tr[y].size+tr[x].cnt&lt;k) &#123;</span><br><span class="line">			k-=tr[y].size+tr[x].cnt; <span class="comment">// 减去左子树大小加上根节点.cnt,求出旋转后正确的k值</span></span><br><span class="line">			x=tr[x].s[<span class="number">1</span>]; <span class="comment">// x走到右儿子上去</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// 如果tr[y].size&gt;=k了就往左子树上走</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tr[y].size&gt;=k) x=y;	</span><br><span class="line">		<span class="comment">// 既不往左子树上走,也不往根子树上找,说明已经找到这个点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每找一个树转一下</span></span><br><span class="line">	<span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> tr[x].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">insert</span>(<span class="number">-1e9</span>);<span class="built_in">insert</span>(<span class="number">1e9</span>); <span class="comment">// 插入哨兵</span></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> op,x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">del</span>(x);</span><br><span class="line">		<span class="comment">// 对于操作356不保证当前数据结构中存在数x</span></span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_rank</span>(x));</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get_val</span>(x<span class="number">+1</span>)); <span class="comment">// 因为哨兵中有极小值,所以+1</span></span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="built_in">get_pre</span>(x)].v);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="built_in">get_suc</span>(x)].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1 106465</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">1 317721</span></span><br><span class="line"><span class="comment">1 460929</span></span><br><span class="line"><span class="comment">1 644985</span></span><br><span class="line"><span class="comment">1 84185</span></span><br><span class="line"><span class="comment">1 89851</span></span><br><span class="line"><span class="comment">6 81968</span></span><br><span class="line"><span class="comment">1 492737</span></span><br><span class="line"><span class="comment">5 493598</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">106465</span></span><br><span class="line"><span class="comment">84185</span></span><br><span class="line"><span class="comment">492737</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>树</tag>
        <tag>高级数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2024/10/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="最小生成树">最小生成树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9C%B4%E7%B4%A0prim%E7%AE%97%E6%B3%95">1. 朴素Prim算法</a></li>
<li><a href="#2-kruskal%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96">2. Kruskal算法+并查集优化</a></li>
<li><a href="#3-kruskal%E5%BB%B6%E7%94%B3%E5%AF%B9%E8%BE%93%E5%87%BA%E6%8E%92%E5%BA%8F">3. Kruskal延申：对输出排序</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>以下模板能使用的前提是：不存在负权环</li>
</ul>
<h2><span id="1-朴素prim算法">1. 朴素Prim算法</span></h2><blockquote>
<p>时间复杂度：$O(n^2)$，适合稠密图，边数接近点数的平方</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素Prim,和dijkstra非常相似</span></span><br><span class="line"><span class="comment">// 1.dist数组初始化为不可达</span></span><br><span class="line"><span class="comment">// 2.遍历每个点,找到集合外距离最近的点</span></span><br><span class="line"><span class="comment">// 3.用t更新其他点到集合的距离</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>; <span class="comment">// 无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储各结点到生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 访问状态</span></span><br><span class="line"><span class="type">int</span> pre[N]; <span class="comment">// 节点的前驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 最终结果</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 从1号点开始生成</span></span><br><span class="line">	<span class="comment">// 对于每个点都遍历一遍</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="comment">// t是距离点集最近的点</span></span><br><span class="line">		<span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// 从点1~n中去找t</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="comment">// 如果j未被访问并且t是第一次更新,并且从t到源点距离比从j到源点距离更近</span></span><br><span class="line">			<span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">				t=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是孤立点,直接退出,无法构成最小生成树</span></span><br><span class="line">		<span class="keyword">if</span>(i &amp;&amp; dist[t]==<span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 先更新,再累加,防止把自环加进来</span></span><br><span class="line">		<span class="comment">// 状态更新</span></span><br><span class="line">		st[t]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 求和距离</span></span><br><span class="line">		res+=dist[t];</span><br><span class="line">		<span class="comment">// 更新dist[j]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dist[j]=min(dist[j],g[t][j]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果要输出边</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=n;j++) &#123;</span></span><br><span class="line"><span class="comment">//			if(dist[j]&gt;g[t][j]&amp;&amp;!st[j]) &#123;</span></span><br><span class="line"><span class="comment">//				dist[j]=g[t][j];</span></span><br><span class="line"><span class="comment">//				pre[j]=t; // 距离变短,前驱变为t</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;pre[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=g[b][a]=min(g[a][b],c); <span class="comment">// 去重边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=prim();</span><br><span class="line">	<span class="keyword">if</span>(t==INF)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//	getPath();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-kruskal算法并查集优化">2. Kruskal算法+并查集优化</span></h2><blockquote>
<p>时间复杂度：$O(mlog^n)$，适合稀疏图，以下模板能解决重边、自环、负权边<br>题目链接：<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2</span>*(<span class="number">2e5</span>+<span class="number">5</span>); <span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点/终点/权值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Edge a,Edge b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// p[i]:顶点i的连通分量</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集查询连通分量,带路径压缩</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> p[x]=find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 加入图的边数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="comment">// 取出每条边中的信息</span></span><br><span class="line">		<span class="type">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].val;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果a和b已经相连则跳过</span></span><br><span class="line">		<span class="comment">// 1.如果是自环-&gt;(3,3)=5</span></span><br><span class="line">		<span class="comment">// 2.如果是重边-&gt;(1,2)=3,(2,1)=5,此时取小边(因为排过序了)</span></span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b)) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出这条边</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;a&lt;&lt;&quot;--&quot;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 选择这条边后的信息维护 </span></span><br><span class="line">		p[find(a)]=find(b); <span class="comment">// 连通两个并查集</span></span><br><span class="line">		ans+=w; <span class="comment">// 答案累加这条边的权值</span></span><br><span class="line">		cnt++; <span class="comment">// 边数+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 联通</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 并查集初始化:连通分量为自身</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		p[i]=i; 	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输入每条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="comment">//		scanf(&quot;%d%d%d&quot;,&amp;edges[i].a,&amp;edges[i].b,&amp;edges[i].val);</span></span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		edges[i]=&#123;a,b,c&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">if</span>(kruskal()) <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-kruskal延申对输出排序">3. Kruskal延申：对输出排序</span></h2><blockquote>
<p>将数组改成 $vector$，为结构体提供无参构造器和全参构造器 $m$，例题：信奥一本通 $p1348$，以下模板能解决重边、自环、负权边。<br>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1348">  信息学奥赛一本通（C++版）</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e5</span><span class="number">+5</span>; <span class="comment">// 最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点/终点/边权</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	ll val;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> aa,<span class="type">int</span> bb,<span class="type">int</span> cc) &#123;</span><br><span class="line">		a=aa;</span><br><span class="line">		b=bb;</span><br><span class="line">		val=cc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">// 记录父节点</span></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges,tree; <span class="comment">// 存储所有边和生成树的边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边权越小越靠前</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_edges</span><span class="params">(Edge a,Edge b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对生成树的边二次排序,编号小的靠前</span></span><br><span class="line"><span class="comment">// 起始点相同,终点小的靠前;否则起始点小的靠前</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_trees</span><span class="params">(Edge x,Edge y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.a==y.a) <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询根节点带路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 已加入图的边</span></span><br><span class="line">	<span class="keyword">for</span>(Edge e:edges) &#123;</span><br><span class="line">		<span class="comment">// 提取边的信息</span></span><br><span class="line">		<span class="type">int</span> a=e.a, b=e.b, w=e.val;</span><br><span class="line">		<span class="type">int</span> v1=<span class="built_in">find</span>(a);</span><br><span class="line">		<span class="type">int</span> v2=<span class="built_in">find</span>(b);</span><br><span class="line">		<span class="comment">// 若a,b已相连</span></span><br><span class="line">		<span class="keyword">if</span>(v1==v2) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 选中这条边</span></span><br><span class="line">		cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		ans+=w;</span><br><span class="line">		fa[v1]=v2; <span class="comment">// 联通并查集</span></span><br><span class="line">		cnt++;</span><br><span class="line">		tree.<span class="built_in">push_back</span>(e); <span class="comment">// 添加到生成树边集中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 优化输入输出</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 初始化并查集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		fa[i]=i;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="comment">// 强行让小的编号在前,大的编号在后</span></span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(a,b,c));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),cmp_edges);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">kruskal</span>()) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 对生成树中的边再排序</span></span><br><span class="line">	<span class="built_in">sort</span>(tree.<span class="built_in">begin</span>(),tree.<span class="built_in">end</span>(),cmp_trees);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> e:tree) &#123;</span><br><span class="line">		cout&lt;&lt;e.a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;e.b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;e.val&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先</title>
    <url>/2024/11/08/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="lca-最近公共祖先">LCA-最近公共祖先</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95">1. 倍增算法</a><ul>
<li><a href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.1. 数据结构</a></li>
<li><a href="#12-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B">1.2. 算法过程</a></li>
<li><a href="#13-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">1.3. 完整代码</a></li>
</ul>
</li>
<li><a href="#2-tarjan%E7%AE%97%E6%B3%95">2. Tarjan算法</a><ul>
<li><a href="#21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.1. 数据结构</a></li>
<li><a href="#22-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B">2.2. 算法过程</a></li>
<li><a href="#23-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">2.3. 完整代码</a></li>
</ul>
</li>
<li><a href="#3-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94">3. 算法对比</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>两个节点的最近公共祖先 $(Lowest Common Ancestor,LCA)$ 就是这两个点的公共祖先里面，离他们最近的那个</li>
</ul>
<h2><span id="1-倍增算法">1. 倍增算法</span></h2><h3><span id="11-数据结构">1.1. 数据结构</span></h3><ul>
<li>$dep[u]$：存储节点$u$的深度</li>
<li>$fa[u][i]$：存储从节点$u$向上跳$2^i$层的祖先节点，$i&#x3D;0,1,2,3···$，例如，节点$9$向上跳$2^0$层的祖先是3，跳$2^1$层祖先是6，跳$2^2$层祖先是1，跳$2^3$层祖先是0（哨兵）</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240214111156105.png" alt="image-20240214111156105"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>; <span class="comment">// 节点总数</span></span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// 对所有节点开一个邻接表</span></span><br><span class="line"><span class="type">int</span> dep[N],fa[N][<span class="number">20</span>]; <span class="comment">// dep[i]:节点i的深度,fa[i][20]:存储每个节点的祖先</span></span><br><span class="line"><span class="comment">// 注意,因为2^20大概等于1e6左右,是大于MAXN的,所以层数最大开20即可</span></span><br></pre></td></tr></table></figure>



<h3><span id="12-算法过程">1.2. 算法过程</span></h3><blockquote>
<p>总时间复杂度$O((n+m)log^n)$，$n,m$分别是节点总数和查询次数</p>
</blockquote>
<ul>
<li>$dfs$一遍，创建$ST$表，倍增递推，$fa[u][i]&#x3D;fa[fa[u][i-1]][i-1]$，即从节点$u$跳到$2^i$层，分两步跳，每步跳$2^{i-1}$层，第一步跳到$fa[u][i-1]$，那么第二步跳到$fa[fa[u][i-1]][i-1]$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240214111903418.png" alt="image-20240214111903418"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs建st表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span> </span>&#123;</span><br><span class="line">	dep[u]=dep[father]<span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 向上跳1,2,4,...步的祖先节点</span></span><br><span class="line">	fa[u][<span class="number">0</span>]=father; <span class="comment">// 向上跳一步得到父节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++) </span><br><span class="line">		fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]; <span class="comment">// 向上跳最大深度</span></span><br><span class="line">	<span class="comment">// 对儿子节点继续dfs建表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:e[u]) </span><br><span class="line">		<span class="comment">// 判断是不是父节点,避免往上走</span></span><br><span class="line">		<span class="keyword">if</span>(v!=father) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用ST表建LCA<ul>
<li>(1) 第一阶段，将u,v<strong>跳到同一层</strong>，设u,v两点的深度之差为y，将y进行二进制拆分，可以将y次游标跳跃优化为”<strong>y的二进制表示所含1的个数</strong>“次游标跳跃，一定能跳到同一层。例如，y&#x3D;1019(0..01111111011)&#x3D;512+256+…+8+2+1，不越界则跳，共跳9次到达。</li>
<li>(2) 第二阶段，将u,v<strong>一起跳到LCA的下一层</strong>从最大的ⅰ开始循环尝试，一直尝试到0，最后游标u,v一定能停在LCA的下一层。例如，y&#x3D;1019(0..01111111011)两游标会跳512+256+…+8+2&#x3D;1018层，共跳8次到达LCA的下一层。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据st找LCA</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 保证u的深度&gt;=v的深度,便于代码书写统一</span></span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v); </span><br><span class="line">	<span class="comment">// 先让u,v跳到同一层去</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])</span><br><span class="line">			u=fa[u][i];</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> v; <span class="comment">// 如果uv同层后发现u==v,说明v就是u的祖先,那么返回v</span></span><br><span class="line">	<span class="comment">// 再跳到LCA的下一层</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) </span><br><span class="line">		<span class="comment">// uv同层后一起往上跳2^i层,如果结果不同则uv递归到父节点</span></span><br><span class="line">		<span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">			u=fa[u][i],v=fa[v][i];</span><br><span class="line">	<span class="keyword">return</span> fa[u][<span class="number">0</span>]; <span class="comment">// 跳到LCA的下一层后,那么再往上跳一步就得到公共祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="13-完整代码">1.3. 完整代码</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240214122324096.png" alt="image-20240214122324096" style="zoom: 80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>; <span class="comment">// 节点总数</span></span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// 对所有节点开一个邻接表</span></span><br><span class="line"><span class="type">int</span> dep[N],fa[N][<span class="number">20</span>]; <span class="comment">// dep[i]:节点i的深度,fa[i][20]:存储每个节点的祖先</span></span><br><span class="line"><span class="comment">// 注意,因为2^20大概等于1e6左右,是大于MAXN的,所以层数最大开20即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs建st表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span> </span>&#123;</span><br><span class="line">	dep[u]=dep[father]<span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 向上跳1,2,4,...步的祖先节点</span></span><br><span class="line">	fa[u][<span class="number">0</span>]=father; <span class="comment">// 向上跳一步得到父节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++) </span><br><span class="line">		fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]; <span class="comment">// 向上跳最大深度</span></span><br><span class="line">	<span class="comment">// 对儿子节点继续dfs建表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:e[u]) </span><br><span class="line">		<span class="comment">// 判断是不是父节点,避免往上走</span></span><br><span class="line">		<span class="keyword">if</span>(v!=father) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据st找LCA</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 保证u的深度&gt;=v的深度,便于代码书写统一</span></span><br><span class="line">	<span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v); </span><br><span class="line">	<span class="comment">// 先让u,v跳到同一层去</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v])</span><br><span class="line">			u=fa[u][i];</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> v; <span class="comment">// 如果uv同层后发现u==v,说明v就是u的祖先,那么返回v</span></span><br><span class="line">	<span class="comment">// 再跳到LCA的下一层</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) </span><br><span class="line">		<span class="comment">// uv同层后一起往上跳2^i层,如果结果不同则uv递归到父节点</span></span><br><span class="line">		<span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">			u=fa[u][i],v=fa[v][i];</span><br><span class="line">	<span class="keyword">return</span> fa[u][<span class="number">0</span>]; <span class="comment">// 跳到LCA的下一层后,那么再往上跳一步就得到公共祖先</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// n:节点数,m:询问个数,s:根节点的序号</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="comment">// a,b节点之间有一条边(数据保证构成树)</span></span><br><span class="line">	<span class="comment">// 节点数为n,树有n-1条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// m次查询</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(a,b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-tarjan算法">2. Tarjan算法</span></h2><ul>
<li>Tarjan(塔扬)算法是一种离线算法，巧妙利用并查集维护祖先节点。</li>
<li>离线算法：一开始需要知道问题的所有输入数据，才能计算出结果。</li>
</ul>
<h3><span id="21-数据结构">2.1. 数据结构</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240214145136351.png" alt="image-20240214145136351" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// e[u]存树边,e[1]=5,e[5]=1</span></span><br><span class="line"><span class="comment">// N次查询,存两次,query[3]=&#123;4,1&#125;,query[4]=&#123;3,1&#125;,表示第一次查询,查的是&#123;3,4&#125;的LCA</span></span><br><span class="line">vector&lt;PII&gt; query[N]; </span><br><span class="line"><span class="comment">// fa[u]:存父节点,fa[5]=1,节点5的父节点是1</span></span><br><span class="line"><span class="comment">// vis[u]:打标记</span></span><br><span class="line"><span class="comment">// ans[i]:存储每次查询的结果</span></span><br><span class="line"><span class="type">int</span> fa[N],vis[N],ans[M];</span><br></pre></td></tr></table></figure>



<h3><span id="22-算法过程">2.2. 算法过程</span></h3><blockquote>
<p>总时间复杂度$O(m+n)$，其中n是节点个数，m是查询总次数</p>
</blockquote>
<ol>
<li>从根开始深搜遍历，入u时打标记</li>
<li>枚举u的儿子v，遍历完v的子树，回u时把v指向u</li>
<li>遍历完u的儿子们，离u时枚举以u为起点的查询，若终点V被搜过则查找v的根，即u,v的LCA，答案记入ans[]</li>
<li>递归遍历完整颗树，得到全部查询答案。</li>
</ol>
<ul>
<li>模拟过程建议听课，<a href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">D10 Tarjan算法 P3379【模板】最近公共祖先（LCA）bilibili</a>，从$10:08$起，注意路径压缩是不会影响到后面的查询的，这就是这个算法的精妙之处</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==fa[u]) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">return</span> fa[u]=<span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 塔扬算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1:入</span></span><br><span class="line">	vis[u]=<span class="literal">true</span>; <span class="comment">// 入u时标记</span></span><br><span class="line">	<span class="comment">// 枚举u的所有儿子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]) &#123;</span><br><span class="line">		<span class="comment">// 2:下,判重,保证一定往下走,防止往回搜</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			fa[v]=u; <span class="comment">// 3:回,回u时,v指向u,让儿子指向父亲,维护并查集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4:离,遍历完u的儿子之后,离u时遍历以u为起点的查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q:query[u]) &#123;</span><br><span class="line">		<span class="comment">// v:取出终点,i:第几次查询</span></span><br><span class="line">		<span class="type">int</span> v=q.x,i=q.y;</span><br><span class="line">		<span class="comment">// 如果终点被搜过,则查找v的根,即u/v的LCA,答案计入ANS</span></span><br><span class="line">		<span class="keyword">if</span>(vis[v]) ans[i]=<span class="built_in">find</span>(v); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-完整代码">2.3. 完整代码</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+5</span>,M=<span class="number">2</span>*N; <span class="comment">// 查询的边要建两次</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// e[u]存树边,e[1]=5,e[5]=1</span></span><br><span class="line"><span class="comment">// N次查询,存两次,query[3]=&#123;4,1&#125;,query[4]=&#123;3,1&#125;,表示第一次查询,查的是&#123;3,4&#125;的LCA</span></span><br><span class="line">vector&lt;PII&gt; query[N]; </span><br><span class="line"><span class="comment">// fa[u]:存父节点,fa[5]=1,节点5的父节点是1</span></span><br><span class="line"><span class="comment">// vis[u]:打标记</span></span><br><span class="line"><span class="comment">// ans[i]:存储每次查询的结果</span></span><br><span class="line"><span class="type">int</span> fa[N],vis[N],ans[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==fa[u]) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">return</span> fa[u]=<span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 塔扬算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1:入</span></span><br><span class="line">	vis[u]=<span class="literal">true</span>; <span class="comment">// 入u时标记</span></span><br><span class="line">	<span class="comment">// 枚举u的所有儿子</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]) &#123;</span><br><span class="line">		<span class="comment">// 2:下,判重,保证一定往下走,防止往回搜</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			fa[v]=u; <span class="comment">// 3:回,回u时,v指向u,让儿子指向父亲,维护并查集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4:离,遍历完u的儿子之后,离u时遍历以u为起点的查询</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q:query[u]) &#123;</span><br><span class="line">		<span class="comment">// v:取出终点,i:第几次查询</span></span><br><span class="line">		<span class="type">int</span> v=q.x,i=q.y;</span><br><span class="line">		<span class="comment">// 如果终点被搜过,则查找v的根,即u/v的LCA,答案计入ANS</span></span><br><span class="line">		<span class="keyword">if</span>(vis[v]) ans[i]=<span class="built_in">find</span>(v); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; <span class="comment">// n:节点数,m:查询数,s:根节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="comment">// 查询建边两次,因为不知道在tarjan算法中查询用哪个点</span></span><br><span class="line">		query[a].<span class="built_in">push_back</span>(&#123;b,i&#125;);</span><br><span class="line">		query[b].<span class="built_in">push_back</span>(&#123;a,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) fa[i]=i; <span class="comment">// 并查集初始化</span></span><br><span class="line">	<span class="built_in">tarjan</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-算法对比">3. 算法对比</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240214150921613.png" alt="image-20240214150921613" style="zoom:80%;">
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>高级数据结构</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2024/11/07/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="树形dp">树形DP</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83">1. 树的重心</a></li>
<li><a href="#2-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">2. 树的直径</a></li>
<li><a href="#3-%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BF%83">3. 树的中心</a><ul>
<li><a href="#31-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B7%B1%E6%90%9C-dfs_ddown">3.1. 第一次深搜 dfs_d（down）</a></li>
<li><a href="#32-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%B7%B1%E6%90%9C-dfs_uup">3.2. 第二次深搜 dfs_u（up）</a></li>
</ul>
</li>
<li><a href="#4-%E4%BE%8B%E9%A2%98">4. 例题</a><ul>
<li><a href="#41-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A">4.1. 没有上司的舞会</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-树的重心">1. 树的重心</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV14K4y1f7Uf/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E32 树形DP 树的重心_bilibili</a>，模拟过程从 $10:00$ 起</p>
</blockquote>
<ul>
<li>重心定义：指树中的一个结点，将这个点删除后剩余各个连通块中点数的最大值最小，那么这个结点就是树的重心</li>
<li>思路，任取一点 $u$，若以 $u$ 为重心，则分为两类<ul>
<li>一类是 $u$ 的子树，需要计算出 $u$ 的最大子树的节点数 $size$ 和以 $u$ 为根的子树的结点数 $sum$</li>
<li>另一类是 $u$ 上面的部分，直接通过 $n-sum$ 得到</li>
</ul>
</li>
<li>下面的子树部分在深搜回溯时完成，上方部分用做差的方法来计算，在深搜每个结点时，不断取每个结点 $size$ 和 $n-sum$ 中的最大值来更新结果</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240415212508027.png" alt="image-20240415212508027"></p>
<ul>
<li>如上图中将结点 $6$ 作为树的重心，那么其左子树 ${7,\ 8,\ 9}$ 的结点个数为 $3$，其右子树 ${3}$ 结点个数为 $1$，则 $sum$ 为 $1+3+1(自身)&#x3D;5$，其上方部分为 ${1,\ 2,\ 4,\ 5}$ 结点个数为 $4$，$ans&#x3D;min(max(1,3),9-sum)&#x3D;4$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">		</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line">		</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,ans; <span class="comment">// ans记录答案,也就是剩余各个连通块中点数的最大值</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 避免重复搜索,只能自上往下</span></span><br><span class="line"><span class="type">int</span> h[N],e[<span class="number">2</span>*N],ne[<span class="number">2</span>*N],idx; <span class="comment">// 链式前向星邻接表</span></span><br><span class="line">		</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a];</span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 以u为根的子树的节点数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> size=<span class="number">0</span>; <span class="comment">// 记录u的最大子树的结点数</span></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>; <span class="comment">// 记录以u为根的子树的结点数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i]; <span class="comment">// 取邻点</span></span><br><span class="line">		<span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>; <span class="comment">// 因为是无向图建边,避免往回走陷入死循环</span></span><br><span class="line">		<span class="type">int</span> s=dfs(j); <span class="comment">// s是以j为根的子树的结点数</span></span><br><span class="line">		<span class="comment">// 入下回离,回时更新维护size和sum</span></span><br><span class="line">		size=max(size,s); <span class="comment">// 最大子树的结点数</span></span><br><span class="line">		sum+=s; <span class="comment">// 子树的结点总数</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u=&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;, size=&quot;</span>&lt;&lt;size&lt;&lt;<span class="string">&quot;, sum=&quot;</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当所有临边访问完后,也就是&quot;离&quot;开u结点的时候,更新答案</span></span><br><span class="line">	ans=min(ans,max(size,n-sum)); <span class="comment">// 最小最大值</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u=&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;, size=&quot;</span>&lt;&lt;size&lt;&lt;<span class="string">&quot;, sum=&quot;</span>&lt;&lt;sum&lt;&lt;<span class="string">&quot;, ans=&quot;</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> sum; <span class="comment">// 返回以u为根的子树的结点个数</span></span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	ans=n;</span><br><span class="line">	<span class="comment">// n结点共n-1条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		add(a,b);</span><br><span class="line">		add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>); <span class="comment">// 从任意结点开始深搜,不影响结果</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">6 3</span></span><br><span class="line"><span class="comment">6 7</span></span><br><span class="line"><span class="comment">7 9</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-树的直径">2. 树的直径</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1ni4y157s3/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E33 树形DP 树的直径_bilibili</a>，模拟过程从 $9:45$ 起</p>
</blockquote>
<ul>
<li>树的直径：即树的最长路径，在一棵树中使得路径两端点之间的距离最远，注意路径中可只包含一个点</li>
<li>思路，任取一点 $u$，从 $u$ 往下搜，返回时收集边权并记录两条路径<ul>
<li>$d1$：从 $u$ 往下走的最长路径的长度</li>
<li>$d2$：从 $u$ 往下走的次长路径的长度</li>
<li>那么 $d1+d2$ 代表的就是悬挂在结点 $u$ 上的最长路径的长度，用一个临时变量 $ans$ 维护最大路径长度即可，$ans&#x3D;max(ans,d1+d2)$</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240415224030562.png" alt="image-20240415224030562"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2</span>*N;</span><br><span class="line"><span class="type">int</span> n,ans; <span class="comment">// ans记录最长路径的长度</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 避免往下走</span></span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a];</span><br><span class="line">	w[idx]=c;</span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从u点往下走的最大长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> d1=<span class="number">0</span>; <span class="comment">// 从u往下走的最大长度</span></span><br><span class="line">	<span class="type">int</span> d2=<span class="number">0</span>; <span class="comment">// 从u往下走的次大长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i]; <span class="comment">// 取出邻接点</span></span><br><span class="line">		<span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>; <span class="comment">// 无向图双向建边,只能从上往下避免往回走</span></span><br><span class="line">		<span class="type">int</span> d=dfs(j)+w[i]; <span class="comment">// 从u经j点向下走的最大长度</span></span><br><span class="line">		<span class="comment">// 如果d比最大长度还大,那么d变最大,最大变次大</span></span><br><span class="line">		<span class="keyword">if</span>(d&gt;=d1) d2=d1,d1=d;</span><br><span class="line">		<span class="comment">// 如果d比次大大,那么d变次大</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d&gt;d2) d2=d;</span><br><span class="line">		<span class="comment">// 回的时候更新u的最大边和次大边</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u=&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;, d1=&quot;</span>&lt;&lt;d1&lt;&lt;<span class="string">&quot;, d2=&quot;</span>&lt;&lt;d2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 入下回离,离的时候更新答案</span></span><br><span class="line">	ans=max(ans,d1+d2);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;u=&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;, d1=&quot;</span>&lt;&lt;d1&lt;&lt;<span class="string">&quot;, d2=&quot;</span>&lt;&lt;d2&lt;&lt;<span class="string">&quot;, ans=&quot;</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> d1; <span class="comment">// 返回从u往下走的最大长度,先有最大边,再遍历其他边,从而找新最大和次大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="comment">// n点 n-1边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		add(a,b,c);</span><br><span class="line">		add(b,a,c);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>); <span class="comment">// 任选一点开始深搜结果相等</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5 1 6</span></span><br><span class="line"><span class="comment">1 4 5</span></span><br><span class="line"><span class="comment">6 3 9</span></span><br><span class="line"><span class="comment">2 6 8</span></span><br><span class="line"><span class="comment">6 1 7</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2><span id="3-树的中心">3. 树的中心</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1FT4y1M7R6/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E34 树形DP 树的中心_bilibili</a>，模拟过程从 $14:20$ 起</p>
</blockquote>
<ul>
<li><p>树的中心：到树中其他点的最远距离最近</p>
</li>
<li><p>思路，若以每个点为根，分别求出从根向下走的最远距离，然后循环 $n$ 个点，求出各点最远距离的最小值，这样相当于 $n$ 遍 $dfs$，时间复杂度 $O(n^2)$ 会超时，该思路可以由两遍 $dfs$ 代替</p>
</li>
<li><p>从 $u$ 到其他结点的最远距离可以分为两类</p>
<ul>
<li>从 $u$ 点向下走的最远距离，用 $d1[u]$ 表示，自下而上递推，由子结点信息更新父结点信息，在返回时实现，属于入下回离中的回，即在 $dfs$ 之后实现<ul>
<li>从 $u$ 向下走的最大长度：$d1[u]&#x3D;d1[j]&#x3D;w[i]$</li>
<li>从 $u$ 向下走的次长长度：$d2[u]&#x3D;d2[j]+w[i]$</li>
</ul>
</li>
<li>从 $u$ 点向上走的最远距离，用 $up[u]$ 表示，自上而下递推，由父结点信息更新子结点信息，在下行时实现，属于入下回离中的下，即在 $dfs$ 之前实现<ul>
<li>如果 $j$ 在从 $u$ 向下走的最长路径上，$up[j]&#x3D;w[i]+max(up[u],d2[u])$，即当前边权 $+$ 次长边</li>
<li>如果 $j$ 不在从 $u$ 向下走的最长路径上，$up[j]&#x3D;w[i]+max(up[u],d1[u])$，即当前边权 $+$ 最长边</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="31-第一次深搜-dfs_ddown">3.1. 第一次深搜 dfs_d（down）</span></h3><ul>
<li>子结点更新父结点，向上传递，故“回” 时传递信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一遍dfs</span></span><br><span class="line"><span class="comment">// 维护u向下走的最远距离d1[u]和次大距离d2[u]</span></span><br><span class="line"><span class="comment">// 维护从u向下走的最长路径是从哪个点下去的,即可在第二遍dfs中判断结点是否在最长路径上</span></span><br><span class="line"><span class="comment">// u:当前访问结点,fa:父结点,代替vis数组避免往回走的情况,其实就是树的直径升级版</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs_d</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="comment">// 最长与次长初始化为0</span></span><br><span class="line">	d1[u]=<span class="number">0</span>;</span><br><span class="line">	d2[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i]; <span class="comment">// 取出邻接点</span></span><br><span class="line">		<span class="keyword">if</span>(j==fa) <span class="keyword">continue</span>; <span class="comment">// 避免向上查找</span></span><br><span class="line">		<span class="type">int</span> d=dfs_d(j,u)+w[i]; <span class="comment">// 从u经j向下走的最长长度+边权</span></span><br><span class="line">        <span class="comment">// 为什么是d&gt;=d1[u]?因为最长长度可能由多条,为了次大和最大长度不相等,每次遍历到≥d1[u]的边时直接覆盖</span></span><br><span class="line">		<span class="keyword">if</span>(d&gt;=d1[u]) d2[u]=d1[u],d1[u]=d,p1[u]=j; <span class="comment">// 最长路径是从j下去的</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d&gt;d2[u]) d2[u]=d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离开结点时输出每个结点向下走的最大长度和次大长度</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;u=%d, d1[%d]=%d, d2[%d]=%d\n&quot;</span>,u,u,d1[u],u,d2[u]);</span><br><span class="line">	<span class="keyword">return</span> d1[u]; <span class="comment">// 返回向下走的最长长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-第二次深搜-dfs_uup">3.2. 第二次深搜 dfs_u（up）</span></h3><ul>
<li>父结点更新子结点，向下传递，故“下”时传递信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维护每个结点向上走的最大长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs_u</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="keyword">if</span>(j==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 如果j在u往下走的最大路径上,用次大边更新</span></span><br><span class="line">		<span class="keyword">if</span>(p1[u]==j) up[j]=max(up[u],d2[u])+w[i];</span><br><span class="line">		<span class="comment">// 下行传递信息</span></span><br><span class="line">		<span class="comment">// 如果j不在y往下走的最大路径上,用最大边更新</span></span><br><span class="line">		<span class="keyword">else</span> up[j]=max(up[u],d1[u])+w[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;u=%d, up[%d]=%d, up[%d]=%d\n&quot;</span>,u,j,up[j],u,up[u]);</span><br><span class="line">		dfs_u(j,u); <span class="comment">// 深搜u的子结点j</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240416102410939.png" alt="image-20240416102410939"></p>
<ul>
<li><p>如上图树结构在第一次 $dfs$ 结束后得到每个结点向下走的最大长度和次长长度如每个结点下方的第一关键字和第二关键字所示</p>
</li>
<li><p>现进行第二次 $dfs$，因为是向下传递，所以我们只看入下回离中的“下”</p>
<ul>
<li>先经过结点 $5$，由于 $5$ 不在其父结点 $1$ 的最长路径上，所以 $up[5]&#x3D;d1[1]+w[i]&#x3D;3+1&#x3D;4$（$1$ 向下走的最长长度 $+$ 边权）</li>
<li>再经过结点 $2$，由于 $2$ 在父结点 $1$ 的最长路径上，所以 $up[2]&#x3D;d2[1]+w[i]&#x3D;1+1&#x3D;2$（$1$ 向下走的次大长度 $+$ 边权）</li>
<li>再经过结点 $3$，由于 $3$ 在父结点 $2$ 的最长路径上，所以 $up[3]&#x3D;max(up[2],d2[2])+w[i]&#x3D;max(2,0)+1&#x3D;3$（父结点 $2$ 向上走的最大距离或者向下走的次大距离中的最大值，即 ${2→\ 1→\ 5}$ 这条路 $+$ ${2→3}$的边权）</li>
<li>最后经过结点 $4$，由于 $4$ 在父结点 $3$ 的最长路径上，所以 $up[4]&#x3D;max(up[3],d2[3])+w[i]&#x3D;max(3,0)+1&#x3D;4$</li>
</ul>
</li>
<li><p>最终输入完整的模拟结果如下：</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240416104618207.png" alt="image-20240416104618207"></p>
<ul>
<li>完整代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2</span>*N;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> e[M];</span><br><span class="line"><span class="type">int</span> ne[M];</span><br><span class="line"><span class="type">int</span> w[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a];</span><br><span class="line">	w[idx]=c;</span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d1[N]; <span class="comment">// 存储从u点向下走的最大长度</span></span><br><span class="line"><span class="type">int</span> d2[N]; <span class="comment">// 存储从u点向下走的次大长度</span></span><br><span class="line"><span class="type">int</span> p1[N]; <span class="comment">// 记录从u点向下走的最长路径是从哪个点下去的</span></span><br><span class="line"><span class="type">int</span> up[N]; <span class="comment">// 记录从u点向上走的最大路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一遍dfs</span></span><br><span class="line"><span class="comment">// 维护u向下走的最远距离d1[u]和次大距离d2[u]</span></span><br><span class="line"><span class="comment">// 维护从u向下走的最长路径是从哪个点下去的,即可在第二遍dfs中判断结点是否在最长路径上</span></span><br><span class="line"><span class="comment">// u:当前访问结点,fa:父结点,代替vis数组避免往回走的情况,其实就是树的直径升级版</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs_d</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="comment">// 最长与次长初始化为0</span></span><br><span class="line">	d1[u]=<span class="number">0</span>;</span><br><span class="line">	d2[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i]; <span class="comment">// 取出邻接点</span></span><br><span class="line">		<span class="keyword">if</span>(j==fa) <span class="keyword">continue</span>; <span class="comment">// 避免向上查找</span></span><br><span class="line">		<span class="type">int</span> d=dfs_d(j,u)+w[i]; <span class="comment">// 从u经j向下走的最长长度+边权</span></span><br><span class="line">		<span class="keyword">if</span>(d&gt;=d1[u]) d2[u]=d1[u],d1[u]=d,p1[u]=j; <span class="comment">// 最长路径是从j下去的</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(d&gt;d2[u]) d2[u]=d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离开结点时输出每个结点向下走的最大长度和次大长度</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;u=%d, d1[%d]=%d, d2[%d]=%d\n&quot;</span>,u,u,d1[u],u,d2[u]);</span><br><span class="line">	<span class="keyword">return</span> d1[u]; <span class="comment">// 返回向下走的最长长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护每个结点向上走的最大长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs_u</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="keyword">if</span>(j==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 如果j在u往下走的最大路径上,用次大边更新</span></span><br><span class="line">		<span class="keyword">if</span>(p1[u]==j) up[j]=max(up[u],d2[u])+w[i];</span><br><span class="line">		<span class="comment">// 下行传递信息</span></span><br><span class="line">		<span class="comment">// 如果j不在y往下走的最大路径上,用最大边更新</span></span><br><span class="line">		<span class="keyword">else</span> up[j]=max(up[u],d1[u])+w[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;u=%d, up[%d]=%d, up[%d]=%d\n&quot;</span>,u,j,up[j],u,up[u]);</span><br><span class="line">		dfs_u(j,u); <span class="comment">// 深搜u的子结点j</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="comment">// n顶点 n-1条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		add(a,b,c),add(b,a,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 深搜入口父结点定义为-1,因为编号为-1的点根本不存在,根节点无父结点,相当于把1作为根节点的意思</span></span><br><span class="line">	dfs_d(<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">// 第一次深搜 </span></span><br><span class="line">	dfs_u(<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">// 第二次深搜</span></span><br><span class="line">	<span class="type">int</span> res=INT_MAX;</span><br><span class="line">	<span class="comment">// 对每个结点</span></span><br><span class="line">	<span class="comment">// (往上走距离的最大值,往下走距离的最大值)的最大值即结点i到树中其他结点的最大距离</span></span><br><span class="line">	<span class="comment">// 对每个结点的最大值取最小值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=min(res,max(up[i],d1[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出到中心到其他结点的最大距离</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">2 1 1</span></span><br><span class="line"><span class="comment">3 2 1</span></span><br><span class="line"><span class="comment">4 3 1</span></span><br><span class="line"><span class="comment">5 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2><span id="4-例题">4. 例题</span></h2><h3><span id="41-没有上司的舞会">4.1. 没有上司的舞会</span></h3><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1eK411N7Ly/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E17 树形DP Luogu P1352 没有上司的舞会 bilibili</a>，模拟过程从 $6:50$ 开始</p>
</blockquote>
<ul>
<li>先从根到叶一路深搜，再从叶到根做后</li>
<li>序 $DP$，每次用子树的 $f$ 值更新当前结点的 $f$ 值，兜了一圈回到根节点，根节点的 $f$ 值就是全局最优解</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240421234506971.png" alt="image-20240421234506971"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2024/10/04/%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="树">树</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">1. 树的遍历</a></li>
<li><a href="#2-%E6%8E%A8%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91">2. 推断二叉树</a><ul>
<li><a href="#21-%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84">2.1. 前序(后序)+中序→二叉树结构</a></li>
<li><a href="#22-%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84">2.2. 按层遍历+中序→二叉树结构</a></li>
<li><a href="#23-%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84">2.3. 扩展二叉树+前序(后序)→二叉树结构</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-树的遍历">1. 树的遍历</span></h2><ul>
<li>绕行踩点，按照深度优先搜索的顺序遍历整棵树，经过树的左侧时记录，得到的是先序遍历序列，经过树的下方时记录，得到的是中序遍历序列，经过数的右侧”🔺”时记录，得到的是后序遍历序列。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240304151152074.png" alt="image-20240304151152074"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240304151653655.png" alt="image-20240304151653655"></p>
<ul>
<li>若输入 $(0,0)$ 表示叶子节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 用左右孩子节点表示法</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_Order</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(node[root].l!=<span class="number">0</span>) <span class="built_in">pre_Order</span>(node[root].l);</span><br><span class="line">	<span class="keyword">if</span>(node[root].r!=<span class="number">0</span>) <span class="built_in">pre_Order</span>(node[root].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_Order</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[root].l!=<span class="number">0</span>) <span class="built_in">in_Order</span>(node[root].l);</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(node[root].r!=<span class="number">0</span>) <span class="built_in">in_Order</span>(node[root].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_Order</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[root].l!=<span class="number">0</span>) <span class="built_in">post_Order</span>(node[root].l);</span><br><span class="line">	<span class="keyword">if</span>(node[root].r!=<span class="number">0</span>) <span class="built_in">post_Order</span>(node[root].r);</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 输入编号1~n的左右孩子的编号</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		node[i]=&#123;l,r&#125;; <span class="comment">// 编号即为值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pre_Order</span>(<span class="number">1</span>); <span class="comment">// 前序遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">in_Order</span>(<span class="number">1</span>); <span class="comment">// 中序遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">post_Order</span>(<span class="number">1</span>); <span class="comment">// 后序遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2><span id="2-推断二叉树">2. 推断二叉树</span></h2><ul>
<li><p>已知一棵二叉树，可以确定它的四种遍历序列（前序、中序、后序、按层遍历），反过来，已知两种遍历序列，也能确定一棵二叉树。</p>
</li>
<li><p>根据先序序列第一个结点确定根结点</p>
</li>
<li><p>根据根结点在中序序列中的位置，分割出左子树和右子树</p>
</li>
<li><p>对左子树和右子树分别递归使用相同的方法继续分解</p>
</li>
</ul>
<h3><span id="21-前序后序中序二叉树结构">2.1. 前序(后序)+中序→二叉树结构</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 输入先序序列和中序序列推断出后序序列</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> val; </span><br><span class="line">	<span class="type">int</span> l,r; <span class="comment">// 左子树根节点编号,右子树根节点编号</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树因子</span></span><br><span class="line">string s_pre,s_in; <span class="comment">// 先序序列和中序序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据先序和中序建二叉树,返回树根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create</span><span class="params">(string sp,string si)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k; <span class="comment">// 分割点</span></span><br><span class="line">	<span class="type">int</span> root=++idx;</span><br><span class="line">	node[root].val=sp[<span class="number">0</span>]; <span class="comment">// 先序第一个节点作为树根</span></span><br><span class="line">	<span class="comment">// 找到树根在中序遍历中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(sp[<span class="number">0</span>]==si[i]) &#123;</span><br><span class="line">			k=i;</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确定左右子树序列的长度</span></span><br><span class="line">	<span class="type">int</span> len_l=k,len_r=si.<span class="built_in">length</span>()<span class="number">-1</span>-k;</span><br><span class="line">	<span class="comment">// 序列长度&gt;0,建立根节点的左子树,并递归对左子树按照先序和中序递归求解</span></span><br><span class="line">	<span class="comment">// 注意对sp和si都取相同的字符串长度</span></span><br><span class="line">	<span class="comment">// 先序遍历中,根节点总是在最前面,所以对sp跳过根节点</span></span><br><span class="line">	<span class="comment">// 中序遍历中,左子树总是在根节点之前,所以不需要跳过任何节点</span></span><br><span class="line">	<span class="keyword">if</span>(len_l&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		node[root].l=<span class="built_in">create</span>(sp.<span class="built_in">substr</span>(<span class="number">1</span>,len_l),si.<span class="built_in">substr</span>(<span class="number">0</span>,len_l));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(len_r&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		node[root].r=<span class="built_in">create</span>(sp.<span class="built_in">substr</span>(k<span class="number">+1</span>,len_r),si.<span class="built_in">substr</span>(k<span class="number">+1</span>,len_r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root; <span class="comment">// 返回头结点编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrder</span>(node[root].l);</span><br><span class="line">		<span class="built_in">postOrder</span>(node[root].r);</span><br><span class="line">		cout&lt;&lt;node[root].val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想按层遍历,则用BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//		cout&lt;&lt;x&lt;&lt;&#x27; &#x27;; // 若输出编号</span></span><br><span class="line">		cout&lt;&lt;node[x].val&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(node[x].l!=<span class="number">0</span>) q.<span class="built_in">push</span>(node[x].l);</span><br><span class="line">		<span class="keyword">if</span>(node[x].r!=<span class="number">0</span>) q.<span class="built_in">push</span>(node[x].r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s_pre&gt;&gt;s_in;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">create</span>(s_pre,s_in);</span><br><span class="line">	<span class="built_in">postOrder</span>(root); <span class="comment">// 输出后续遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">bfs</span>(root); <span class="comment">// 输出按层遍历的结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例输入:</span></span><br><span class="line"><span class="comment">abdec</span></span><br><span class="line"><span class="comment">dbeac</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3><span id="22-按层遍历中序二叉树结构">2.2. 按层遍历+中序→二叉树结构</span></h3><ul>
<li>按层遍历比较特殊，因为是按层，一般用广搜实现，下面这段代码的技巧在于，新开一种数据类型<strong>用于存储将中序遍历按照按层遍历中找到的根节点的信息</strong>，存储的信息包括这个待分解的中序遍历序列以及其根节点所在的位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解题思路: 将按层遍历的序列按照中序遍历序列分解那么排在前面的一定是根节点</span></span><br><span class="line"><span class="comment">// 但是按照常规算法来做时间复杂度会变成O(n²),介绍下面这种做法</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外开一个数据结构来存储按层遍历结果将中序遍历分成的每段中序遍历序列的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">	string s_in; <span class="comment">// 中序遍历序列</span></span><br><span class="line">	<span class="type">int</span> idx; <span class="comment">// 该中序遍历序列对应的子树的根节点编号</span></span><br><span class="line">	<span class="built_in">QNode</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">QNode</span>(string a,<span class="type">int</span> b):<span class="built_in">s_in</span>(a),<span class="built_in">idx</span>(b)&#123;&#125; <span class="comment">// 构造方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line">string s_in,s_lev; <span class="comment">// 中序遍历序列和层次遍历序列</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 建树因子</span></span><br><span class="line"><span class="type">int</span> lev_i; <span class="comment">// s_lev的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;QNode&gt; q;</span><br><span class="line">	<span class="type">int</span> k; <span class="comment">// 分割点</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">QNode</span>(s_in,++cnt)); <span class="comment">// 根节点地址为1</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		QNode u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">// 寻找中序遍历序列中根节点(根据层遍历)元素的下标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;u.s_in.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">			<span class="comment">// lev_i从0开始</span></span><br><span class="line">			<span class="keyword">if</span>(u.s_in[i]==s_lev[lev_i]) &#123;</span><br><span class="line">				k=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">// 这里可以手动模拟一下,更清晰</span></span><br><span class="line">		node[u.idx].val=s_lev[lev_i++]; <span class="comment">// 下一次在层次遍历中看下一个字符</span></span><br><span class="line">		string sl=u.s_in.<span class="built_in">substr</span>(<span class="number">0</span>,k),sr=u.s_in.<span class="built_in">substr</span>(k<span class="number">+1</span>); <span class="comment">// 左子树的中序遍历序列,右子树的中序遍历序列</span></span><br><span class="line">		<span class="comment">// 存在左子树,建树</span></span><br><span class="line">		<span class="keyword">if</span>(sl.<span class="built_in">length</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> lroot=++cnt; <span class="comment">// 根节点分配编号</span></span><br><span class="line">			node[u.idx].l=lroot;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">QNode</span>(sl,lroot)); <span class="comment">// sl是中序遍历序列,lroot是该中序遍历序列的根节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sr.<span class="built_in">length</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> rroot=++cnt;</span><br><span class="line">			node[u.idx].r=rroot;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">QNode</span>(sr,rroot));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	cout&lt;&lt;node[root].val;</span><br><span class="line">	<span class="built_in">preOrder</span>(node[root].l);</span><br><span class="line">	<span class="built_in">preOrder</span>(node[root].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s_in&gt;&gt;s_lev;</span><br><span class="line">	<span class="built_in">createTree</span>();</span><br><span class="line">	<span class="built_in">preOrder</span>(<span class="number">1</span>); <span class="comment">// 输出前序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">DBEAC</span></span><br><span class="line"><span class="comment">ABCDE</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">ABDEC</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h3><span id="23-扩展二叉树前序后序二叉树结构">2.3. 扩展二叉树+前序(后序)→二叉树结构</span></h3><ul>
<li>知道三种遍历中的其中两种可以推断出树的结构，但是用扩展二叉树标记法的时候只需要知道前序或者后序中的一种也能够推断出二叉树的结构</li>
<li>单独知道中序遍历无论如何都无法推断出二叉树的结构</li>
<li>下面代码的样例输入：$ABD..EF..G..C..$ 其中”.”表示的是补充的孩子节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 知道扩展二叉树的先序遍历结果即可反解出中序遍历和后序遍历</span></span><br><span class="line"><span class="comment">// 中序遍历和后序遍历的代码简单,关键在于如何建树</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树因子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(node[r].l);</span><br><span class="line">	cout&lt;&lt;node[r].val;</span><br><span class="line">	<span class="built_in">inOrder</span>(node[r].r);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">postOrder</span>(node[r].l);</span><br><span class="line">	<span class="built_in">postOrder</span>(node[r].r);</span><br><span class="line">	cout&lt;&lt;node[r].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入生成的二叉树的根值,返回生成的二叉树的编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTree</span><span class="params">(<span class="type">char</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val==<span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 说明到根节点了,左子树/右子树建树结束</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> root=++idx;</span><br><span class="line">		node[root].val=val;</span><br><span class="line">		node[root].l=<span class="built_in">createTree</span>(cin.<span class="built_in">get</span>()); <span class="comment">// 读取下一个字符是左子树</span></span><br><span class="line">		node[root].r=<span class="built_in">createTree</span>(cin.<span class="built_in">get</span>()); <span class="comment">// 读取下一个字符是右子树</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">createTree</span>(cin.<span class="built_in">get</span>()); <span class="comment">// 不断读取每一个字符</span></span><br><span class="line">	<span class="built_in">inOrder</span>(root);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">postOrder</span>(root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">ABD..EF..G..C..</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">DBFEGAC</span></span><br><span class="line"><span class="comment">DFGEBCA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2024/11/07/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="数位dp">数位DP</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F">1. 数字游戏</a><ul>
<li><a href="#11-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">1.1. 完整代码</a></li>
<li><a href="#12-%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90">1.2. 样例解析</a></li>
</ul>
</li>
<li><a href="#2-windy%E6%95%B0">2. Windy数</a><ul>
<li><a href="#21-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">2.1. 完整代码</a></li>
<li><a href="#22-%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90">2.2. 样例解析</a></li>
</ul>
</li>
<li><a href="#3-%E5%BA%A6%E7%9A%84%E6%95%B0%E9%87%8F">3. 度的数量</a><ul>
<li><a href="#31-%E7%8A%B6%E6%80%81%E9%A2%84%E5%A4%84%E7%90%86">3.1. 状态预处理</a></li>
<li><a href="#32-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB">3.2. 状态转移</a></li>
<li><a href="#33-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">3.3. 完整代码</a></li>
<li><a href="#34-%E6%A0%B7%E4%BE%8B%E8%A7%A3%E6%9E%90">3.4. 样例解析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>数位$DP$的特点：求某个区间 $[L,R]$，满足某种性质的数的个数</p>
</li>
<li><p>数位$DP$的技巧 $1$：类似前缀和的思想，转换为 $[0,R]-[0,L-1]$ 求解</p>
</li>
<li><p>数位$DP$的技巧 $2$：从高位到低位填数字，要分类讨论。把整数 $R$ 的每一位取出来，存入数组 $a$，则 $R&#x3D;a_na_{n-1}a_{n-2}…a_1$从高位到低位填数，划分两类：$[0,a_i-1]$ 和 $a_i$，如果 $i$ 位填 $[0,a_i-1]$ 则后面每一位都可以填 $[0,9]$；如果 $i$ 位填 $a_i$，则再讨论下一位，这样就可以保证填的数不超过 $R$</p>
</li>
<li><p>若 $R&#x3D;235$，从高位到低位所以先看第一位百位 $a_i&#x3D;2$，此时第一位可以填 $[0,a_i-1]$ 也就是 $[0,1]$，当 $a_i$ 填 $[0,1]$ 时剩下的每一位都可以填 $[0,9]$，故有 $[000,099]$ 和 $[100,199]$，这些数字都小于 $R$；当 $a_i$ 填 $2$ 时，进而开始看十位 $ai&#x3D;3$，此时第二位可以填 $[0,a_i-1]$ 也就是 $[0,2]$，当第二位填 $[0,2]$ 时剩下每一位都能填 $[0,9]$ 故有 $[200,209]$，$[210,219]$，$[220,229]$，当 $a_i$ 填 $3$ 时就要进而讨论最后一位个位 $a_i&#x3D;5$；此时也要分个位 $a_i$ 取 $[0,4]$ 和 $5$，这样就得到了 $&lt;&#x3D;R$ 的数集进行了划分</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240504112310985.png" alt="image-20240504112310985"></p>
<ul>
<li>代码模板<ul>
<li>先对数集从低位到高位做预处理</li>
<li>再对数据从高位到低位做递推</li>
</ul>
</li>
</ul>
<h2><span id="1-数字游戏">1. 数字游戏</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1fy4y1q79f/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E36 数位DP 数字游戏_bilibili</a><br>题目描述：从左往右各数字呈非下降关系如 $123$,$446$，问给定区间 $[a,b]$ 求区间内不降数的个数</p>
</blockquote>
<ul>
<li>不降数的个数应该与位数和最高位的数字有关</li>
<li>状态表示：$f[i,j]$ 表示一共有 $i$ 位，且最高位数字为 $j$ 的不降数的个数</li>
<li>状态转移：$f[i,j]&#x3D;f[i-1,j]+f[i-1,j+1]+f[i-1,j+2]+…+f[i-1,9]$ ，因为最高位固定为 $j$，所以假设第 $i-1$ 位是 $k$，根据不降数的定义 $k&gt;&#x3D;j$，故有 $f[i,j]&#x3D;\sum_{k&#x3D;j}^9\ f[i-1,k]$，一位一位的确定，所以 $f[i]$ 由 $f[i-1]$ 转移过来。举个比较简单的例子，$f[3,5]$ 表示三位数，最高位数字为 $5$，那么它应该是由 $f[2,5]+f[2,6]+…+f[2,9]$ 转移得到的，比如 $f[2,5]$ 就应该是 $f[1,5]+f[1,6]+…+f[1,9]$ 转移得到的</li>
<li>边界初值：$f[1,i]&#x3D;1\ (i&#x3D;[1,9])$ 只有一位数时不降数为 $1$</li>
</ul>
<h3><span id="11-完整代码">1.1. 完整代码</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a&lt;=b&lt;=2^31-1≈2.1×10^9,所以不超过10位数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">12</span>; <span class="comment">// 略开大一点,以防万一</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 保存数字的每一位</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:一共有i位且最高位数字是j的不降数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理不降数的个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) f[<span class="number">1</span>][i]=<span class="number">1</span>; <span class="comment">// 所有1位数,不降数个数为1</span></span><br><span class="line">	<span class="comment">// 1) 枚举位数,刚才计算了一位数,这里从两位数算起走</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举最高位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line">			<span class="comment">// 3) 枚举次高位,k&gt;=j,满足不降数的条件</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=<span class="number">9</span>;k++) &#123;</span><br><span class="line">				<span class="comment">// 累加方案数</span></span><br><span class="line">				f[i][j]+=f[i<span class="number">-1</span>][k];</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d\n&quot;</span>,i,j,f[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算[0,n]有多少个不降数,从高位到低位进行枚举统计,时间按复杂度是10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 特判,n=0也是一种不降数,返回1</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n) a[++cnt]=n%<span class="number">10</span>,n/=<span class="number">10</span>; <span class="comment">// 取位运算</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">0</span>; <span class="comment">// res:答案,last:保存上一位数字</span></span><br><span class="line">	<span class="comment">// 从高位到低位枚举每个数字</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> now=a[i]; <span class="comment">// 当前位数字</span></span><br><span class="line">		<span class="comment">// 枚举当前位可以填入的数字,不能小于last,保证填的数不超过传入的数n</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=last;j&lt;now;j++) &#123;</span><br><span class="line">			res+=f[i][j];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;当前枚举到第i=%d位, f[%d %d]=%d res=%d\n&quot;</span>,i,i,j,f[i][j],res);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(now&lt;last) <span class="keyword">break</span>; <span class="comment">// 比如遇到528,5过后是2,now&lt;last了,就直接break,后面不用算 </span></span><br><span class="line">		last=now; <span class="comment">// 更新上一位的数字</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) res++; <span class="comment">// 走到各位上的最后一次拆分且没有break出去,说明本身是一个不降数,ans++</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	init(); <span class="comment">// 预处理不降数个数</span></span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;dp(r)-dp(l<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-样例解析">1.2. 样例解析</span></h3><ul>
<li>统计 $[1,2557]$ 的不降数个数，对 $2557$ 进行拆分存储到 $a$ 数组中，从高位到低位依次枚举数字 $2,5,5,7$。<ul>
<li>当枚举到最高位 $2$ 时，$last&#x3D;0$，则最高位可以取 $[0,1]$，$res+&#x3D;f[4,0]+f[4,1]$；</li>
<li>当枚举到下一位 $5$ 时，$last&#x3D;2$（更新，满足不降数），则这一位可取 $[2,4]$，$res+&#x3D;f[3,2]+f[3,3]+f[3,4]$</li>
<li>当枚举到下一位 $5$ 时，$last&#x3D;5$，$last&lt;now$ 中没有可取元素，故跳过</li>
<li>当枚举到最后一位 $7$ 时，$last&#x3D;5$，故这一位可取 $[5,6]$，$res+&#x3D;f[2,5]+f[2,6]$，枚举到最后一位都没有退出，说明 $n&#x3D;2557$ 本身也为一个不降数，故 $res+&#x3D;1$</li>
</ul>
</li>
<li>统计 $[1,1]$ 的不降数个数，就是 $1$，所以 $res&#x3D;1$</li>
<li>二者做差，最终结果为 $472$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240504133801132.png" alt="image-20240504133801132"></p>
<ul>
<li>统计 $[1,5728]$ 的不降数个数，对 $5728$ 进行拆分存储到 $a$ 数组中，从高位到低位依次枚举数字 $5,7,2,8$。<ul>
<li>当枚举到最高位 $5$ 时，$last&#x3D;0$，则最高位可以取 $[0,4]$，$res+&#x3D;f[4,0]+f[4,1]+f[4,2]+f[4,3]+f[4,4]$；</li>
<li>当枚举到下一位 $7$ 时，$last&#x3D;5$（更新，满足不降数），则这一位可取 $[5,6]$，$res+&#x3D;f[3,5]+f[3,6]$</li>
<li>当枚举到下一位 $2$ 时，$last&#x3D;7$，$last&gt;now$ 不满足不降数，直接 $break$</li>
</ul>
</li>
<li>统计 $[1,1]$ 的不降数个数，就是 $1$，所以 $res&#x3D;1$</li>
<li>二者做差，最终结果为 $669$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240504134452689.png" alt="image-20240504134452689"></p>
<h2><span id="2-windy数">2. Windy数</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1fa4y1H7J6/?spm_id_from=333.999.0.0">E37 数位DP Windy数_bilibili</a><br>求区间 $[a,b]$ 中不含前导 $0$ 且相邻两个数字之差至少为 $2$ 的正整数（$Windy$ 数）个数</p>
</blockquote>
<ul>
<li><p>注意，个位数都是 $Windy$ 数，并且 $Windy$ 数不含前导 $0$，而上一题中是可以包含前导 $0$ 的，毕竟在最高位补 $0$ 并不影响这个数字是否为不降数，因为 $0$ 始终是最小的</p>
</li>
<li><p>状态表示：$f[i,j]$ 表示一共有 $i$ 位，且最高位数字为 $j$ 的 $Windy$ 数的个数</p>
</li>
<li><p>分段统计（思路）：同样的，用 $last$ 记录上一位数字，枚举当前位 $j$，如果 $abs(j-last)&gt;&#x3D;2$ （成为 $Windy$ 数条件）就累加答案，$res+&#x3D;f[i,j]$；前面的答案都是 $n$ 位的，对于位数低于 $n$ 位的，再分段统计，累加到答案中即可，例如：$[100,999]$、$[10,99]$、$[1,9]$</p>
</li>
<li><p>本题在使用数位$DP$的技巧时需要注意：因为不存在前导 $0$，所以最高位只能补 $[1,a_1-1]$，而其他位是 $[0,a_i-1]$</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240504203750057.png" alt="image-20240504203750057"></p>
<h3><span id="21-完整代码">2.1. 完整代码</span></h3><ul>
<li>代码需要注意几个地方，因为不含前导 $0$，所以从高位到低位处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">12</span>; <span class="comment">// INT_MAX=2×10^9,稍微多开一点空间</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 每一位存进a</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">10</span>]; <span class="comment">// f[i][j]:一共有i位,最高位为j的Windy数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理出所有Windy数,时间复杂度1000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) &#123;</span><br><span class="line">		f[<span class="number">1</span>][i]=<span class="number">1</span>; <span class="comment">// 一位数均为Windy数,包括0	</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d\n&quot;</span>,<span class="number">1</span>,i,f[<span class="number">1</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1) 枚举位数(从2位数开始)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举第i位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line">			<span class="comment">// 3) 枚举第i-1位</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++) &#123;</span><br><span class="line">				<span class="comment">// 如果满足Windy数条件,则转移</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(k-j)&gt;=<span class="number">2</span>) &#123; <span class="comment">// 求出所有k-j&gt;=2和j-k&gt;=2的情况</span></span><br><span class="line">					f[i][j]+=f[i<span class="number">-1</span>][k]; 	</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d\n&quot;</span>,i,j,f[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1~x的所有Windy数的个数</span></span><br><span class="line"><span class="comment">// 注意,数位DP时一定保证枚举到的数不超过x本身</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判,如果x==0返回0</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x) a[++cnt]=x%<span class="number">10</span>,x/=<span class="number">10</span>; <span class="comment">// 将x拆位存进数组a</span></span><br><span class="line">	<span class="comment">// 1) 答案是cnt位的情况,那么最高位的取值范围是[1,now-1],如r=1234</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">-2</span>; <span class="comment">// last取一个≤-1的值即可,只要保证j-last&gt;=2</span></span><br><span class="line">	<span class="comment">// 从最高位到低位枚举</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> now=a[i]; <span class="comment">// 取出当前位数字</span></span><br><span class="line">		<span class="comment">// 最高位从1开始,此时i==cnt,不是最高位就从0开始</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=(i==cnt);j&lt;now;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(j-last)&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">				res+=f[i][j];</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;i=%d f[%d %d]=%d res=%d\n&quot;</span>,i,i,j,f[i][j],res);</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;now&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;last&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不满足定义直接break掉</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(now-last)&lt;<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">		last=now; </span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">			res++; <span class="comment">// 能走到a1说明x本身是Windy数故+1</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;i=%d res=%d (走到a1)\n&quot;</span>,i,res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;以下是答案小于cnt位的情况&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 2) 答案小于cnt位,如r=1234时,对234</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) &#123;</span><br><span class="line">			res+=f[i][j];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;i=%d f[%d %d]=%d res=%d\n&quot;</span>,i,i,j,f[i][j],res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;res=%d (加上小于n位的后)\n&quot;</span>,res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp(r)-dp(l<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-样例解析">2.2. 样例解析</span></h3><ul>
<li>求区间 $[1,345]$ 中的 $Windy$ 数，则 $cnt&#x3D;&#x3D;3$<ul>
<li>当答案为 $3$ 位时 $(cnt)$<ul>
<li>当枚举到最高位 $now&#x3D;a_i&#x3D;3$ 时，$last&#x3D;-2$，进入 $for$ 循环，最高位能取 $[1,2]$（注意因为不含前导 $0$，最高位只能从 $1$ 开始枚举），故 $res+&#x3D;f[3,1]+f[3,2]$，此时 $now-last&gt;&#x3D;2$ 故不用退出计算，继续看下一位</li>
<li>当枚举到下一位 $now&#x3D;a_i&#x3D;4$ 时，$last&#x3D;3$，进入 $for$ 循环，这一位能取 $[0,2]$（不是最高位，可以从 $0$ 开始取），但是当 $a_i&#x3D;2$ 时不满足 $last-a_i&gt;&#x3D;2$，所以 $res+&#x3D;f[2,0]+f[2,1]$，不加 $f[2,2]$，此时 $now-last&lt;2$ 了不满足约束条件，所以直接剪枝退出循环</li>
</ul>
</li>
<li>当答案小于 $3$ 位时，这一步是对上一种情况没枚举完的进行枚举，$345$ 是 $3$ 位数，$&lt;cnt$ 的第一个数是 $cnt-1&#x3D;2$，故枚举累加 $[\ f[1,1],\ f[2,9]\ ]$，即 $[1,99]$</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240505094618965.png" alt="image-20240505094618965"></p>
<ul>
<li>求区间 $[1,2572]$ 中的 $Windy$ 数，可以自己模拟一下，这里不做阐释</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240505100100091.png" alt="image-20240505100100091"></p>
<h2><span id="3-度的数量">3. 度的数量</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1Ff4y1e7YW/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E38 数位DP 度的数量_bilibili</a><br>求区间 $[X,Y]$ 中满足恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和的数的统计个数</p>
</blockquote>
<ul>
<li>$K$ 个互不相等的 $B$ 的整数次幂，等价于是求 $[X,Y]$ 中有多少个数字在 $B$ 进制表示法下由 $K$ 个 $1$ 组成，其余位都是 $0$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240506092242964.png" alt="image-20240506092242964"></p>
<h3><span id="31-状态预处理">3.1. 状态预处理</span></h3><ul>
<li>状态表示 $f[i,j]$：表示 $i$ 个位置上出现 $j$ 个 $1$ 的组合数，如 $f[4,2]$ 表示 $4$ 位上出现 $2$ 个 $1$ 的组合数，很显然情况有：$0011,\ 0101,\ 1001,\ 1010,\ 1100,\ 0110$，就是组合数学中的 $c_4^2&#x3D;6$</li>
<li>状态转移 $f[i,j]&#x3D;f[i-1,j-1]+f[i-1,j]$ ：从 $i$ 个数中选 $j$ 个数，分两类，对于第 $1$ 个数选或不选，如果选，则从剩余的 $i-1$ 个数中再选 $j-1$ 个，即 $c_{i-1}^{j-1}$；如果不选，则从剩下 $i-1$ 个数中再选 $j$ 个</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">34</span>; <span class="comment">// INT_MAX大约2×10^10,转换成2进制最多2^31,为了保险稍开大一点</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:表示i个位置上放置j个1的组合数,如C42=6,则f[4][2]=6</span></span><br><span class="line"><span class="type">int</span> K,B; <span class="comment">// b进制表示,k个1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理组合数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) f[i][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// Cn0=1,cnn的0在下方的递推式中可以得到为1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j]; <span class="comment">// 组合数计算公式</span></span><br><span class="line">			<span class="comment">// c(i)(j)=c(i-1)(j-1)+c(i-1)(j)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-状态转移">3.2. 状态转移</span></h3><ul>
<li>把数字 $n$ 转化为 $B$ 进制数，随后从高位向低位枚举，假设枚举到第 $i$ 位，第 $i$ 位上的数字的 $x$，$last$ 记录第 $i$ 位之前放置 $1$ 的个数， 则分以下情况讨论</li>
</ul>
<ol>
<li>$x&#x3D;&#x3D;0$：直接跳过，继续枚举下一位</li>
<li>$x&#x3D;&#x3D;1$：第 $i$ 位再分为两种情况<ol>
<li>第 $i$ 位放 $0$，后面 $i-1$ 位上可以放 $k-last$ 个 $1$，$res+&#x3D;f[i-1][k-last]$</li>
<li>第 $i$ 为放 $1$，后面 $i-1$ 位上的情况不能用组合数计算，因为要保证答案中的数字比原数字小，所以固定第 $i$ 位为 $1$，继续枚举下一位</li>
</ol>
</li>
</ol>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240506201634106.png" alt="image-20240506201634106"></p>
<ul>
<li>比如当 $n&#x3D;65$ 时，转换成 $B&#x3D;4$ 进制数后为 $1001$，从最高位开始枚举，如果 $a_n$ 放 $0$，那么后面的每一位都可以取 $[0,B-1]$ 即 $[0,3]$，故有 $[0000,0333]$，因为 $K&#x3D;2$，而 $a_n$ 为 $0$，所以需要让后 $3$ 中出现 $2$ 个 $0$，所以 $res+&#x3D;f[3][2]$，$f[3][2]$ 中的 $3$ 表示从后 $3$ 位中取，$f[3][2]$ 中的 $2&#x3D;K-last&#x3D;2-0$；当第一位为 $1$，那后 $3$  位就不能随便取，不能超过 $1001$，所以 $a_{n-1}$ 只能取 $0$， $a_{n-2}$ 只能取 $0$，对于最后一位 $a_1$，如果 $a_1$ 放 $0$，$res+&#x3D;f[0][1]$，如果走到 $a_1&#x3D;1$ 说明 $n$ 这个数字本身满足转换为 $B$ 进制数后有 $K$ 个 $1$，其余位为 $0$，故 $res+&#x3D;1$</li>
</ul>
<ol start="3">
<li>$x&gt;1$ ：第 $i$ 位的放置分为三种情况<ol>
<li>第 $i$ 位放 $0$，后面 $i-1$ 位上可以放 $k-last$ 个 $1$，$res+&#x3D;f[i-1][k-last]$</li>
<li>第 $i$ 位放 $1$，后面 $i-1$ 位上可以放 $k-last-1$ 个 $1$，$res+&#x3D;f[i-1][k-last-1]$</li>
<li>第 $i$ 位放大于 $1$ 的数，已经不合题目要求（出现 $k$ 个 $1$，其余位都是 $0$），此时已经不合题意，直接剪枝 $break$</li>
</ol>
</li>
</ol>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240506203156130.png" alt="image-20240506203156130"></p>
<ul>
<li>比如当 $n&#x3D;99$ 时，转换成 $B&#x3D;4$ 进制数后为 $1201$，从最高位 $a_n$ 开始枚举，如果 $a_n&#x3D;0$，那么后 $3$ 位都能取 $[0,B-1]$，要在后 $3$ 位中放 $2$ 个 $1$，故有 $res+&#x3D;f[3][2]$，如果 $a_n&#x3D;1$，则现在还需在后 $3$ 位中放 $k-last&#x3D;2-1&#x3D;1$ 个 $1$，若第 $a_{n-1}$ 位取 $0,1$，则后 $2$ 位可以取 $[0,2]$，故有 $[1000,1033]$ 和 $[1100,1133]$，$res+&#x3D;f[2][1]+f[2][0]$，如果 $a_{n-1}$ 取 $2$，此时不满足题目性质，故 $break$</li>
</ul>
<h3><span id="33-完整代码">3.3. 完整代码</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">34</span>; <span class="comment">// INT_MAX大约2×10^10,转换成2进制最多2^31,为了保险稍开大一点</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:表示i个位置上放置j个1的组合数,如C42=6,则f[4][2]=6</span></span><br><span class="line"><span class="type">int</span> K,B; <span class="comment">// b进制表示,k个1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理组合数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) f[i][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// Cn0=1,cnn的0在下方的递推式中可以得到为1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j]; <span class="comment">// 组合数计算公式</span></span><br><span class="line">			<span class="comment">// c(i)(j)=c(i-1)(j-1)+c(i-1)(j)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> tmp=n; <span class="comment">// 记录n</span></span><br><span class="line">	<span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判,n==0,则不存在满足这样性质的数字</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n) a[++cnt]=n%B,n/=B; <span class="comment">// 将n拆成B进制数字存储至数组a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印数字n和其转换后的结果</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">0</span>; <span class="comment">// last表示第i位前放置1的个数(记录已经放置的1的个数)</span></span><br><span class="line">	<span class="comment">// 从高位到低位枚举</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="type">int</span> x=a[i]; <span class="comment">// 取出an</span></span><br><span class="line">		<span class="comment">// 1) 第i位==0时,直接跳过枚举下一位(即不进入这个if中)</span></span><br><span class="line">		<span class="comment">// 2) 第i位==1时,则这一位可以放0或1</span></span><br><span class="line">		<span class="keyword">if</span>(x) &#123;</span><br><span class="line">			<span class="comment">// 第一种情况:x位固定可以放0</span></span><br><span class="line">			res+=f[i<span class="number">-1</span>][K-last]; <span class="comment">// 第i位放0,则从后i-1位中放K-last个0</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(1)i=%d f[%d %d]=%d res=%d\n&quot;</span>,i,i<span class="number">-1</span>,K-last,f[i<span class="number">-1</span>][K-last],res);</span><br><span class="line">			<span class="comment">// 第i位&gt;1时,则可以取[0,1,...,ai-1]</span></span><br><span class="line">			<span class="keyword">if</span>(x&gt;<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(K-last<span class="number">-1</span>&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 第二种情况:x&gt;1,在本位可以放1</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;(2)i=%d f[%d %d]=%d res=%d\n&quot;</span>,i,i<span class="number">-1</span>,K-last,f[i<span class="number">-1</span>][K-last<span class="number">-1</span>],res);</span><br><span class="line">					res+=f[i<span class="number">-1</span>][K-last<span class="number">-1</span>]; <span class="comment">// 第i位放1,则从后i-1位中放K-last-1个0</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// 第i位放大于1的数,不合要求直接break</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 第i位==1时,不能使用组合数计算,则继续枚举下一位</span></span><br><span class="line">				last++; <span class="comment">// 出现的1的个数+1</span></span><br><span class="line">				<span class="keyword">if</span>(last&gt;K) <span class="keyword">break</span>; <span class="comment">// 1的个数多余k,break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; last==K) &#123;</span><br><span class="line">			<span class="comment">// 第三种情况=&gt; 走到数字本身</span></span><br><span class="line">			res++; <span class="comment">// 特判,走到末尾了,+1</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(3)i=%d res=%d\n&quot;</span>,i,res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;INT_MAX&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;K&gt;&gt;B;</span><br><span class="line">	init();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp(y)-dp(x<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="34-样例解析">3.4. 样例解析</span></h3><ul>
<li>当 $n&#x3D;65$ 时转换成 $4$ 进制数为 $1001$，从 $a4&#x3D;1$ 开始枚举，若 $a4$ 取 $0$，则 $res+&#x3D;f[i-1][k-last]&#x3D;f[3][2]&#x3D;3$；$a_3&#x3D;0,\ a_2&#x3D;0$，没有比其更小的数；$a_1&#x3D;1$，若 $a_1$ 取 $0$，则 $res+&#x3D;f[i-1]<a href="f%5B0%5D%5B1%5D">k-last</a>&#x3D;3$，最后走到 $a_1&#x3D;1$，$1001$ 本身满足性质，所以 $res+&#x3D;1&#x3D;&#x3D;4$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240506210646018.png" alt="image-20240506210646018"></p>
<ul>
<li>当 $n&#x3D;97$ 时转换成 $4$ 进制数为 $1201$，从 $a_4&#x3D;1$ 开始枚举，若 $a_4$ 取 $0$，则 $res+&#x3D;f[i-1][k-last]&#x3D;f[3][2]&#x3D;3$；$a_3&#x3D;2$，则 $a_3$ 可以取 $[0,1]$，当 $a_3&#x3D;0$ 时，$res+&#x3D;f[i-1][k-last]&#x3D;f[2][1]&#x3D;2$，当 $a_3&#x3D;1$ 时，$res+&#x3D;f[i-1][k-last-1]&#x3D;f[2][0]$，因为 $a_3&#x3D;2&gt;1$ 此时不满足题目性质，所以 $break$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240506211653186.png" alt="image-20240506211653186"></p>
<ul>
<li>当 $n&#x3D;85$ 时转换成 $4$ 进制数为 $1111$，从 $a_4&#x3D;1$ 开始枚举，若 $a_4$ 取 $0$，则 $res+&#x3D;f[i-1][k-last]&#x3D;f[3][2]&#x3D;3$，$a_4&#x3D;1$ 不用计算组合数跳过到下一位，继续枚举 $a_3&#x3D;1$，若 $a_3$ 取 $0$，则 $res+&#x3D;f[i-1][k-last]&#x3D;f[2][1]&#x3D;2$，若 $a_3&#x3D;1$ 不用计算组合数跳过到下一位，继续枚举 $a_2&#x3D;1$，若 $a_2$ 取 $0$，则 $res+&#x3D;f[i-1][k-last]&#x3D;f[1][0]&#x3D;1$，若 $a_2$ 取 $1$，此时 $last&#x3D;&#x3D;3&gt;k$，则 $break$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240506212218740.png" alt="image-20240506212218740"></p>
]]></content>
  </entry>
  <entry>
    <title>桶</title>
    <url>/2024/10/03/%E6%A1%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="桶">桶</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A1%B6%E7%BB%93%E6%9E%84">1. 桶结构</a></li>
<li><a href="#2-%E6%A1%B6%E6%8E%92%E5%BA%8F">2. 桶排序</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-桶结构">1. 桶结构</span></h2><blockquote>
<p>将桶单独拿出来讲，是为了讲后面的离散化</p>
</blockquote>
<ul>
<li>当数组中每个元素的大小范围给定时并且不超过空间限制时，用该数组的下标或下标+偏移量映射为该值的大小，数组的值表示该数字出现的次数的数据结构</li>
<li>优点：有效提高数据的访问效率和处理速度</li>
<li>缺点：必须知道每个元素的大小范围并且能够映射到$[0,N]$才可以使用</li>
</ul>
<blockquote>
<p>例题：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1186">1186：出现次数超过一半的数  信息学奥赛一本通（C++版）</a></p>
</blockquote>
<ul>
<li>桶做法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+10</span>; <span class="comment">// (-50,50),(0,100),[1,99]</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 桶</span></span><br><span class="line"><span class="comment">// 什么时候用桶→每个数据的范围给定</span></span><br><span class="line"><span class="comment">// 下标代表这个数字,或者这个数字的映射值,数组的值代表出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// temp:临时变量,nm n表示行,m表示列</span></span><br><span class="line"><span class="comment">// ans:answer, res:result, cnt:count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序:冒泡/交换/选择 O(n²), 快排/希尔排序/归并排序O(nlogn)/sort, 桶排序O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n; <span class="comment">// 5: 2 4 2 5 9</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		a[temp<span class="number">+50</span>]++; <span class="comment">// a[2]++,a[2]=1,a[4]=1,a[2]=2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历所有可能的大小,其实就遍历了所有的数字</span></span><br><span class="line">	<span class="comment">// 如果根本没出现过,a[i]=0</span></span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// a[i]代表出现的次数</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;n/<span class="number">2</span>) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			cout&lt;&lt;i<span class="number">-50</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>map做法</p>
</li>
<li><p>$map$是$C++$ STL库中自带的一种数据结构，可以理解为$Python$中的$dict$字典数据结构，map中有两个关键字，一个是键(索引)，一个是键值，它是一个二元组，和本题不谋而合，让第一个关键字存储这个值的大小，第二关键字存储出现的次数即可，而且不用考虑从$[-49,49]$映射到$[1,99]$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		m[temp]++; <span class="comment">// temp作为索引,键值+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 遍历map中的所有元素,迭代器的方法遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(it-&gt;second&gt;n/<span class="number">2</span>) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			cout&lt;&lt;it-&gt;first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-桶排序">2. 桶排序</span></h2><ul>
<li>当数据入桶后其实就相当于已经排好了序，我们可以从元素最小值遍历到最大值，又因为桶中的元素代表着这个元素出现的次数，那么出现了多少次我们就输出多少次这个元素，又因为是从小到大遍历的，所以倒桶的过程就是桶排序</li>
<li>桶排序的时间复杂度是$O(n)$，其中n是元素个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 假设每个元素的大小范围是[1,1000],我们准备一个大小足够的桶</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>; </span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		<span class="comment">// 入桶</span></span><br><span class="line">		a[temp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 倒桶的过程即为排序,不是真正的排好序</span></span><br><span class="line">	<span class="comment">// 从小到大遍历下标,即less规则排序</span></span><br><span class="line">	<span class="comment">// 从大到小遍历下标,即greater规则排序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i这个数字出现过</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&gt;<span class="number">0</span>;j--) &#123;</span><br><span class="line">				<span class="comment">// 输出a[i]次,因为a[i]代表i出现的次数</span></span><br><span class="line">				cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2024/11/08/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="树状数组">树状数组</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-%E5%89%8D%E7%BD%AE">2. 前置</a></li>
<li><a href="#3-%E6%80%A7%E8%B4%A8">3. 性质</a></li>
<li><a href="#4-%E6%93%8D%E4%BD%9C">4. 操作</a><ul>
<li><a href="#41-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">4.1. 单点修改，区间查询</a></li>
<li><a href="#42-%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">4.2. 区间修改，单点查询</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-概述">1. 概述</span></h2><ul>
<li>树状数组：动态维护前缀和，其应用为：<ol>
<li>单点修改，区间查询</li>
<li>区间修改，单点查询（通过差分思想）</li>
<li>区间修改，区间查询（直接线段树了，不用树状数组表示）</li>
</ol>
</li>
</ul>
<h2><span id="2-前置">2. 前置</span></h2><ul>
<li>$lowbit()$ 运算：非负整数在二进制表示下最低位 $1$ 及其后面的 $0$ 构成的数值</li>
<li>例如：$lowbit(44)&#x3D;lowbit((101100)_2)&#x3D;4$</li>
<li>在计算机中为了得到这个数值，可以先对 $101100$ 按位取反再 $+1$ 得到 $010100$，并把两个数字相与，即可得到 $100$。</li>
<li>① ~n+1&#x3D;-n (<del>表示按位取反)，② lowbit(n)&#x3D;n&amp;(</del>n+1)&#x3D;n&amp;-n</li>
<li>下图为树状数组结构</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230727151151406.png" alt="image-20230727151151406" style="zoom:67%;">



<h2><span id="3-性质">3. 性质</span></h2><ul>
<li>注意：线段树是树状数组的扩展，比树状数组的功能更强，但对于比较一般的问题更倾向于比较简单的树状数组</li>
<li>下图为树状数组展开为二进制</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230727153114410.png" alt="image-20230727153114410"></p>
<ul>
<li>如果不好理解这个图的形状，可以这样来看：</li>
<li>1）$len&#x3D;1$ 代表第 $0$ 层，从 $2^0$ 开始，两两元素的差值为 $2^1$</li>
<li>2）$len&#x3D;2$ 代表第 $1$ 层，从 $2^1$ 开始，两两元素的差值为 $2^2$</li>
<li>3）···</li>
</ul>
<ol>
<li>性质一、$t[x]$ 节点的长度等于 $lowbit(x)$ ，比如 $t[5]$ 的长度为 $lowbit((0101)_2)&#x3D;1$</li>
<li>性质二、$t[x]$ 节点的父节点等于 $t[x+lowbit(x)]$ ，比如 $t[6]$ 的父节点为 $t[6+lowbit(6)]&#x3D;t[6+lowbit(0110)_2]&#x3D;t[8]$</li>
<li>性质三、$t[x]$ 节点左上角的值等于 $t[x-lowbit(x)]$ ，此性质用于求和</li>
<li>性质四、整棵树的深度为 $log_2^{n+1}$</li>
<li>性质五、树状数组中每个元素的值存储的都是 $c[x]&#x3D;[x-lowbit(x), x]$ 这个区间内元素的和 ，由此可推导</li>
</ol>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230727153359531.png" alt="image-20230727153359531" style="zoom:50%;">



<h2><span id="4-操作">4. 操作</span></h2><h3><span id="41-单点修改区间查询">4.1. 单点修改，区间查询</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230727154039606.png" alt="image-20230727154039606" style="zoom:67%;">

<ul>
<li>在执行 $add$ 操作时，我们要对 $t$ 数组的某个值 $+k$ ，比如 $t[3]+k$，则需要更新其父节点 $t[4],t[8]$ 也加上$k$ ，根据性质 $2$ ，我们可以通过 $t[3+lowbit(3)]找到t[4]$，再通过 $t[4+lowbit(4)]$ 找到 $t[8]$，让三个节点都加上 $k$ 即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n是a数组的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230727154547790.png" alt="image-20230727154547790" style="zoom:67%;">

<ul>
<li>如果我们要求某个区间的和，比如 $ask(7)$ ，从图中可以看出$[1,7]$ 的和等于 $t[7]+t[6]+t[4]$（不断加左上角的值）[性质三]，其中 $t[7]&#x3D;a[7]$ ，$t[6]&#x3D;t[5]+a[6]&#x3D;a[5]+a[6]$，$t[4]&#x3D;t[2]+t[3]+a[4]&#x3D;t[1]+a[2]+a[3]+a[4]&#x3D;a[1]+a[2]+a[3]+a[4]$，所以为 $[a[1],a[7]]$ 的元素和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(x)) &#123;</span><br><span class="line">        sum+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当然，上述函数只能求 $1$ 到 $n$ 的区间和，如何求 $l$ 到 $r$ 的区间和呢？可以利用前缀和的性质：$[L,R]&#x3D;[1,R]-[1,L-1]$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        res-=t[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        res+=t[i]</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>板子题如下：</li>
</ul>
<blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1 </a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n是数组大小,m为查询次数</span></span><br><span class="line"><span class="type">int</span> t[maxn]; <span class="comment">// t数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x); <span class="comment">// 详见文档</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">		t[i]+=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [L,R]=[1,R]-[1,L-1]</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">search</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r;i;i-=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">		res+=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i;i-=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">		res-=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">// 把赋初值操作看成向空白的t数组add值,直接得到t数组,而无需存储a数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		<span class="built_in">add</span>(i,temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> op,l,r;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="built_in">add</span>(l,r);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">search</span>(l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">1 5 4 2 3</span></span><br><span class="line"><span class="comment">1 1 3</span></span><br><span class="line"><span class="comment">2 2 5</span></span><br><span class="line"><span class="comment">1 3 -1</span></span><br><span class="line"><span class="comment">1 4 2</span></span><br><span class="line"><span class="comment">2 1 4</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">14</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3><span id="42-区间修改单点查询">4.2. 区间修改，单点查询</span></h3><ul>
<li>lowbit(x)函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>区间update函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pos:修改点的起始位置,k:更新值</span></span><br><span class="line"><span class="comment">// 对于区间修改,比如[L,R]+k,只需要更新差分数组add(l,k),add(R+1,-k)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) </span><br><span class="line">		t[i]+=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了能对区间进行修改，我们引入差分数组 d[maxn]，要使t[L,R]+k，只需要add(l,k)，add(r+1,-k)，从l起的位置+k，从r+1后的位置-k，利用差分数组的性质</li>
<li>单点ask的函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回区间1~pos的总和</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i)) </span><br><span class="line">		res+=t[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>只需要将差分数组的 $[1,pos]$ 位相加起来，得到的就是这一位上的值</p>
</li>
<li><p>板子题：洛谷-p3368</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> t[maxn]; <span class="comment">// 树状数组</span></span><br><span class="line"><span class="type">int</span> d[maxn]; <span class="comment">// 差分数组,用于区间修改,d[i]=a[i]-a[i-1]</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n是数列个数,m是操作次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pos:修改点的起始位置,k:更新值</span></span><br><span class="line"><span class="comment">// 对于区间修改,比如[L,R]+k,只需要更新差分数组add(l,k),add(R+1,-k)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) </span><br><span class="line">		t[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回区间1~pos的总和</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i)) </span><br><span class="line">		res+=t[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		d[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">update</span>(i,d[i]); <span class="comment">// 为t[i]赋初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> op,l,r,val,q;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;val;</span><br><span class="line">			<span class="built_in">update</span>(l,val);</span><br><span class="line">			<span class="built_in">update</span>(r<span class="number">+1</span>,-val);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			cin&gt;&gt;q;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">ask</span>(q)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AcWing 1264：该题是一个树状数组板子题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 最普通的树状数组模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">add</span>(i,a[i]); <span class="comment">// 在第i个位置加上a[i]以初始化</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> k,x,y;</span><br><span class="line">		cin&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>) cout&lt;&lt;<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">// 区间求和</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">add</span>(x,y); <span class="comment">// 单点修改</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>高级数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛</title>
    <url>/2024/10/07/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="欧拉筛">欧拉筛</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E4%BC%A0%E7%BB%9F%E6%89%BE%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%9B%E9%80%89%E6%AC%A1%E6%95%B0">1. 传统找质数的方法（优化筛选次数）</a></li>
<li><a href="#2-%E6%AC%A7%E6%8B%89%E7%AD%9B">2. 欧拉筛</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-传统找质数的方法优化筛选次数">1. 传统找质数的方法（优化筛选次数）</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要找从 $[1,1e6]$ 中的所有质数，时间复杂度很高</li>
</ul>
<h2><span id="2-欧拉筛">2. 欧拉筛</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230720102317937.png" alt="image-20230720102317937"></p>
<ul>
<li>算法思想：遍历到 $2$ 的时候，筛掉范围内所有 $2$ 的倍数（因为除了 $1$ 和自身以外，一定能被 $2$ 整除），到 $3$ 的时候，筛掉所有 $3$ 的倍数···</li>
<li>注意：如果计算 $[l,r]$ 之间出现的质数的个数？可以用前缀和的思想；当 $n$ 过大时，$i×i$ 容易出现数组越界的错误，即可能 $RuntimeError$ ，此时要将线性筛中第二个 $for$ 中的 $j&#x3D;i×i$ 改为 $j&#x3D;i+i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 下标为i时,记录1~i出现的所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 是否已经访问过</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 用于存放素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx是存放素数的遍历因子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果vis[i]为false才需要遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]<span class="number">+1</span>; <span class="comment">// 计算前缀和</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 是素数,存起来</span></span><br><span class="line">            <span class="comment">// 如果出现RuntimeError,将j=i+i,这样就不会数组越界</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) <span class="comment">// 将素数i的倍数全部标记为合数,则无需遍历</span></span><br><span class="line">				vis[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如:输入1000即打印0~1000以内的素数</span></span><br><span class="line">	cin&gt;&gt;n;  </span><br><span class="line">	<span class="type">int</span> l,r; <span class="comment">// 左右区间</span></span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">get_primes</span>(n);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;1~&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;之间的素数分别是:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=idx;i++) &#123;</span><br><span class="line">		cout&lt;&lt;p[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=idx)</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot;所出现的素数个数为:&quot;</span>&lt;&lt;f[r]-f[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最简单的模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+5</span>; <span class="comment">// 注意这里没有开到2^9,只要比sqrt(2^9)大即可</span></span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> ans[N],len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++) &#123;</span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么特判x&gt;=N的情况?因为为了节省内存或者没必要,本题中只要保证MAXN比sqrt(理论最大值)大即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> !st[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;primes[i]&lt;=x/primes[i];i++)</span><br><span class="line">		<span class="keyword">if</span>(x%primes[i]==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
        <tag>欧拉筛</tag>
      </tags>
  </entry>
  <entry>
    <title>状压DP</title>
    <url>/2024/11/07/%E7%8A%B6%E5%8E%8BDP/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="状态压缩dp">状态压缩DP</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3">1. 蒙德里安的梦想</a><ul>
<li><a href="#11-%E7%8A%B6%E6%80%81%E9%A2%84%E5%A4%84%E7%90%86">1.1. 状态预处理</a><ul>
<li><a href="#111-%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81">1.1.1. 合法状态</a></li>
<li><a href="#112-%E9%9D%9E%E6%B3%95%E7%8A%B6%E6%80%81">1.1.2. 非法状态</a></li>
</ul>
</li>
<li><a href="#12-%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97">1.2. 状态计算</a></li>
<li><a href="#13-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">1.3. 完整代码</a></li>
</ul>
</li>
<li><a href="#2-%E5%B0%8F%E5%9B%BD%E7%8E%8B">2. 小国王</a><ul>
<li><a href="#21-%E7%8A%B6%E6%80%81%E9%A2%84%E5%A4%84%E7%90%86">2.1. 状态预处理</a><ul>
<li><a href="#210-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.1.0. 数据结构</a></li>
<li><a href="#211-%E8%A1%8C%E5%86%85%E5%90%88%E6%B3%95">2.1.1. 行内合法</a></li>
<li><a href="#212-%E8%A1%8C%E9%97%B4%E5%85%BC%E5%AE%B9">2.1.2. 行间兼容</a></li>
</ul>
</li>
<li><a href="#22-%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97">2.2. 状态计算</a></li>
<li><a href="#23-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">2.3. 完整代码</a></li>
</ul>
</li>
<li><a href="#3-%E7%8E%89%E7%B1%B3%E7%94%B0">3. 玉米田</a><ul>
<li><a href="#31-%E7%8A%B6%E6%80%81%E9%A2%84%E5%A4%84%E7%90%86">3.1. 状态预处理</a><ul>
<li><a href="#310-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3.1.0. 数据结构</a></li>
<li><a href="#311-%E8%A1%8C%E5%86%85%E5%90%88%E6%B3%95">3.1.1. 行内合法</a></li>
<li><a href="#312-%E8%A1%8C%E9%97%B4%E5%85%BC%E5%AE%B9">3.1.2. 行间兼容</a></li>
<li><a href="#313-%E4%BB%A3%E7%A0%81">3.1.3. 代码</a></li>
</ul>
</li>
<li><a href="#32-%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97">3.2. 状态计算</a></li>
<li><a href="#33-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">3.3. 完整代码</a></li>
</ul>
</li>
<li><a href="#4-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0">4. 炮兵阵地</a><ul>
<li><a href="#41-%E7%8A%B6%E6%80%81%E9%A2%84%E5%A4%84%E7%90%86">4.1. 状态预处理</a><ul>
<li><a href="#410-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4.1.0. 数据结构</a></li>
<li><a href="#411-%E8%A1%8C%E5%86%85%E5%90%88%E6%B3%95">4.1.1. 行内合法</a></li>
<li><a href="#412-%E8%A1%8C%E9%97%B4%E5%85%BC%E5%AE%B9">4.1.2. 行间兼容</a></li>
<li><a href="#413-%E4%BB%A3%E7%A0%81">4.1.3. 代码</a></li>
</ul>
</li>
<li><a href="#42-%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97">4.2. 状态计算</a></li>
<li><a href="#43-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">4.3. 完整代码</a></li>
<li><a href="#44-%E5%BB%B6%E7%94%B3-%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96">4.4. 延申-滚动数组优化</a><ul>
<li><a href="#441-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4.4.1. 数据结构</a></li>
<li><a href="#442-%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97%E9%83%A8%E5%88%86%E4%BF%AE%E6%94%B9">4.4.2. 状态计算部分修改</a></li>
<li><a href="#443-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">4.4.3. 完整代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-蒙德里安的梦想">1. 蒙德里安的梦想</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1cv411b7EG/?spm_id_from=333.999.0.0">E31 状态压缩DP 蒙德里安的梦想_bilibili</a>，参考博客：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/1634404/">AcWing 291. 蒙德里安的梦想 - AcWing</a></p>
</blockquote>
<ul>
<li>思路：摆放方块时，先放横着的，再放竖着的（先把横着的放完最后用竖着的去填充），方案总数等于只放横着的小方块的合法方案数</li>
<li>一定要理解下图的状态表示，每一行的状态 $1$ 表示：是横放的向下一列伸出；每一行的状态 $0$ 表示：状态 $1$ 的反集，竖放或由上一列伸出或未摆放<ul>
<li>对于图1<ul>
<li>第一列第一行是横放的向下一列伸出，故为1</li>
<li>第一列第二行是竖放的，故为0</li>
<li>第一列第三行是竖放的，故为0</li>
<li>第一列第四含是横放的向下一列深处，故为1</li>
</ul>
</li>
<li>对于图2<ul>
<li>第二列第一行是由上一列伸出的，故为0</li>
<li>第二列第二行是横放的向下一列伸出，故为1</li>
<li>第二列第三行是横放的向下一列伸出，故为1</li>
<li>第二列第四列是由上一列伸出的，故为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240427203142963.png" alt="image-20240427203142963"></p>
<ul>
<li>状态表示： $f[i,j]$ 表示已经将前 $i-1$ 列摆好，且从第 $i-1$ 列伸出到第 $i$ 列，状态为 $j$ 时的方案数，比如图 $1$ 的  ${1\ 0\ 0\ 1}$ 转换为十进制就是 $9$ ，所以图 $1$ 表示的是  $f[1,9]$   </li>
<li>状态转移： $f[i-1,k]→f[i,j]$ ，$f[i,j]$ 可由上一列的多种可行状态转移而来，所以第二维坐标是 $k$ ，如下图中 ${0\ 0\ 1\ 1}$ 可以由 ${0\ 0\ 0\ 0}$ 或者 ${1\ 1\ 0\ 0}$ 转移而来</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240427203858461.png" alt="image-20240427203858461"></p>
<ul>
<li>边界赋值：$f[0,0]&#x3D;1$ 不摆是一种方案</li>
<li>目标值：$f[m,0]$ 摆到第 $m$ 列且每一行都是 $0$，即刚好填满的状态</li>
</ul>
<h3><span id="11-状态预处理">1.1. 状态预处理</span></h3><ul>
<li><p>预处理即是检验在计算第 $i$ 行的状态 $j$ 时能否由第 $i-1$ 行的状态 $k$ 转换（是否合法），如果先进行了预处理的话那么在计算 $dp$ 数组的时候就很容易了</p>
</li>
<li><p>我们引入合并列的状态表示</p>
</li>
</ul>
<h4><span id="111-合法状态">1.1.1. 合法状态</span></h4><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240427210241200.png" alt="image-20240427210241200"></p>
<ul>
<li>对于左图，第一列的状态是 $1,\ 1,\ 0,\ 0$，第二列的状态是 $0,\ 0,\ 1,\ 1$，二者做或运算得到的就是合并列的状态，为 $1,\ 1,\ 1,\ 1$，转换为十进制为 $15$，所以 $15$ 为合法状态</li>
<li>对于右图，第一列的状态是 $1,\ 1,\ 0,\ 0$，第二列的状态是 $0,\ 0,\ 0,\ 0$，二者做或运算得到的就是合并列的状态，为 $1,\ 1,\ 0,\ 0$，转换为十进制为 $12$，所以 $12$ 为合法状态</li>
<li>二者都为合法状态，当然合法状态不止这些</li>
<li><strong>为什么要做或运算？</strong></li>
<li>做或运算主要是为了检验有没有连续的奇数个 $0$，如果有连续的奇数个 $0$，表示按照这种规则摆放横方格，就没法对奇数个 $0$ 的位置摆竖方格。因为每一行上的数字为 $1$ 代表该行上的单元格是伸出的，为 $0$ 代表未伸出，若第 $i-1$ 列为 ${1,\ 1,\ 0,\ 0}$ 就代表第 $i-1$ 列每一行的伸出状态，第 $i$ 列为 ${0,\ 0,\ 1,\ 1}$ 代表第 $i$ 列的伸出状态，做或运算，是对这两列的每一行分别做或运算，如果对于某一行两列都为未伸出状态 $(0)$ 则合并后也为 $(0)$，出现偶数个相邻的 $0$ 可以用竖方格来填充，但是奇数个就没有办法了，所以出现连续奇数个 $0$ 是非法的！</li>
</ul>
<h4><span id="112-非法状态">1.1.2. 非法状态</span></h4><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240427210636856.png" alt="image-20240427210636856"></p>
<ul>
<li>对于左图，第一列的状态是 $1,\ 1,\ 0,\ 0$，第二列的状态是 $0,\ 0,\ -1,\ 1$（这里用 $-1$ 表示不摆放），二者做或运算得到的就是合并列的状态，为 $1,\ 1,\ 0,\ 1$，因为第三行没有空间竖放，转换为十进制为 $13$，所以 $13$ 为非法状态</li>
<li>对于右图，第一列的状态是 $1,\ 1,\ 0,\ 0$，第二列的状态是 $0,\ 0,\ 1,\ -1$（这里用 $-1$ 表示不摆放），二者做或运算得到的就是合并列的状态，为 $1,\ 1,\ 1,\ 0$，因为第四行没有空间竖放，转换为十进制为 $14$，所以 $14$ 为非法状态</li>
<li>二者都为非法状态，当然非法状态不止这些</li>
<li>我们可以总结出，只要有连续的奇数个 $0$，就是竖放不了的，此时就是非法状态，除此以外就是合法状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理:判断合并列的状态i是否合法</span></span><br><span class="line"><span class="comment">// 如果合并列的某行是1表示横放,是0表示竖放</span></span><br><span class="line"><span class="comment">// 如果合并列不存在连续的奇数个0,即为合法状态</span></span><br><span class="line"><span class="comment">// 这里可以结合md文档来理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举状态1~2^n-1,若n=4,有四行,则总状态数为15</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++) &#123;</span><br><span class="line">    st[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 连续0的个数</span></span><br><span class="line">    <span class="comment">// 枚举状态二进制表示的每一位,比如13=1101(2)</span></span><br><span class="line">    <span class="comment">// 依次枚举每一位,得到 1 1 0 1,这样就可以处理有多少个连续的0来判断是否合法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">        <span class="comment">// 如果这一位是1,紧接着判断连续的0的个数是否是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;&gt;j &amp;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                st[i]=<span class="literal">false</span>; <span class="comment">// 这种状态不合法</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该位是1可以把cnt清0了因为要的是连续的(但其实也可以不清零)</span></span><br><span class="line">			cnt=<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果这位是0,那么cnt++</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有可能最后一位是0,此时中间如果隔了个1,比如0100,那么连续的0的个数也出现了奇数</span></span><br><span class="line">    <span class="comment">// 那么也是非法的,处理高位0的个数</span></span><br><span class="line">    <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) st[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出每一种状态是否合法或者非法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>&lt;&lt;n;i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;st[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;st[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-状态计算">1.2. 状态计算</span></h3><ul>
<li>第一层状态枚举列，第二层状态枚举这一列的状态，第三层枚举上一列的状态，如果两列的状态兼容，则可以转移，何为兼容？</li>
</ul>
<ol>
<li>不出现重叠的 $1$：</li>
</ol>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240427214132813.png" alt="image-20240427214132813"></p>
<ul>
<li>（虽然我觉得这张图的例子不恰当，因为这个状态本来就是非法的，但是也只有这张图了，假设它发生了吧）</li>
<li>第一列的状态为 ${0,\ 0,\ 0,\ 1}$，第二列的状态为 ${0,\ 0,\ 1,\ 1}$，做且运算的结果是 ${0,\ 0,\ 0,\ 1}$ 不为 $0$，说明出现了重叠的 $1$</li>
<li><strong>为什么要做与运算？</strong></li>
<li>做或运算主要是为了检验有没有重叠的横方格，因为每一行上的数字为 $1$ 代表该行上的单元格是伸出的，为 $0$ 代表未伸出，若第 $i-1$ 列为 ${0,\ 0,\ 0,\ 1}$ 就代表第 $i-1$ 列每一行的伸出状态，第 $i$ 列为 ${0,\ 0,\ 1,\ 1}$ 代表第 $i$ 列的伸出状态，做与运算，是对这两列的每一行分别做与运算，如果对于某一行，如果两列都有伸出状态 $(1)$，则合并后也为 $(1)$，此时说明第 $i-1$ 列和第 $i$ 列在某一行上都向下一行伸出，此时横方块就重叠了，不合法！</li>
</ul>
<ol start="2">
<li>不出现连续的奇数个 $0$</li>
</ol>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240427214448929.png" alt="image-20240427214448929"></p>
<ul>
<li>也就是我们预处理的时候预处理过的各种情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态转移</span></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 第0列不摆放是一种合法方案</span></span><br><span class="line"><span class="comment">// 1) 枚举列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">    <span class="comment">// 2)状态: 枚举第i列的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j++) &#123;</span><br><span class="line">        <span class="comment">// 3) 枚举第i-1列的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;n;k++) &#123;</span><br><span class="line">            <span class="comment">// 两列状态兼容</span></span><br><span class="line">            <span class="comment">// 不出现重叠的1 且 不出现连续的奇数个0(前一列的状态和当前列做或运算)</span></span><br><span class="line">            <span class="keyword">if</span>((j&amp;k)==<span class="number">0</span> &amp;&amp; st[j|k]) &#123;</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][k]; <span class="comment">// 前一列兼容状态的方案数之和</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d f[%d %d]=%d\n&quot;</span>,i,j,f[i][j],i<span class="number">-1</span>,k,f[i<span class="number">-1</span>][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[m][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第m列不横放,即下一列没有突出的,刚好放满,即答案</span></span><br></pre></td></tr></table></figure>



<h3><span id="13-完整代码">1.3. 完整代码</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">12</span>+<span class="number">5</span>; <span class="comment">// 最大行数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;N; <span class="comment">// 最大状态数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[M]; <span class="comment">// 总状态数</span></span><br><span class="line"><span class="type">int</span> f[N][M]; <span class="comment">// 第i行共k个状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 同时为0时退出</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m, n||m) &#123;</span><br><span class="line">		<span class="comment">// 预处理:判断合并列的状态i是否合法</span></span><br><span class="line">		<span class="comment">// 如果合并列的某行是1表示横放,是0表示竖放</span></span><br><span class="line">		<span class="comment">// 如果合并列不存在连续的奇数个0,即为合法状态</span></span><br><span class="line">		<span class="comment">// 这里可以结合md文档来理解</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 枚举状态1~2^n-1,若n=4,有四行,则总状态数为15</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++) &#123;</span><br><span class="line">			st[i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 连续0的个数</span></span><br><span class="line">			<span class="comment">// 枚举状态二进制表示的每一位,比如13=1101(2)</span></span><br><span class="line">			<span class="comment">// 依次枚举每一位,得到 1 1 0 1,这样就可以处理有多少个连续的0来判断是否合法</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">				<span class="comment">// 如果这一位是1,紧接着判断连续的0的个数是否是奇数</span></span><br><span class="line">				<span class="keyword">if</span>(i&gt;&gt;j &amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) &#123;</span><br><span class="line">						st[i]=<span class="literal">false</span>; <span class="comment">// 这种状态不合法</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">// 该位是1可以把cnt清0了因为要的是连续的(但其实也可以不清零)</span></span><br><span class="line">					cnt=<span class="number">0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 如果这位是0,那么cnt++</span></span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 有可能最后一位是0,此时中间如果隔了个1,比如0100,那么连续的0的个数也出现了奇数</span></span><br><span class="line">			<span class="comment">// 那么也是非法的,处理高位0的个数</span></span><br><span class="line">			<span class="keyword">if</span>(cnt&amp;<span class="number">1</span>) st[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出每一种状态是否合法或者非法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1</span>&lt;&lt;n;i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;st[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;st[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 状态转移</span></span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">		f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 第0列不摆放是一种合法方案</span></span><br><span class="line">		<span class="comment">// 1) 枚举列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">			<span class="comment">// 2)状态: 枚举第i列的状态</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;n;j++) &#123;</span><br><span class="line">				<span class="comment">// 3) 枚举第i-1列的状态</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;n;k++) &#123;</span><br><span class="line">					<span class="comment">// 两列状态兼容</span></span><br><span class="line">					<span class="comment">// 不出现重叠的1 且 不出现连续的奇数个0(前一列的状态和当前列做或运算)</span></span><br><span class="line">					<span class="keyword">if</span>((j&amp;k)==<span class="number">0</span> &amp;&amp; st[j|k]) &#123;</span><br><span class="line">						f[i][j]+=f[i<span class="number">-1</span>][k]; <span class="comment">// 前一列兼容状态的方案数之和</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d f[%d %d]=%d\n&quot;</span>,i,j,f[i][j],i<span class="number">-1</span>,k,f[i<span class="number">-1</span>][k]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;f[m][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第m列不横放,即下一列没有突出的,刚好放满,即答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-小国王">2. 小国王</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1pf4y1q7hU/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E25 状态压缩DP 小国王_bilibili</a><br>题目描述：在 $n×n$ 的棋盘上放 $k$ 个国王，国王可以攻击相邻的 $8$ 个格子，求使他们无法互相攻击的方案总数</p>
</blockquote>
<ul>
<li>比如在一个 $3×3$ 的矩阵中放 $2$ 个国王，一共有 $16$ 种方案</li>
<li>我们可以用二维数组表示一行上国王的放置情况，比如某一行为 $[1,\ 0,\ 1]$ 就表示第一列和第三列上有国王，但是当 $n$ 偏大时就会浪费掉很多空间甚至 $MLE$，所以将 $[1,\ 0,\ 1]$ 当作二进制数，转换成十进制数 $5$ 来表示状态</li>
<li>所谓状态压缩即为<ul>
<li>用二进制表示状态</li>
<li>用十进制存储状态</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240501224207803.png" alt="image-20240501224207803"></p>
<h3><span id="21-状态预处理">2.1. 状态预处理</span></h3><ul>
<li>假设 $n$ 的值就为 $3$，那么对于一个 $3×3$ 的棋盘，每一行的所有状态有 $2^3&#x3D;8$ 种，即 $000,\ 001,\ 010,\ 011,\ 100,\ 101,\ 102,\ 110,\ 111$</li>
</ul>
<h4><span id="210-数据结构">2.1.0. 数据结构</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">12</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 行数,国王个数</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 同一行的合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span>&lt;&lt;<span class="number">12</span>]; <span class="comment">// 同一行的合法状态集</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">1</span>&lt;&lt;<span class="number">12</span>]; <span class="comment">// 每个合法状态包含的国王数</span></span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">144</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>]; <span class="comment">// 最大12行,国王个数最大12×12,1左移12位表示所有状态最大值</span></span><br><span class="line"><span class="comment">// f[i,j,a]:前i行放了j个国王,第i行第a个状态时的方案</span></span><br></pre></td></tr></table></figure>



<h4><span id="211-行内合法">2.1.1. 行内合法</span></h4><ul>
<li>因为国王会攻击相邻 $8$ 个位置（同一行、同一列、两条对角线的首个元素），所以同一行不能存在两个相邻的 $1$，每行的合法状态只剩：$000,\ 001,\ 010,\ 100,\ 101$</li>
<li>用位运算 $!(i\ &amp;\ i&gt;&gt;1)$ 实现，即把 $i$ 和右移一位的 $i$ 按位相与，如果两位同为 $1$ 相与之后的结果为 $1$，此时说明存在两个相邻的 $1$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240501231046905.png" alt="image-20240501231046905"></p>
<ul>
<li>代码上每次枚举每一行的所有状态，如果行间不相邻则合法，合法时依次提取这个合法状态的每一位，统计有多少个 $1$，即出现了多少个国王，最后保存到 $s$ 和 $num$ 数组中去</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">    <span class="comment">// 枚举一行的所有状态(n个国王,共2^n-1状态)</span></span><br><span class="line">    <span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 不存在相邻的1,则为合法状态</span></span><br><span class="line">        s[cnt++]=i; <span class="comment">// s即为每一行的合法状态集,这里记录一下,cnt++</span></span><br><span class="line">        <span class="comment">// i为合法状态才进入这个if</span></span><br><span class="line">        <span class="comment">// 每次右移j位(j从0到n-1)就可以取到i的每一位,&amp;1 即可判断1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) </span><br><span class="line">            num[i]+=(i&gt;&gt;j&amp;<span class="number">1</span>); <span class="comment">// 每个合法状态的1的个数,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="212-行间兼容">2.1.2. 行间兼容</span></h4><ul>
<li>行内只用考虑行，行间还需要考虑对角线，即对第 $i$ 行考虑 $i-1$ 行的左上角、正上方和右上方三个位置，所以行 $a$ 对行 $b$ 考虑与 $b$ 直接相与（正上方）、右移（左上方）、左移（右上方）按位相与是否出现 $1$（是否相邻）</li>
<li>在状态计算时进行行间兼容的判断</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240501231306824.png" alt="image-20240501231306824"></p>
<h3><span id="22-状态计算">2.2. 状态计算</span></h3><ul>
<li><p>状态表示：$f[i,j,a]$ 表示前 $i$ 行已经放了 $j$ 个国王，第 $i$ 行的第 $a$ 个状态的方案数</p>
</li>
<li><p>状态转移：$f[i,j,a]&#x3D;\sum\ f[i-1,j-c[a],b]$ 表示来自上一行 $i-1$ 行，第 $i$ 行已经放了 $a$ 状态时（已经有几个国王）【用前 $i$ 行已经放的国王个数 $j$ 减去第 $i-1$ 行放的国王个数 $c[a]$】，再从上一行中所有的能和 $a$ 状态兼容的状态中累加求和，即是说，我们遍历到第 $i$ 行时，遍历第 $i$ 行的所有自己行内合法的状态，对每一个状态与上一行 $i-1$ 间处理行间兼容，如果兼容则加 $1$，相当于一个累加求和的过程</p>
</li>
<li><p>目标值：$ans&#x3D;\sum\ f[n,k,a]$，前 $n$ 行中已经放了 $k$ 个国王，对所有的第 $n$ 行的合法状态进行累加求和</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240501232626218.png" alt="image-20240501232626218"></p>
<ul>
<li>代码上</li>
</ul>
<ol>
<li><p>每一行可以不放国王最多 $k$ 个国王，所以枚举国王范围是 $[0,k]$</p>
</li>
<li><p>为什么特判 $j&gt;&#x3D;c$ ？控制 $f[i-1][j-c][b]$ 中的下标不为负数，表示可以继续放国王</p>
</li>
<li><p>为什么枚举行数要从 $[1,n]$ 呢？因为我们输出的目标值是 $f[n+1][k][0]$ 即遍历到了 $f[n][k][cnt-1]$ 的下一个状态，相当于第 $n+1$ 行什么都不放，两个状态等价，下面两段代码是等价的，好好理解，说实话这里我也没太明白，关于这部分的讲解从视频的 $17:25$ 开始</p>
</li>
</ol>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240501235708410.png" alt="image-20240501235708410"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态计算</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 不放国王是一种方案</span></span><br><span class="line"><span class="comment">// 1) 枚举行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 2) 枚举国王数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) &#123;</span><br><span class="line">        <span class="comment">// 3) 枚举第i行的合法状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">            <span class="comment">// 4) 枚举第i-1行的合法状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">                <span class="type">int</span> c=num[s[a]]; <span class="comment">// 第i行第a个合法状态的国王数</span></span><br><span class="line">                <span class="comment">// 可以继续放国王,不存在同列和斜对角的1</span></span><br><span class="line">                <span class="keyword">if</span>((j&gt;=c) &amp;&amp; !(s[b]&amp;s[a]) &amp;&amp; !(s[b]&amp;(s[a]&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(s[b]&amp;(s[a]&gt;&gt;<span class="number">1</span>))) &#123;</span><br><span class="line">                    f[i][j][a]+=f[i<span class="number">-1</span>][j-c][b]; <span class="comment">// 从第i-1行向第i行转移</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">1</span>][k][<span class="number">0</span>]; <span class="comment">// 第n+1行什么都不,只在1~n行放国王</span></span><br></pre></td></tr></table></figure>



<h3><span id="23-完整代码">2.3. 完整代码</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">12</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 行数,国王个数</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 同一行的合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span>&lt;&lt;<span class="number">12</span>]; <span class="comment">// 同一行的合法状态集</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">1</span>&lt;&lt;<span class="number">12</span>]; <span class="comment">// 每个合法状态包含的国王数</span></span><br><span class="line">ll f[<span class="number">12</span>][<span class="number">144</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>]; <span class="comment">// 最大12行,国王个数最大12×12,1左移12位表示所有状态最大值</span></span><br><span class="line"><span class="comment">// f[i,j,a]:前i行放了j个国王,第i行第a个状态时的方案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="comment">// 预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">		<span class="comment">// 枚举一行的所有状态(n个国王,共2^n-1状态)</span></span><br><span class="line">		<span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="comment">// 不存在相邻的1,则为合法状态</span></span><br><span class="line">			s[cnt++]=i; <span class="comment">// s即为每一行的合法状态集,这里记录一下,cnt++</span></span><br><span class="line">			<span class="comment">// i为合法状态才进入这个if</span></span><br><span class="line">			<span class="comment">// 每次右移j位(j从0到n-1)就可以取到i的每一位,&amp;1 即可判断1的个数</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) </span><br><span class="line">				num[i]+=(i&gt;&gt;j&amp;<span class="number">1</span>); <span class="comment">// 每个合法状态的1的个数,</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 状态计算</span></span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 不放国王是一种方案</span></span><br><span class="line">	<span class="comment">// 1) 枚举行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举国王数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) &#123;</span><br><span class="line">			<span class="comment">// 3) 枚举第i行的合法状态</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">				<span class="comment">// 4) 枚举第i-1行的合法状态</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">					<span class="type">int</span> c=num[s[a]]; <span class="comment">// 第i行第a个合法状态的国王数</span></span><br><span class="line">					<span class="comment">// 可以继续放国王,不存在同列和斜对角的1</span></span><br><span class="line">					<span class="keyword">if</span>((j&gt;=c) &amp;&amp; !(s[b]&amp;s[a]) &amp;&amp; !(s[b]&amp;(s[a]&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(s[b]&amp;(s[a]&gt;&gt;<span class="number">1</span>))) &#123;</span><br><span class="line">						f[i][j][a]+=f[i<span class="number">-1</span>][j-c][b]; <span class="comment">// 从第i-1行向第i行转移</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">1</span>][k][<span class="number">0</span>]; <span class="comment">// 第n+1行什么都不,只在1~n行放国王</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-玉米田">3. 玉米田</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1BA411j7Qv/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E26 状态压缩DP 玉米田_bilibili</a><br>题目描述：玉米田的大小为 $n×m$，相邻土地不能同时种植玉米（种玉米的方格边缘不相交），部分土地不育无法种植玉米，求种植方案总数</p>
</blockquote>
<ul>
<li>比如当玉米田大小为 $2×3$ 时，有下图 $8$ 种种植方案，其中红色的 $0$ 表示不育的土地</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240502123107098.png" alt="image-20240502123107098"></p>
<ul>
<li>和上一题类似用二进制表示每一行的状态，再转换为十进制数存储状态，用一维数组存储</li>
</ul>
<h3><span id="31-状态预处理">3.1. 状态预处理</span></h3><ul>
<li>和上一题类似，从行内合法和行内兼容来考虑，本题的“相邻”指的是上下左右四个方向的位置</li>
</ul>
<h4><span id="310-数据结构">3.1.0. 数据结构</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Mod=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 玉米田行数列数</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">14</span>]; <span class="comment">// 各行的状态值</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 同一行的合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span>&lt;&lt;<span class="number">14</span>]; <span class="comment">// 一行的合法状态集</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">14</span>][<span class="number">1</span>&lt;&lt;<span class="number">14</span>];</span><br><span class="line"><span class="comment">// f[i,a]:已种植前i行,第i行第a个状态时的方案数</span></span><br></pre></td></tr></table></figure>



<h4><span id="311-行内合法">3.1.1. 行内合法</span></h4><ul>
<li>若本行状态合法，则一定没有相邻的 $1$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240502123651504.png" alt="image-20240502123651504"></p>
<h4><span id="312-行间兼容">3.1.2. 行间兼容</span></h4><ul>
<li>除了考察正上方的元素，本题相较于小国王多了一个地图，所以需要考察是否能种</li>
<li>比如第 $i$ 行的地图为 $[1,1,0]$，每一行的合法状态有五个，他们没有相邻的 $1$，分别为：$[0,0,0],\ [0,0,1],\ [0,1,0],\ [1,0,0],\ [1,0,1]$，因为 $[0,0,1],\ [1,0,1]$ 与 $[1,1,0]$ 相与的结果不为本身（即出现了不能种的情况），所以合法状态还剩三个；此时还需要考察与上一行之间是否满足不相邻，比如遍历到 $a$ 行的第 $[0,1,0]$ 状态时，满足与此状态不相邻的有 $[0,0,0],\ [0,0,1],\ [1,0,0],\ [1,0,1]$ 共 $4$ 个</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240502124050540.png" alt="image-20240502124050540"></p>
<h4><span id="313-代码">3.1.3. 代码</span></h4><ul>
<li>地图数组 $g$ 存储的是每一行二进制地图状态的十进制表示数，如某一行的状态是 $[1,1,0]$，则十进制状态为 $6$，至于如何用代码实现就是一种技巧了，$g[i]&#x3D;(g[i]&lt;&lt;1)+x$，每次左移 $×2$ 提权随后加上这一位的值 $x$</li>
<li>保存行内合法的方法与小国王一致，这里不阐释</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        g[i]=(g[i]&lt;&lt;<span class="number">1</span>)+x; <span class="comment">// 保存各行的状态值</span></span><br><span class="line">        <span class="comment">// 模拟跟踪一下,g每次左移+x,得到的是第i行二进制状态的十进制数数值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;g[%d]=%d\n&quot;</span>,i,g[i]);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举一行的所有状态</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line">    <span class="comment">// 如果不存在相邻的1</span></span><br><span class="line">    <span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">        s[cnt++]=i; <span class="comment">// 保存合法状态的十进制表示数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-状态计算">3.2. 状态计算</span></h3><ul>
<li>状态表示：$f[i,a]$ 表示已经种植前 $i$ 行，第 $i$ 行第 $a$ 个状态时的方案数</li>
<li>状态计算：$f[i,a]&#x3D;\sum\ f[i-1,b]$（通过上一行所有的与第 $a$ 行兼容的状态进行累加求和）</li>
<li>目标值：$ans&#x3D;\sum\ f[n,a]$，即 $f[n+1,0]$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态计算</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 题目说什么都不种是一种状态</span></span><br><span class="line"><span class="comment">// 1) 枚举行技巧</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 2) 枚举第i行合法状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">        <span class="comment">// 3) 枚举第i-1行合法状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">            <span class="comment">// a种在肥沃土地上,a b同列不同时为1</span></span><br><span class="line">            <span class="keyword">if</span>((s[a]&amp;g[i])==s[a] &amp;&amp; !(s[a]&amp;s[b])) &#123;</span><br><span class="line">                f[i][a]=(f[i][a]+f[i<span class="number">-1</span>][b])%Mod;</span><br><span class="line">                <span class="comment">// 模拟跟踪</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d f[%d %d]=%d\n&quot;</span>,i,a,f[i][a],i<span class="number">-1</span>,b,f[i<span class="number">-1</span>][b]);</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">// 第n+1行什么都不种</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时我们可以对状态转移的条件判断做一个加强，我们让 $a,b$ 两行的状态都种在肥沃土地上，上面代码的写法只判断了 $a$ 要种在肥沃土地上，但是上一行 $b$ 的五种合法状态中也可以排除一些与上一行的土地 $g[i-1]$ 相与结果不为本身的，这样转移次数就会变少</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((s[a]&amp;g[i])==s[a] &amp;&amp; (s[b]&amp;g[i<span class="number">-1</span>])==s[b] &amp;&amp; !(s[a]&amp;s[b])) &#123;</span><br><span class="line">    f[i][a]=(f[i][a]+f[i<span class="number">-1</span>][b])%Mod;</span><br><span class="line">    <span class="comment">// 模拟跟踪</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d f[%d %d]=%d\n&quot;</span>,i,a,f[i][a],i<span class="number">-1</span>,b,f[i<span class="number">-1</span>][b]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以这样写，过滤掉不合法状态，再累加求和</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="comment">// 过滤掉 a b 种在不育土地上,a b同列同时为1</span></span><br><span class="line"><span class="keyword">if</span>(s[a]&amp;~g[i] || s[b]&amp;~g[i<span class="number">-1</span>] || s[a]&amp;s[b]) <span class="keyword">continue</span>;</span><br><span class="line">f[i][a]=(f[i][a]+f[i<span class="number">-1</span>][b])%Mod;</span><br></pre></td></tr></table></figure>



<h3><span id="33-完整代码">3.3. 完整代码</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">14</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 玉米田行数列数</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">14</span>]; <span class="comment">// 各行的状态值</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 同一行的合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span>&lt;&lt;<span class="number">14</span>]; <span class="comment">// 一行的合法状态集</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">14</span>][<span class="number">1</span>&lt;&lt;<span class="number">14</span>];</span><br><span class="line"><span class="comment">// f[i,a]:已种植前i行,第i行第a个状态时的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 预处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="type">int</span> x;<span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">			g[i]=(g[i]&lt;&lt;<span class="number">1</span>)+x; <span class="comment">// 保存各行的状态值</span></span><br><span class="line">			<span class="comment">// 模拟跟踪一下,g每次左移+x,得到的是第i行二进制状态的十进制数数值</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;g[%d]=%d\n&quot;</span>,i,g[i]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 枚举一行的所有状态</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line">		<span class="comment">// 如果不存在相邻的1</span></span><br><span class="line">		<span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">			s[cnt++]=i; <span class="comment">// 保存合法状态的十进制表示数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 状态计算</span></span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 题目说什么都不种是一种状态</span></span><br><span class="line">	<span class="comment">// 1) 枚举行技巧</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举第i行合法状态</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">			<span class="comment">// 3) 枚举第i-1行合法状态</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">				<span class="comment">// a种在肥沃土地上,a b同列不同时为1</span></span><br><span class="line">				<span class="keyword">if</span>((s[a]&amp;g[i])==s[a] &amp;&amp; !(s[a]&amp;s[b])) &#123;</span><br><span class="line">					f[i][a]=(f[i][a]+f[i<span class="number">-1</span>][b])%Mod;</span><br><span class="line">					<span class="comment">// 模拟跟踪</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;f[%d %d]=%d f[%d %d]=%d\n&quot;</span>,i,a,f[i][a],i<span class="number">-1</span>,b,f[i<span class="number">-1</span>][b]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 状态转移增强,让上一行b也必须种在肥沃土地上</span></span><br><span class="line"><span class="comment">//				if((s[a]&amp;g[i])==s[a] &amp;&amp; (s[b]&amp;g[i-1])==s[b] &amp;&amp; !(s[a]&amp;s[b])) &#123;</span></span><br><span class="line"><span class="comment">//					f[i][a]=(f[i][a]+f[i-1][b])%Mod;</span></span><br><span class="line"><span class="comment">//					// 模拟跟踪</span></span><br><span class="line"><span class="comment">//					printf(&quot;f[%d %d]=%d f[%d %d]=%d\n&quot;,i,a,f[i][a],i-1,b,f[i-1][b]);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line">				<span class="comment">// 也可以这样写</span></span><br><span class="line">				<span class="comment">// 过滤掉 a b 种在不育土地上,a b同列同时为1</span></span><br><span class="line"><span class="comment">//				if(s[a]&amp;~g[i] || s[b]&amp;~g[i-1] || s[a]&amp;s[b]) continue;</span></span><br><span class="line"><span class="comment">//				f[i][a]=(f[i][a]+f[i-1][b])%Mod;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">// 第n+1行什么都不种</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">1 1 0</span></span><br><span class="line"><span class="comment">0 1 1</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2><span id="4-炮兵阵地">4. 炮兵阵地</span></h2><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1vy4y1z7qy/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E27 状态压缩DP 炮兵部队_bilibili</a><br>题目描述：$n×m$ 的网格地图由平原和山地构成，炮兵只能放在平原，放在平原后攻击范围为横向左右各两格、纵向上下各两格，攻击范围不受地形影响，现在问在保证任意两支炮兵不互相攻击的前提下，在整个地图区域<strong>最多能</strong>摆放多少炮兵部队？</p>
</blockquote>
<ul>
<li><p>和玉米田一样的是，不是所有的方格都能放，那么区别在哪里？</p>
<ul>
<li>横向和纵向上分别延申了两格，那么行内兼容和行间兼容的条件都会发生变化</li>
<li>求的是最多能摆放多少部队，而不是总方案数</li>
</ul>
</li>
<li><p>同样的把每一行的地图用二进制表示，十进制存储，如 $PHHP→1001→9$（$P$ 表示平原，$H$ 表示山地）</p>
</li>
</ul>
<h3><span id="41-状态预处理">4.1. 状态预处理</span></h3><ul>
<li>横向和纵向上分别延申两格</li>
</ul>
<h4><span id="410-数据结构">4.1.0. 数据结构</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>; <span class="comment">// 最大行数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>; <span class="comment">// 列数最大为10,则状态最大有2^10-1</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N]; <span class="comment">// 地图各行十进制表示数值</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 每行合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[M]; <span class="comment">// 同一行的合法状态集个数</span></span><br><span class="line"><span class="type">int</span> num[M]; <span class="comment">// 每个合法状态包含1的个数</span></span><br><span class="line"><span class="type">int</span> f[N][M][M]; <span class="comment">// 110*1024*1024*4=440MB(int型4字节)</span></span><br><span class="line"><span class="comment">// f[i][a][b]:已放好前i行,第i行第a个状态,第i-1行第b个状态时能放置的最大数量</span></span><br></pre></td></tr></table></figure>



<h4><span id="411-行内合法">4.1.1. 行内合法</span></h4><ul>
<li>若列数 $m&#x3D;4$，则一行的所有状态有：$[0000,1111]$ 共 $15$ 个状态，合法即：不出现相邻的 $1$ 或不出现 $101$</li>
<li>判断条件：$if(!(i&amp;i&gt;&gt;1)\ &amp;&amp;\ !(i&amp;i&gt;&gt;2))$ 为$true$，则 $i$ 合法<ul>
<li>若 $i&#x3D;3,\ 0011$，$i&gt;&gt;1\ &#x3D;\ 0001$，$0011&amp;0001&#x3D;0001$，取反为 $false$，所以 $i&#x3D;3$ 不合法</li>
<li>若 $i&#x3D;5,\ 0101$，$i&gt;&gt;2\ &#x3D;\ 0001$，$0101&amp;0001&#x3D;0001$，取反为 $false$，所以 $i&#x3D;5$ 不合法</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240503101107406.png" alt="image-20240503101107406"></p>
<h4><span id="412-行间兼容">4.1.2. 行间兼容</span></h4><ul>
<li>现在用 $a$ 表示当前行，用 $b$ 表示上一行，用 $c$ 表示上上行，那么每遍历一个 $a$ 的合法状态并且 $a$ 与地图适配，$1$ 出现的位置都在平原上，那么再而去遍历 $b$ 的合法状态且不与 $a$ 有同列的冲突，确定好 $b$ 后再而去确定 $c$ 的状态，同理 $c$ 也不能和 $a$、$b$ 有同列冲突，这样就判定了一个合法状态</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240503101731400.png" alt="image-20240503101731400"></p>
<h4><span id="413-代码">4.1.3. 代码</span></h4><ul>
<li>需要学习的技巧在于<ul>
<li>若输入的地图是字符类型的，如何把其当成二进制数并转换成十进制数存储起来</li>
<li>考察相邻的 $11$ 的代码是 $!(i&amp;i&gt;&gt;1)$，考察 $101$ 的代码是 $!(i&amp;i&gt;&gt;2)$</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">// 预处理地图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">        <span class="type">char</span> c;<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="comment">// 这个技巧很重要,如果是平原(即1)需要转换成二进制</span></span><br><span class="line">        <span class="comment">// m-j-1 是1需要偏移的长度,即出现在第几位,转换成二进制是多少</span></span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;P&#x27;</span>) g[i]+=<span class="number">1</span>&lt;&lt;(m-j<span class="number">-1</span>); <span class="comment">// 保存地图各行数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g[%d]=%d\n&quot;</span>,i,g[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预处理合法状态和1的个数</span></span><br><span class="line"><span class="comment">// 枚举一行的所有状态</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line">    <span class="comment">// 如果不存在11或101</span></span><br><span class="line">    <span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>) &amp;&amp; !(i&amp;i&gt;&gt;<span class="number">2</span>)) &#123;</span><br><span class="line">        s[cnt++]=i; <span class="comment">// 保存这个合法状态</span></span><br><span class="line">        <span class="comment">// 统计这个合法状态包含1的个数,存进num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">            num[i]+=(i&gt;&gt;j&amp;<span class="number">1</span>); <span class="comment">// j&amp;1说明i偏移j位后末尾是1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印所有合法状态看看</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输出合法状态:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s[%d]=%d num[%d]=%d\n&quot;</span>,i,s[i],i,num[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="42-状态计算">4.2. 状态计算</span></h3><ul>
<li><p>状态表示：$f[i,a,b]$ 表示已摆放前 $i$ 行，当前第 $i$ 行的状态为 $a$，并且第 $i-1$ 行的状态为 $b$ 时能摆放的最大数量（比玉米田多了一维来锁定第 $i-1$ 行的状态，注意这里不是方案数！）【为什么不再来一维表示第 $i-2$ 行的状态？因为状态转移时，$f[i,a,b]$ 是由 $f[i-1,b,c]$ 转移来的，即状态 $i$ 的上一行是状态 $i-1$ 的本行，在循环计算时 $c$ 也包含在内了】</p>
</li>
<li><p>状态转移：$f[i,a,b]&#x3D;max(f[i,a,b],f[i-1,b,c]+num[a])$ 是由上一个状态的最大数量加上当前行第 $a$ 行所能摆放炮兵的数量转移得到</p>
</li>
<li><p>边界初值：$f[]&#x3D;0$</p>
</li>
<li><p>目标值：$ans&#x3D;max(f[n,a,b])$，即 $f[n+2,0,0]$（多算两行，最后两行什么都不放）或从 摆放了前 $n$ 的各个状态中遍历求得最大值</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态计算</span></span><br><span class="line"><span class="comment">// 1) 枚举行,多算两行,技巧同上</span></span><br><span class="line"><span class="comment">// 直接输出f[n+2][0][0] 这样就不用枚举最后一行n的所有合法状态挑出最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 2) 枚举第i行合法状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">        <span class="comment">// 3) 枚举第i-1行合法状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">            <span class="comment">// 4) 枚举第i-2行合法状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;cnt;c++) &#123;</span><br><span class="line">                <span class="comment">// 状态转移的条件</span></span><br><span class="line">                <span class="keyword">if</span>(!(s[a]&amp;s[b]) &amp;&amp; !(s[a]&amp;s[c]) &amp;&amp; !(s[b]&amp;s[c]) <span class="comment">// 任意两行不同列 </span></span><br><span class="line">                   &amp;&amp; (g[i]&amp;s[a])==s[a] &amp;&amp; (g[i<span class="number">-1</span>]&amp;s[b])==s[b]) <span class="comment">// 地图适配a,地图适配b</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// s[a]: 状态a的十进制表示,num[s[a]]: 取出本行状态为a时这一行的炮兵个数</span></span><br><span class="line">                    f[i][a][b]=max(f[i][a][b],f[i<span class="number">-1</span>][b][c]+num[s[a]]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 模拟跟踪状态转移过程</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;f[%d %d %d]=%d 由上一行 f[%d %d %d]=%d 加上本行炮兵个数 %d 转移而来\n&quot;</span>,</span><br><span class="line">                           i,a,b,f[i][a][b],i<span class="number">-1</span>,b,c,f[i<span class="number">-1</span>][b][c],num[s[a]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 等价于枚举第n行a/b所有状态遍历得到的最大值 </span></span><br></pre></td></tr></table></figure>



<h3><span id="43-完整代码">4.3. 完整代码</span></h3><blockquote>
<p>模拟跟踪过程从视频 $17:35$ 开始</p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240503114304814.png" alt="image-20240503114304814"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>; <span class="comment">// 最大行数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>; <span class="comment">// 列数最大为10,则状态最大有2^10-1</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N]; <span class="comment">// 地图各行十进制表示数值</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 每行合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[M]; <span class="comment">// 同一行的合法状态集个数</span></span><br><span class="line"><span class="type">int</span> num[M]; <span class="comment">// 每个合法状态包含1的个数</span></span><br><span class="line"><span class="type">int</span> f[N][M][M]; <span class="comment">// 110*1024*1024*4=440MB(int型4字节)</span></span><br><span class="line"><span class="comment">// f[i][a][b]:已放好前i行,第i行第a个状态,第i-1行第b个状态时能放置的最大数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 预处理地图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			<span class="type">char</span> c;<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">			<span class="comment">// 这个技巧很重要,如果是平原(即1)需要转换成二进制</span></span><br><span class="line">			<span class="comment">// m-j-1 是1需要偏移的长度,即出现在第几位,转换成二进制是多少</span></span><br><span class="line">			<span class="keyword">if</span>(c==<span class="string">&#x27;P&#x27;</span>) g[i]+=<span class="number">1</span>&lt;&lt;(m-j<span class="number">-1</span>); <span class="comment">// 保存地图各行数值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;g[%d]=%d\n&quot;</span>,i,g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预处理合法状态和1的个数</span></span><br><span class="line">	<span class="comment">// 枚举一行的所有状态</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) &#123;</span><br><span class="line">		<span class="comment">// 如果不存在11或101</span></span><br><span class="line">		<span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>) &amp;&amp; !(i&amp;i&gt;&gt;<span class="number">2</span>)) &#123;</span><br><span class="line">			s[cnt++]=i; <span class="comment">// 保存这个合法状态</span></span><br><span class="line">			<span class="comment">// 统计这个合法状态包含1的个数,存进num</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">				num[i]+=(i&gt;&gt;j&amp;<span class="number">1</span>); <span class="comment">// j&amp;1说明i偏移j位后末尾是1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印所有合法状态看看</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输出合法状态:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;s[%d]=%d num[%d]=%d\n&quot;</span>,i,s[i],i,num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 状态计算</span></span><br><span class="line">	<span class="comment">// 1) 枚举行,多算两行,技巧同上</span></span><br><span class="line">	<span class="comment">// 直接输出f[n+2][0][0] 这样就不用枚举最后一行n的所有合法状态挑出最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 2) 枚举第i行合法状态</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">			<span class="comment">// 3) 枚举第i-1行合法状态</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">				<span class="comment">// 4) 枚举第i-2行合法状态</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;cnt;c++) &#123;</span><br><span class="line">					<span class="comment">// 状态转移的条件</span></span><br><span class="line">					<span class="keyword">if</span>(!(s[a]&amp;s[b]) &amp;&amp; !(s[a]&amp;s[c]) &amp;&amp; !(s[b]&amp;s[c]) <span class="comment">// 任意两行不同列 </span></span><br><span class="line">						&amp;&amp; (g[i]&amp;s[a])==s[a] &amp;&amp; (g[i<span class="number">-1</span>]&amp;s[b])==s[b]) <span class="comment">// 地图适配a,地图适配b</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// s[a]: 状态a的十进制表示,num[s[a]]: 取出本行状态为a时这一行的炮兵个数</span></span><br><span class="line">						f[i][a][b]=max(f[i][a][b],f[i<span class="number">-1</span>][b][c]+num[s[a]]);</span><br><span class="line">						</span><br><span class="line">						<span class="comment">// 模拟跟踪状态转移过程</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;f[%d %d %d]=%d 由上一行 f[%d %d %d]=%d 加上本行炮兵个数 %d 转移而来\n&quot;</span>,</span><br><span class="line">							i,a,b,f[i][a][b],i<span class="number">-1</span>,b,c,f[i<span class="number">-1</span>][b][c],num[s[a]]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 等价于枚举第n行a/b所有状态遍历得到的最大值 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">PHHP</span></span><br><span class="line"><span class="comment">HPHP</span></span><br><span class="line"><span class="comment">HHPH</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3><span id="44-延申-滚动数组优化">4.4. 延申-滚动数组优化</span></h3><ul>
<li>在上述代码中 $f$ 数组是三维的，共占空间 $440MB$，如果题目限制为 $64MB$，那么肯定会 $MLE$，所以考虑如何压缩空间</li>
<li>可以用滚动数组优化，因为状态转移时，第 $i$ 行只与第 $i-1$ 行有关，所以第一维可以只开 $2$ 个空间</li>
</ul>
<h4><span id="441-数据结构">4.4.1. 数据结构</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>; <span class="comment">// 最大行数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>; <span class="comment">// 列数最大为10,则状态最大有2^10-1</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N]; <span class="comment">// 地图各行十进制表示数值</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 每行合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[M]; <span class="comment">// 同一行的合法状态集个数</span></span><br><span class="line"><span class="type">int</span> num[M]; <span class="comment">// 每个合法状态包含1的个数</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][M][M]; <span class="comment">// 2*1024*1024*4=8MB(int型4字节)</span></span><br></pre></td></tr></table></figure>



<h4><span id="442-状态计算部分修改">4.4.2. 状态计算部分修改</span></h4><ul>
<li>因为第一维空间只有 $2$ 了，所以每次使用第一维空间时要模 $2$，也可以通过位运算的方式，使用 $&amp;1$ 达到模 $2$ 的效果</li>
<li>另外，对于 $i-1&amp;1$ 的运算顺序是 $i-1$ 后再 $&amp;1$ ，位运算的优先级通常较低</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 计算的次数不变</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 2) 枚举第i行合法状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;cnt;a++) &#123;</span><br><span class="line">        <span class="comment">// 3) 枚举第i-1行合法状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;cnt;b++) &#123;</span><br><span class="line">            <span class="comment">// 4) 枚举第i-2行合法状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;cnt;c++) &#123;</span><br><span class="line">                <span class="comment">// 状态转移的条件</span></span><br><span class="line">                <span class="keyword">if</span>(!(s[a]&amp;s[b]) &amp;&amp; !(s[a]&amp;s[c]) &amp;&amp; !(s[b]&amp;s[c]) <span class="comment">// 任意两行不同列 </span></span><br><span class="line">                   &amp;&amp; (g[i]&amp;s[a])==s[a] &amp;&amp; (g[i<span class="number">-1</span>]&amp;s[b])==s[b]) <span class="comment">// 地图适配a,地图适配b</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// s[a]: 状态a的十进制表示,num[s[a]]: 取出本行状态为a时这一行的炮兵个数</span></span><br><span class="line">                    f[i&amp;<span class="number">1</span>][a][b]=max(f[i&amp;<span class="number">1</span>][a][b],f[i<span class="number">-1</span>&amp;<span class="number">1</span>][b][c]+num[s[a]]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 模拟跟踪状态转移过程</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;f[%d %d %d]=%d 由上一行 f[%d %d %d]=%d 加上本行炮兵个数 %d 转移而来\n&quot;</span>,</span><br><span class="line">                           i&amp;<span class="number">1</span>,a,b,f[i&amp;<span class="number">1</span>][a][b],i<span class="number">-1</span>&amp;<span class="number">1</span>,b,c,f[i<span class="number">-1</span>&amp;<span class="number">1</span>][b][c],num[s[a]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">2</span>&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 等价于枚举第n行a/b所有状态遍历得到的最大值 </span></span><br></pre></td></tr></table></figure>



<h4><span id="443-完整代码">4.4.3. 完整代码</span></h4><blockquote>
<p>这里直接引用董晓老师的代码了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>, M=<span class="number">1</span>&lt;&lt;<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;    <span class="comment">//行数,列数 </span></span><br><span class="line"><span class="type">int</span> g[N];   <span class="comment">//存储地图各行数值</span></span><br><span class="line"><span class="type">int</span> cnt;    <span class="comment">//一行的合法状态个数</span></span><br><span class="line"><span class="type">int</span> s[M];   <span class="comment">//一行的合法状态集 </span></span><br><span class="line"><span class="type">int</span> num[M]; <span class="comment">//每个合法状态包含1的个数 </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][M][M]; <span class="comment">//滚动数组 2*1024*1024*4 = 8MB</span></span><br><span class="line"><span class="comment">// f[i][a][b]表示已放好前i行，</span></span><br><span class="line"><span class="comment">// 第i行第a个状态，第i-1行第b个状态时，能放置的最大数量 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">      <span class="type">char</span> c; <span class="built_in">cin</span>&gt;&gt;c; </span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">&#x27;P&#x27;</span>) g[i]+=<span class="number">1</span>&lt;&lt;(m-j<span class="number">-1</span>); <span class="comment">//地图各行数值          </span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;m); i++)   <span class="comment">//枚举一行的所有状态 </span></span><br><span class="line">    <span class="keyword">if</span>(!(i&amp;i&gt;&gt;<span class="number">1</span>) &amp;&amp; !(i&amp;i&gt;&gt;<span class="number">2</span>))&#123; <span class="comment">//如果不存在11和101 </span></span><br><span class="line">      s[cnt++]=i;               <span class="comment">//保存一行的合法状态</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span><br><span class="line">      	num[i]+=(i&gt;&gt;j&amp;<span class="number">1</span>);         <span class="comment">//每个合法状态包含1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n+<span class="number">2</span>; i++) <span class="comment">//枚举行</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>; a&lt;cnt; a++)  <span class="comment">//枚举第i行合法状态</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>; b&lt;cnt; b++)  <span class="comment">//枚举第i-1行合法状态</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>; c&lt;cnt; c++)  <span class="comment">//枚举第i-2行合法状态</span></span><br><span class="line">    <span class="keyword">if</span>(!(s[a]&amp;s[b])&amp;&amp;!(s[a]&amp;s[c])&amp;&amp;!(s[b]&amp;s[c])</span><br><span class="line">      &amp;&amp;(g[i]&amp;s[a])==s[a]&amp;&amp;(g[i<span class="number">-1</span>]&amp;s[b])==s[b])</span><br><span class="line">        f[i&amp;<span class="number">1</span>][a][b]=max(f[i&amp;<span class="number">1</span>][a][b],f[i<span class="number">-1</span>&amp;<span class="number">1</span>][b][c]+num[s[a]]);</span><br><span class="line">      </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n+<span class="number">2</span>&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/2024/10/03/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="离散化">离散化</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E7%A6%BB%E6%95%A3%E5%8C%96">1. 离散化</a><ul>
<li><a href="#11-%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%88%86">1.1. 基于二分</a></li>
<li><a href="#12-%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8">1.2. 基于哈希表</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>上篇博客我们介绍了桶结构，假设现在给我们一个序列，数据范围是$[-10^9,10^9]$，显然我们是不能再用一个数组来存的</p>
</li>
<li><p>所以现在需要做的就是把大范围的数据映射到小范围数据，如：将$-123456789$映射到$5$，那么$a[5]&#x3D;-123456789$，统计的时候直接$cnt[3]++$即可，这便是离散化</p>
</li>
<li><p>怎么快速的映射，并且让映射的数字相互之间不冲突？<br><strong>排序加去重，使序列升序的排到数组中</strong></p>
</li>
<li><p>怎么找到映射后的数字在映射数组的下标？</p>
<p><strong>二分（已经排序了）、哈希表</strong></p>
</li>
</ul>
<h2><span id="1-离散化">1. 离散化</span></h2><blockquote>
<p> 题目链接：<a href="https://www.acwing.com/problem/content/804/">802. 区间和 - AcWing题库</a></p>
</blockquote>
<ul>
<li>该题目的数据范围很大，但是数据的总数又比较小，在数轴上非常稀疏，并且如果用枚举的方式求区间和必定会超时，所以非常适合用离散化的思想来解决</li>
</ul>
<h3><span id="11-基于二分">1.1. 基于二分</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 必须要用离散化</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+10</span>; <span class="comment">// max(n+2m)=3e5,假设每次输入的值都不同,最大也才3e5个空间</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n次在x位置上加c的操作,m次查询区间[l,r]所有数的和</span></span><br><span class="line"><span class="type">int</span> x,c;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 存储数字</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alls:需要离散化的数组,在插入和查询过程中把需要离散化的坐标添加进来</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储插入和查询操作中遇到的所有唯一坐标,然后排序用于索引</span></span><br><span class="line">vector&lt;PII&gt; add,query; <span class="comment">// 存储插入和查询操作的二元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找第一个大于等于x的下标,答案在左边,因此需要用二分的第二个模板(压缩右边界)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(alls[mid]&gt;=x) </span><br><span class="line">			r=mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l=mid<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r<span class="number">+1</span>; <span class="comment">// 返回的是顺序而不是下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;c);</span><br><span class="line">		add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x); <span class="comment">// 需要离散化的数值大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">		<span class="comment">// 区间也需要离散化</span></span><br><span class="line">		alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离散化:先排序后去重(因为可能有多个操作在同一个点上)</span></span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 去重,unique去除范围内的重复元素并返回新数组的末尾位置</span></span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 执行前n次插入操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:add) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">find</span>(item.first); <span class="comment">// 找到离散化后的下标</span></span><br><span class="line">		a[x]+=item.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用映射后的地址求一次前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) </span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="comment">// 执行后m次询问区间和操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:query) &#123;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">find</span>(item.first);</span><br><span class="line">		<span class="type">int</span> r=<span class="built_in">find</span>(item.second);</span><br><span class="line">		cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">7 5</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>



<h3><span id="12-基于哈希表">1.2. 基于哈希表</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 二分查询下标的时间是O(nlogn),而哈希表只需要O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x,c;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 所有需要离散化处理的数值</span></span><br><span class="line">vector&lt;PII&gt; add,query; <span class="comment">// 存储插入操作和区间和查询操作的向量</span></span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">// 哈希表(注意手写哈希表更快)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],s[N]; <span class="comment">// 映射后的数组和前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;c);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">		add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离散化</span></span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 映射到下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=alls.<span class="built_in">size</span>()<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		mp[alls[i]]=i<span class="number">+1</span>; <span class="comment">// 映射到从下标1开始</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行n次add操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:add) &#123;</span><br><span class="line">		<span class="type">int</span> x=mp[item.first];</span><br><span class="line">		a[x]+=item.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用映射后的值计算前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行m次查询操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:query) &#123;</span><br><span class="line">		l=mp[item.first];</span><br><span class="line">		r=mp[item.second];</span><br><span class="line">		cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索</title>
    <url>/2024/10/04/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="深度优先搜索">深度优先搜索</span></h1><!-- toc -->

<ul>
<li><a href="#1-dfs%E6%A8%A1%E6%9D%BF">1. DFS模板</a></li>
<li><a href="#2-%E8%A7%A6%E7%A2%B0%E8%8A%82%E7%82%B9%E6%97%B6%E6%9C%BA">2. 触碰节点时机</a><ul>
<li><a href="#21-%E5%A4%9A%E5%8F%89%E6%A0%91">2.1. 多叉树</a></li>
<li><a href="#22-%E4%BA%8C%E5%8F%89%E6%A0%91">2.2. 二叉树</a></li>
<li><a href="#23-%E4%B8%80%E6%9D%A1%E9%93%BE">2.3. 一条链</a></li>
<li><a href="#24-%E5%9B%BE">2.4. 图</a></li>
</ul>
</li>
<li><a href="#3-%E4%BE%8B%E9%A2%98">3. 例题</a><ul>
<li><a href="#31-%E6%B4%9B%E8%B0%B7-p1605-%E8%BF%B7%E5%AE%AB">3.1. 洛谷 P1605 迷宫</a></li>
<li><a href="#32-%E6%B4%9B%E8%B0%B7-p1644-%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98">3.2. 洛谷 P1644 跳马问题</a></li>
<li><a href="#33-%E6%B4%9B%E8%B0%B7-p1219-%E5%85%AB%E7%9A%87%E5%90%8E">3.3. 洛谷 P1219 八皇后</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>推荐视频：<a href="https://www.bilibili.com/video/BV1uS4y1i7j5/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B03 深搜 (DFS) 算法_bilibili</a></p>
</blockquote>
<h2><span id="1-dfs模板">1. DFS模板</span></h2><ul>
<li>深搜是通过系统栈实现的</li>
<li>递归调用的过程，系统自动通过栈去维护函数的状态空间</li>
<li>系统栈记录函数返回地址、局部变量、参数传递等</li>
<li>向下走，是压栈的过程；向上走，是出栈的过程</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322200028226.png" alt="image-20240322200028226"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// 存储每个节点可达节点的编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u:当前节点,fa:父节点,存储父节点是为了避免往回走</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 输出当前点的编号,dfs遍历顺序</span></span><br><span class="line">	<span class="comment">// 对于节点u的所有儿子节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>; <span class="comment">// 避免往回走,因为是有向边</span></span><br><span class="line">		dfs(v,u); <span class="comment">// 往下走</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 节点数和边数</span></span><br><span class="line"><span class="type">int</span> a,b; <span class="comment">// 起点和终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  8 7</span></span><br><span class="line"><span class="comment">  3 6</span></span><br><span class="line"><span class="comment">  8 6</span></span><br><span class="line"><span class="comment">  2 5</span></span><br><span class="line"><span class="comment">  5 6</span></span><br><span class="line"><span class="comment">  1 5</span></span><br><span class="line"><span class="comment">  5 7</span></span><br><span class="line"><span class="comment">  1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="comment">// 双向边</span></span><br><span class="line">		e[a].push_back(b);</span><br><span class="line">		e[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">// 从根节点1开始走,默认0是至高节点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-触碰节点时机">2. 触碰节点时机</span></h2><h3><span id="21-多叉树">2.1. 多叉树</span></h3><ul>
<li>1：入，2：下，3：回，4：离</li>
<li>深搜的计算过程：<ol>
<li>自顶向下，由父节点信息计算子节点信息，入和下，如对节点5，入代表父节点1向子节点5传递，下代表父节点5向子节点2、6、7传递</li>
<li>自底向上，由子节点信息计算父节点信息，回和离，如对节点5，回代表子节点2、6、7向父节点5传递，离代表子节点5向父节点1传递</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322203537204.png" alt="image-20240322203537204"></p>
<ul>
<li>如何理解？入是第一次遍历到该节点，所以直接输出编号即可；下是在遍历儿子节点过程中，由该节点第一次向下访问其下的儿子节点，随后对儿子节点递归到下一层dfs(v,u)（此时u作为v的父节点向下传递），当函数自然结束时，应该回溯，所以有回，回是该节点第一次向上访问其父节点，输出编号；循环结束后在节点u上的函数应该自然结束了，所以离开节点u，此时系统栈会回溯到5的父节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入%d\n&quot;</span>, u);</span><br><span class="line">	<span class="comment">// 下和回有多次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;下%d-&gt;%d\n&quot;</span>, u, v); <span class="comment">// 下</span></span><br><span class="line">		dfs2(v, u);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;回%d&lt;-%d\n&quot;</span>, u, v); <span class="comment">// 回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;离%d\n&quot;</span>, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-二叉树">2.2. 二叉树</span></h3><ul>
<li>1：先，2：中，3：后</li>
<li>在线段树就用到了类似的思想，其中先就对应的父节点将懒标记下传到儿子节点的pushdown函数，而遍历完两个儿子过后的“后”就类似于线段树中儿子节点上传更新父节点懒标记的pushup函数</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322205838629.png" alt="image-20240322205838629"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs3</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;先%d\n&quot;</span>,u);</span><br><span class="line">	dfs3(<span class="number">2</span>*u); <span class="comment">// 访问左孩子</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;中%d\n&quot;</span>,u);</span><br><span class="line">	dfs3(<span class="number">2</span>*u+<span class="number">1</span>); <span class="comment">// 访问右孩子</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;后%d\n&quot;</span>,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-一条链">2.3. 一条链</span></h3><ul>
<li>1：入，2：离</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322210326282.png" alt="image-20240322210326282"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 每个节点的下一个节点编号(类似链表)</span></span><br><span class="line"><span class="comment">// 一条链</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs4</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入%d\n&quot;</span>,u);</span><br><span class="line">	dfs4(ne[u]); <span class="comment">// 下一个相连的节点编号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;离%d\n&quot;</span>,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="24-图">2.4. 图</span></h3><ul>
<li>对图深搜会形成DFS树，因为图可能带环，所以需要开状态数组存储每个节点的访问状态，当访问状态为true时这条边就没必要走了，所以环中的某些边在dfs的过程中会被去掉，最终形成DFS树</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322210753384.png" alt="image-20240322210753384"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322210804032.png" alt="image-20240322210804032"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="comment">// 入</span></span><br><span class="line">	vis[u]=<span class="literal">true</span>; <span class="comment">// 当前节点被访问过</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]) &#123;</span><br><span class="line">		<span class="comment">// 下</span></span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>; <span class="comment">// 如果遍历过了就跳过</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d→%d\n&quot;</span>,u,v);</span><br><span class="line">		dfs(v);</span><br><span class="line">		<span class="comment">// 回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		e[a].push_back(b);</span><br><span class="line">		e[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-例题">3. 例题</span></h2><h3><span id="31-洛谷-p1605-迷宫">3.1. 洛谷 P1605 迷宫</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240323154212768.png" alt="image-20240323154212768"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 偏移量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,t; <span class="comment">// 地图行数列数,障碍数</span></span><br><span class="line"><span class="type">int</span> sx,sy,fx,fy,x,y; <span class="comment">// 起点和终点坐标以及障碍坐标</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 地图最大为5×5,O(2^25)实际会小很多</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前所在位置(x,y)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="comment">// 1)边界条件</span></span><br><span class="line">	<span class="keyword">if</span>(x==fx &amp;&amp; y==fy) &#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2)试探</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> xx=x+dx[i];</span><br><span class="line">		<span class="type">int</span> yy=y+dy[i];</span><br><span class="line">		<span class="comment">// 3)约束条件</span></span><br><span class="line">		<span class="keyword">if</span>(xx&lt;<span class="number">1</span> || yy&lt;<span class="number">1</span> || xx&gt;n || yy&gt;m) <span class="keyword">continue</span>; <span class="comment">// 越界处理</span></span><br><span class="line">		<span class="keyword">if</span>(g[xx][yy]==<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 有障碍或者访问过了</span></span><br><span class="line">		<span class="comment">// 能走,占据方案,递归到下一层</span></span><br><span class="line">		g[xx][yy]=<span class="number">1</span>;</span><br><span class="line">		dfs(xx,yy);</span><br><span class="line">		g[xx][yy]=<span class="number">0</span>; <span class="comment">// 4)回溯,找所有方案</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		g[x][y]=<span class="number">1</span>; <span class="comment">// 回溯时不会去掉标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 起点打标记</span></span><br><span class="line">	g[sx][sy]=<span class="number">1</span>; <span class="comment">// 提前打上的标记回溯时不会去掉,只有dfs中的会去掉</span></span><br><span class="line">	dfs(sx,sy);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-洛谷-p1644-跳马问题">3.2. 洛谷 P1644 跳马问题</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1644">P1644 跳马问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 马走日,原本8个方向,但是只能往右走,所以dy必须&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 终点</span></span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="comment">// 1)边界条件,到达终点</span></span><br><span class="line">	<span class="keyword">if</span>(x==n &amp;&amp; y==m) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2)试探</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> xx=x+dx[i];</span><br><span class="line">		<span class="type">int</span> yy=y+dy[i];</span><br><span class="line">		<span class="comment">// 3)约束条件</span></span><br><span class="line">		<span class="comment">// 越界处理</span></span><br><span class="line">		<span class="keyword">if</span>(xx&lt;<span class="number">0</span> || yy&lt;<span class="number">0</span> || xx&gt;n || yy&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 注意本题限制了方向只能往右走,所以不存在往回走的情况</span></span><br><span class="line">		<span class="comment">// 不需要状态数组</span></span><br><span class="line">		dfs(xx,yy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">// 注意右上角是(m,n),即行是n,列是m</span></span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="33-洛谷-p1219-八皇后">3.3. 洛谷 P1219 八皇后</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1219">P1219 USACO1.5 八皇后 Checker Challenge - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13</span>+<span class="number">5</span>; <span class="comment">// 棋盘最大范围</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 棋盘大小</span></span><br><span class="line"><span class="type">int</span> x[N]; <span class="comment">// x[i]:第i个皇后(第i行上的皇后)所在的列数</span></span><br><span class="line"><span class="comment">//int g[N][N]; // 地图,不需要地图嗷</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看第u个皇后是否能放,与前u-1个皇后作比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=u<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 剪枝函数,若不在同一列或同一对角线</span></span><br><span class="line">		<span class="keyword">if</span>(x[u]==x[i] || <span class="built_in">abs</span>(u-i)==<span class="built_in">abs</span>(x[u]-x[i])) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能放</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 能放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前在放第u个皇后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="comment">// 1)边界条件</span></span><br><span class="line">	<span class="keyword">if</span>(u&gt;n) &#123;</span><br><span class="line">		<span class="comment">// 皇后放完了,找到可行解了,直接输出</span></span><br><span class="line">		<span class="comment">// 只输出前3个</span></span><br><span class="line">		<span class="keyword">if</span>(++idx&lt;=<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;x[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2)试探,遍历所有可放的列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 3)如果能和前u-1行的皇后不冲突,则占据,向下递归</span></span><br><span class="line">		x[u]=i;</span><br><span class="line">		<span class="keyword">if</span>(place(u)) dfs(u+<span class="number">1</span>);</span><br><span class="line">		x[u]=<span class="number">0</span>; <span class="comment">// 4)释放,状态复原 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	dfs(<span class="number">1</span>); <span class="comment">// 从第一个皇后开始放</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数论</title>
    <url>/2024/10/07/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="简单数论">简单数论</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E8%B4%A8%E6%95%B0%E7%AD%9B">1. 质数筛</a></li>
<li><a href="#2-%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8B%86">2. 进制数拆</a></li>
<li><a href="#3-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0">3. 分解质因数</a></li>
<li><a href="#4-%E8%B4%A8%E6%95%B0%E7%AD%9B">4. 质数筛</a><ul>
<li><a href="#41-%E8%AF%95%E9%99%A4%E6%B3%95%E6%9E%9A%E4%B8%BE%E4%BC%98%E5%8C%96">4.1. 试除法（枚举优化）</a></li>
<li><a href="#42-%E6%AC%A7%E6%8B%89%E7%AD%9B">4.2. 欧拉筛</a></li>
</ul>
</li>
<li><a href="#5-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">5. 最大公约数与最小公倍数</a><ul>
<li><a href="#51-%E4%B8%A4%E4%B8%AA%E6%95%B0">5.1. 两个数</a></li>
<li><a href="#52-n%E4%B8%AA%E6%95%B0">5.2. n个数</a><ul>
<li><a href="#521-%E6%B1%82%E5%85%AC%E5%85%B1gcd">5.2.1. 求公共GCD</a></li>
<li><a href="#522-%E6%B1%82%E5%85%AC%E5%85%B1lcm">5.2.2. 求公共LCM</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-质数筛">1. 质数筛</span></h2><blockquote>
<p>先从最简单的质数开始吧，用优化遍历大小的朴素法或者欧拉筛(线性筛)可以完成，时间复杂度分别是O(n)和O(logn)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 最小的质数是2</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-进制数拆">2. 进制数拆</span></h2><blockquote>
<p>比如把任意一个正整数拆成二进制表现的形式，如7&#x3D;2的2次方+2的1次方+2的0次方</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n:待拆分十进制数</span></span><br><span class="line"><span class="comment">// m:拆分成多少进制的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>; <span class="comment">// 权</span></span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%m) &#123;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;<span class="string">&#x27;^&#x27;</span>&lt;&lt;s&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;<span class="built_in">pow</span>(m,s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			v.<span class="built_in">push_back</span>(<span class="built_in">pow</span>(m,s));</span><br><span class="line">		&#125;</span><br><span class="line">		n/=m;</span><br><span class="line">		s++;</span><br><span class="line">	&#125; cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		cout&lt;&lt;v[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=v.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;+&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-分解质因数">3. 分解质因数</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 分解质因数,一边找质因子一边将质因子的值和幂存储起来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[]:存储质因子,p[cnt]=x,第cnt个质因子是x</span></span><br><span class="line"><span class="comment">// g[]:存储质因子的幂,g[cnt]=y,第cnt个质因子是x,幂是y</span></span><br><span class="line"><span class="comment">// cnt:记录个数</span></span><br><span class="line"><span class="type">int</span> n,p[N],g[N],cnt; </span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime_fact</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i*i&lt;=n:枚举优化,从2开始,2是最小的质数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) cnt++; <span class="comment">// i是n的因子,cnt++</span></span><br><span class="line">		<span class="comment">// 计算i的幂</span></span><br><span class="line">		<span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			p[cnt]=i;</span><br><span class="line">			g[cnt]++; <span class="comment">// 次幂+1</span></span><br><span class="line">			n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分解完后如果n&gt;1,说明最终剩下的数字是一个质数,也单独算成质因数</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		p[++cnt]=n;</span><br><span class="line">		g[cnt]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">prime_fact</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;质因数: %d, 幂为:%d\n&quot;</span>,p[i],g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按唯一分解定理形式打印</span></span><br><span class="line">	cout&lt;&lt;n&lt;&lt;<span class="string">&quot;=&quot;</span>;</span><br><span class="line">	<span class="comment">// 遍历p,g数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="comment">// 打印g[i]次p[i]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=g[i];j++) &#123;</span><br><span class="line">			cout&lt;&lt;p[i];</span><br><span class="line">			<span class="keyword">if</span>(j!=g[i]) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(i!=cnt) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-质数筛">4. 质数筛</span></h2><h3><span id="41-试除法枚举优化">4.1. 试除法（枚举优化）</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要找从 $[1,10000]$ 中的所有质数，时间复杂度很高</li>
</ul>
<h3><span id="42-欧拉筛">4.2. 欧拉筛</span></h3><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230720102317937.png" alt="image-20230720102317937"></p>
<ul>
<li>算法思想：遍历到 $2$ 的时候，筛掉范围内所有 $2$ 的倍数，到 $3$ 的时候，筛掉所有 $3$ 的倍数，被筛掉的数会被标记为合数，合数不会进入到 $if$ 中扩展其倍数，相当于每个数只被遍历过一次，因而时间复杂度是 $O(n)$，欧拉筛也被称为线性筛</li>
<li>注意：如果计算 $[l,r]$ 之间出现的质数的个数？可以用前缀和的思想；<br>当 $n$ 过大时，$i×i$ 容易出现数组越界的错误，即可能 $RuntimeError$，此时要将线性筛中第二个 $for$ 中的$j&#x3D;i×i$ 改为 $j&#x3D;i+i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 欧拉筛</span></span><br><span class="line"><span class="comment">  先从最小的质数开始,每次在数据范围内将它的倍数标记为合数,那么留下的一定是素数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// f[i]:记录1~i中所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]:i的访问状态</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存放1~n中所有素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx:找素数迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i未放问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]<span class="number">+1</span>; <span class="comment">// 计算前缀和,维护数量</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 存储素数</span></span><br><span class="line">			<span class="comment">// 如果出现RE,将j=i*i改成j=i+i,这样就不会越界</span></span><br><span class="line">			<span class="comment">// 将i的倍数全部标记为合数,无需遍历</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">get_primes</span>(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1~%d 之间的质数分别是:&quot;</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=idx;i++) &#123;</span><br><span class="line">		cout&lt;&lt;p[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=idx) cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125; cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d~%d 之间存在的质数个数是:%d\n&quot;</span>,l,r,f[r]-f[l<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-最大公约数与最小公倍数">5. 最大公约数与最小公倍数</span></h2><blockquote>
<p>辗转相除法的时间复杂度：近似 $O(max(a,b))$</p>
</blockquote>
<h3><span id="51-两个数">5.1. 两个数</span></h3><ul>
<li>辗转相除法（欧几里得算法）求解最大公约数，最小公倍数就是两数的成绩除以最大公约数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求两个数的最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>(m%n) &#123;</span><br><span class="line">		r=m%n;</span><br><span class="line">		m=n;</span><br><span class="line">		n=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简单易背的方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两数的最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCM</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m*n/<span class="built_in">GCD</span>(m,n);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3><span id="52-n个数">5.2. n个数</span></h3><h4><span id="521-求公共gcd">5.2.1. 求公共GCD</span></h4><ul>
<li>求多个数的 $GCD$ 的思路是先求两个数的 $GCD$，再用这个结果与后续的每一个数分别求出 $GCD$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过循环求出公共GCD</span></span><br><span class="line">	<span class="type">int</span> res=a[<span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=gcd(res,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述求解方法的时间复杂度最坏是 $O(n^2)$，所以数据量比较大时，推荐用下述方法求解公共 $GCD$</li>
</ul>
<ol>
<li><p>对这组数从大到小排序</p>
</li>
<li><p>对每两个相邻的数 $A,B$（假设 $A$ 在前，故有 $A&gt;B$），如果 $A&#x3D;n×B$，则令 $A&#x3D;B$；否则令 $A&#x3D;A%B$</p>
</li>
<li><p>重复上述步骤，直到数组中每个数字都相同，此时这个数就为公共 $GCD$</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi_gcd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 直到所有数字相等</span></span><br><span class="line">	<span class="keyword">while</span>(a[<span class="number">1</span>]!=a[n]) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]%a[i+<span class="number">1</span>]==<span class="number">0</span>) a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> a[i]=a[i]%a[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="522-求公共lcm">5.2.2. 求公共LCM</span></h4><ul>
<li>同样的，我们可以对这组数据依次求最小公倍数，但是时间复杂度在最坏时达到 $O(n^2)$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi_lcm</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=res*a[i]/gcd(res,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来介绍质因子分解法，如：求 $10,12,4$ 的最小公倍数<br>$① 10&#x3D;2×5,\ ② 12&#x3D;2×3×3,\ ③4&#x3D;2×2$<br>可见，$2$ 在①②③式中都出现了， $3$ 只在②式中出现， $5$ 只在①式中出现<br>所以最小公倍数：$2^3×3^1×5^1&#x3D;60$，即对每个质因子的最高次幂做乘积得到的就是公共 $LCM$</p>
</li>
<li><p>用这种方法也可以避免遍历时做乘法超出数据类型所能表示的最大范围的情况</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 求公共LCM</span></span><br><span class="line"><span class="comment">  1) 先用欧拉筛预处理出数据范围内所有质数</span></span><br><span class="line"><span class="comment">  2) 将数组a中的数字依次分解质因数,按照欧拉筛筛出来的质数分解</span></span><br><span class="line"><span class="comment">  3) 用一个map记录所有质因子出现的最小次数(计算GCD)或最大次数(计算LCM)</span></span><br><span class="line"><span class="comment">  4) 枚举map中的质因子及其出现次数乘在一起算出GCD和LCM即可</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// f[i]:记录1~i中所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]:i的访问状态</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存放1~n中所有素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx:找素数迭代器 </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m_max; <span class="comment">// m_max[i]:对a[i]进行质因数分解后每个质因数的最大次数</span></span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i未放问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>; <span class="comment">// 计算前缀和,维护数量</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 存储素数</span></span><br><span class="line">			<span class="comment">// 如果出现RE,将j=i*i改成j=i+i,这样就不会越界</span></span><br><span class="line">			<span class="comment">// 将i的倍数全部标记为合数,无需遍历</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_facts</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 对于数组a中的每一个数字,分解质因数,计算在这n个数中的最大次数	</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=idx;j++) &#123;</span><br><span class="line">			<span class="comment">// 剪枝,如p[j]×p[j]&gt;a[i],说明p[j]不可能为a[i]质因数</span></span><br><span class="line">			<span class="keyword">if</span>(p[j]*p[j]&gt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 遍历质数数组</span></span><br><span class="line">			<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 分解后p[i]的次数</span></span><br><span class="line">			<span class="keyword">while</span>(a[i]%p[j]==<span class="number">0</span>) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				a[i]/=p[j];</span><br><span class="line">			&#125;</span><br><span class="line">			m_max[p[j]]=max(m_max[p[j]],cnt); <span class="comment">// 更新质因数p[i]出现的最大次数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 本身是质数</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			m_max[a[i]]=<span class="number">1</span>; <span class="comment">// 次幂只能为1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	get_primes(<span class="number">1000</span>);</span><br><span class="line">	get_facts(a);</span><br><span class="line">	<span class="comment">// 打印测试</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it=m_max.begin();it!=m_max.end();it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=it-&gt;second;i++) &#123;</span><br><span class="line">			res*=(it-&gt;first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 公共LCM</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">12 24 30 32 36 42</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">10080</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>线性DP</title>
    <url>/2024/11/07/%E7%BA%BF%E6%80%A7DP/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="线性dp">线性DP</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2">1. 数字三角形</a><ul>
<li><a href="#11-%E9%A1%BA%E6%8E%A8">1.1. 顺推</a></li>
<li><a href="#12-%E9%80%86%E6%8E%A8">1.2. 逆推</a></li>
</ul>
</li>
<li><a href="#2-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97">2. 最长上升子序列</a><ul>
<li><a href="#21-%E7%BA%BF%E6%80%A7dp%E5%81%9A%E6%B3%95">2.1. 线性DP做法</a></li>
<li><a href="#22-%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96">2.2. 二分优化</a></li>
</ul>
</li>
<li><a href="#3-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">3. 最长公共子序列</a></li>
<li><a href="#4-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2">4. 最长公共子串</a></li>
<li><a href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">5. 字符串编辑距离</a></li>
<li><a href="#6-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98">6. 股票问题</a><ul>
<li><a href="#61-%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93">6.1. 股票交易</a></li>
<li><a href="#62-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96-k-%E7%AC%94%E4%BA%A4%E6%98%93">6.2. 股票买卖 $k$ 笔交易</a><ul>
<li><a href="#621-%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84">6.2.1. 三维数组</a></li>
<li><a href="#622-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">6.2.2. 二维数组</a></li>
</ul>
</li>
<li><a href="#63-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F">6.3. 股票买卖含冷冻期</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-数字三角形">1. 数字三角形</span></h2><h3><span id="11-顺推">1.1. 顺推</span></h3><ul>
<li>顺推比较需要注意的问题就是边界问题，因为从上往下推每个元素会用到上方元素和左上方元素<ul>
<li>对于某一行的最后一个元素，那么上方的元素是没有被初始化的</li>
<li>对于某一行的第一个元素，那么左上方的元素是没有被初始化的</li>
<li>为了保证这两种情况一定不选择未被初始化的元素，所以首先把 $f$ 数组初始化为 $-INF$</li>
</ul>
</li>
<li>随后把 $f[1,1]$ 初始化为 $a[1,1]$，因为从第二行开始计算，这样计算出来的值就是正常值，最后从最后一行的出口中枚举找一个最大值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果顺推,每个元素应该考虑上方和左上方元素</span></span><br><span class="line">	<span class="comment">// 如果当前计算元素的[i,j]刚好i==j即最后一个时,则上方无元素,会遇到边界问题</span></span><br><span class="line">	<span class="comment">// 为了一定不选择这个边界,可以把其初始化为-INF(因为三角形中数字可能有负值)</span></span><br><span class="line">	<span class="comment">// 别忘了左上角,所以ij均从0开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i+<span class="number">1</span>;j++) &#123;</span><br><span class="line">			f[i][j]=-INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 从a[1][1]开始算,边界依然为-INF</span></span><br><span class="line">	<span class="comment">// 从第二行开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			f[i][j]=max(f[i<span class="number">-1</span>][j]+a[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=INT_MIN;</span><br><span class="line">	<span class="comment">// 对出口求最大值,即为最大路径数字和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ans=max(ans,f[n][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-逆推">1.2. 逆推</span></h3><ul>
<li>从上往下有五个出口，最终要用 $O(n)$ 的时间来判断谁的值更大，如果从下往上那么出口只有一个，无需比较；并且从下往上逆推不会遇到边界问题，用到的每个元素都刚好有初始值，可以手动模拟一下为什么没有边界问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 经典数字三角形</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 逆推,从下往上那么出口只有一个,注意元素只从下方和右下方来</span></span><br><span class="line">	<span class="comment">// 从下往上没有边界问题</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从倒数第二行开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="comment">// 每一行的元素的个数应该就是i</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			a[i][j]+=max(a[i+<span class="number">1</span>][j],a[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;a[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若需要输出路径，可以用 $b$ 数组 $memcpy$ 原二维数组，因为加和是直接在原数组上进行操作的，另外用 $p$ 表示前驱数组用来记录路径，在记录时只需要记录在列方向的偏移量即可，比如往右下则 $p[i,j]&#x3D;1$，往下 $p[i,j]&#x3D;0$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 经典数字三角形</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N][N]; <span class="comment">// 记录最大值路径</span></span><br><span class="line"><span class="type">int</span> b[N][N]; <span class="comment">// 备份数组,路径跟踪</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 逆推,从下往上那么出口只有一个,注意元素只从下方和右下方来</span></span><br><span class="line">	<span class="comment">// 从下往上没有边界问题</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝</span></span><br><span class="line">	<span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span> a); <span class="comment">// 从a拷到b</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从倒数第二行开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="comment">// 每一行的元素的个数应该就是i</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line"><span class="comment">//			a[i][j]+=max(a[i+1][j],a[i+1][j+1]);</span></span><br><span class="line">			<span class="keyword">if</span>(a[i+<span class="number">1</span>][j]&gt;=a[i+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">				a[i][j]+=a[i+<span class="number">1</span>][j];</span><br><span class="line">				p[i][j]=<span class="number">0</span>; <span class="comment">// 来自下方,y轴增量为0</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				a[i][j]+=a[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">				p[i][j]=<span class="number">1</span>; <span class="comment">// 来自右下,y轴增量为1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;a[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="comment">// 输出最大数的路径(行数一直增大,列数根据存储的增量变化)</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;b[i][j]&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">		j+=p[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;b[n][j];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-最长上升子序列">2. 最长上升子序列</span></h2><h3><span id="21-线性dp做法">2.1. 线性DP做法</span></h3><blockquote>
<p>时间复杂度：$O(n^2)$</p>
</blockquote>
<ul>
<li>如果不理解状态转移方程，可以 <a href="https://www.bilibili.com/video/BV1KK4y1e7t7/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E03 线性DP 最长上升子序列 bilibili</a> $4:00$ 起看该问题的模拟过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 以第i个元素结尾的LIS(最长上升子序列)长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=INT_MIN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		f[i]=<span class="number">1</span>; <span class="comment">// 所有元素起码可以以自身结尾</span></span><br><span class="line">		<span class="comment">// 遍历i之前的元素,如果比i小则可以拼接</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">			<span class="comment">// 不理解可以看视频中的模拟过程</span></span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i]) &#123;</span><br><span class="line">				f[i]=max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res=max(res,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-二分优化">2.2. 二分优化</span></h3><blockquote>
<p>时间复杂度：$O(nlog^n)$，因为二分查找是 $O(log^n)$</p>
</blockquote>
<ul>
<li>模拟过程在 <a href="https://www.bilibili.com/video/BV1Kp4y1e77H/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E04 线性DP 最长上升子序列 二分优化 bilibili</a> $6:15$ 起</li>
<li>唯一比较疑惑的地方在于，为什么是找到第一个大于等于 $a[i]$ 的元素做替换而不是大于呢？翻了一下评论区搞明白了，比如 ${1\  2\  6\  7\  2\  3}$ 的话，如果大于 $x$，那么序列中可能出现重复元素，最长上升子序列为 $1\ 2\ 2\ 3$，这样就不是严格单调递增的了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N]; <span class="comment">// 有序子序列</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历a中每一个元素,构造有序子序列</span></span><br><span class="line">	len=<span class="number">1</span>;</span><br><span class="line">	b[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 1)如果a中元素大于b中最后一个元素,则添加到末尾</span></span><br><span class="line">	<span class="comment">// 2)如果a中元素小于等于b中最后一个元素,则在b数组中找到第一个大于等于a的元素进行替换</span></span><br><span class="line">	<span class="comment">// 比如a[i]替换掉b[j]后,b[j]变小,则b[1...j]的结尾元素更小,则更可能续其他元素,使ILS更大</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;b[len]) &#123;</span><br><span class="line">			b[++len]=a[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 用二分找到第一个大于等于a[i]的元素(答案在左边,压缩右边界)</span></span><br><span class="line">			<span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">				<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(b[mid]&gt;=a[i]) &#123;</span><br><span class="line">					r=mid<span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					l=mid+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// l是答案</span></span><br><span class="line">			b[l]=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最终len的长度就是答案</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-最长公共子序列">3. 最长公共子序列</span></h2><ul>
<li>为什么没有 a[i]≠b[j]，且 a[i], b[j] 都不在公共子序列的情况？其实可以把这种情况归为第 2, 3 种情况之一</li>
<li>为什么没有 a[i]≠b[j]，且 a[i], b[j] 都不在公共子序列的情况？其实可以把这种情况归为第 2, 3 种情况之一</li>
</ul>
<p><img src="E:\Typora\图片\image-20240411143809881.png" alt="image-20240411143809881"></p>
<ul>
<li>一边 $dp$ 一边打标记记录状态转移，其中从左上方转移过来的元素即为 $LCS$ 中的公共元素</li>
</ul>
<p><img src="E:\Typora\图片\image-20240411144744745.png" alt="image-20240411144744745"></p>
<ul>
<li>只要理解了状态转移方程，代码就很简单</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>; <span class="comment">// 字符串最大长度</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:序列a[1...i]和b[1...j]的最长公共子序列的长度(LCS)</span></span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a+<span class="number">1</span>&gt;&gt;b+<span class="number">1</span>; <span class="comment">// 从下标1开始存储</span></span><br><span class="line">	n=<span class="built_in">strlen</span>(a+<span class="number">1</span>); <span class="comment">// 起始位置是a+1</span></span><br><span class="line">	m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 初始化 f[0][j]=0,f[i][0]=0,即i和j中有未指向任意元素的指针存在时</span></span><br><span class="line">    <span class="comment">// 但是全局变量本身初始化为0,所以无需初始化</span></span><br><span class="line">    <span class="comment">// 枚举字符串a</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="comment">// 枚举字符串b</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[j]) &#123;</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				f[i][j]=max(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要带路径输出呢？同理，开一个数组 $p$ 用来记录取得 $LCS$ 的路径，注意，只有来自左上方的元素是 $LCS$ 中的元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>; <span class="comment">// 字符串最大长度</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:序列a[1...i]和b[1...j]的最长公共子序列的长度(LCS)</span></span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> p[N][N]; <span class="comment">// 前驱数组</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a+<span class="number">1</span>&gt;&gt;b+<span class="number">1</span>; <span class="comment">// 从下标1开始存储</span></span><br><span class="line">	n=<span class="built_in">strlen</span>(a+<span class="number">1</span>); <span class="comment">// 起始位置是a+1</span></span><br><span class="line">	m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 初始化 f[0][j]=0,f[i][0]=0,即i和j中有未指向任意元素的指针存在时</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[j]) &#123;</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">				p[i][j]=<span class="number">1</span>; <span class="comment">// 来自↖</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f[i<span class="number">-1</span>][j]&gt;f[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">				p[i][j]=<span class="number">2</span>; <span class="comment">// 来自←</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">				p[i][j]=<span class="number">3</span>; <span class="comment">// 来自↑</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 最长长度</span></span><br><span class="line">	<span class="type">int</span> i=n,j=m,k=f[n][m];</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; path;</span><br><span class="line">	<span class="comment">// i或j中任意一个元素=0时退出</span></span><br><span class="line">	<span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 左上方</span></span><br><span class="line">		<span class="keyword">if</span>(p[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">			path.push_back(a[i]); <span class="comment">// LCS中</span></span><br><span class="line">			i--,j--;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// 上方</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p[i][j]==<span class="number">2</span>) &#123;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左方</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(path.begin(),path.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:path) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-最长公共子串">4. 最长公共子串</span></h2><ul>
<li>这一题和上一题有什么区别呢？序列可以是不连续的，但是串一定是连续的，区别就在此</li>
<li>最长公共子序列中 $f[i,j]$ 表示序列 $a[1…i]$ 和 $b[1…j]$ 的最长公共子序列的长度</li>
<li>最长公共子串中 $f[i,j]$ 表示以 $a[i]$ 和 $b[j]$ 为结尾的公共子串的长度</li>
</ul>
<p><img src="E:\Typora\图片\image-20240411161150378.png" alt="image-20240411161150378"></p>
<p><img src="E:\Typora\图片\image-20240411164021914.png" alt="image-20240411164021914"></p>
<ul>
<li>则可以得到状态转移方程<ul>
<li>若 $a[i]&#x3D;&#x3D;b[j]$，构成公共子串，$f[i,j]&#x3D;f[i-1,j-1]+1$</li>
<li>若 $a[i]!&#x3D;b[j]$，不能构成公共子串，$f[i,j]&#x3D;0$（为什么不记录为最大值呢？因为串必须是连续的）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// 以a[i]和b[j]结尾的最长公共子串的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a+<span class="number">1</span>&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line">	n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">	m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 无需初始化,全局变量</span></span><br><span class="line">    <span class="type">int</span> len=INT_MIN; <span class="comment">// 最长公共子串长度 </span></span><br><span class="line">    <span class="type">int</span> st=<span class="number">0</span>; <span class="comment">// 起始点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// 必须要连续才相加</span></span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[j]) &#123;</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				f[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保存第一个最长公共子串</span></span><br><span class="line">            <span class="keyword">if</span>(f[i][j]&gt;=len) &#123;</span><br><span class="line">                len=f[i][j];</span><br><span class="line">                st=i-len+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// ans=max(ans,f[i][j]);</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以最后一个元素结尾的不一定是最长公共子串的长度</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=st;i&lt;=st+len<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-字符串编辑距离">5. 字符串编辑距离</span></h2><ul>
<li>$f[i,j]$ 表示从 $a[1…i]$ 变成 $b[1…j]$ 的编辑距离</li>
<li>若 $a[i]&#x3D;b[j]$，$f[i,j]&#x3D;f[i-1,j-1]$ ：因为新位置 $i$ 和 $j$ 的元素是相等的，无需编辑转移</li>
<li>若 $a[i]!&#x3D;b[j]$<ul>
<li>修改，即 $a$ 中前 $i-1$ 项 和 $b$ 中前 $j-1$ 项已然相等，只需要把最后一项修改为 $b[j]$ 即可，所以有 $f[i,j]&#x3D;f[i-1,j-1]+1$</li>
<li>插入，即 $a$ 中前 $i$ 项和 $b$ 中前 $j-1$ 项相等，只需要再插入一项 $b[j]$ 即可，所以有 $f[i,j]&#x3D;f[i,j-1]+1$</li>
<li>删除，即 $a$ 中前 $i-1$ 项和 $b$ 中前 $j$ 项相等，但是多了一项，所以有 $f[i,j]&#x3D;f[i-1,j]+1$</li>
<li>由于属性是取最小值，所以三者中取 $min$ 即可</li>
</ul>
</li>
</ul>
<p><img src="E:\Typora\图片\image-20240411171937474.png" alt="image-20240411171937474"></p>
<ul>
<li>二维数组的常规做法如下，关于滚动数组优化这里不做解释，因为自己都搞得不是很清楚</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a+<span class="number">1</span>&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line">	n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">	m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 从a[1...i]变成空串,需要是删除i次</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		f[i][<span class="number">0</span>]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从空串变成b[1...j],需要添加j次</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">		f[<span class="number">0</span>][j]=j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="comment">// 如果记录一下状态转移就可以输出变化过程</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// 末尾相等,无需添加</span></span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[i]) &#123;</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				f[i][j]=min(f[i<span class="number">-1</span>][j],min(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>; <span class="comment">// 三种操作的最小值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="6-股票问题">6. 股票问题</span></h2><h3><span id="61-股票交易">6.1. 股票交易</span></h3><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1iK4y177jT/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E22 线性DP 股票买卖_bilibili</a></p>
</blockquote>
<ul>
<li><p>状态表示：</p>
<ul>
<li>$f[i][0]$：第 $i$ 天手中无票时获取的最大利润</li>
<li>$f[i][1]$：第 $i$ 天手中有票时获取的最大利润</li>
</ul>
</li>
<li><p>状态属性：$max$</p>
</li>
<li><p>状态转移：</p>
<ul>
<li><p>当前手中无票，可能是上一个状态未买入股票，故有 $f[i][0]&#x3D;f[i-1][0]$；也可以前一天有票，但是卖出了，此时收入为 $f[i][0]&#x3D;f[i-1][1]+w[i]$，所以无票时状态转移方程为：$f[i][0]&#x3D;max(f[i-1][0],f[i-1][1]+w[i])$</p>
</li>
<li><p>当前手中有票，可能是上一个状态手中本来有票，但未卖出股票，故有 $f[i][1]&#x3D;f[i-1][1]$；也可以前一天无票，但是买入了，此时收入为 $f[i][1]&#x3D;f[i-1][0]-w[i]$，为何是减呢？因为买入嘛，我们的收益减去 $w[i]$，所以有票时状态转移方程为：$f[i][1]&#x3D;max(f[i-1][1],f[i-1][0]-w[i])$</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426153152625.png" alt="image-20240426153152625"></p>
<ul>
<li><p>边界初值：</p>
<ul>
<li>第 $1$ 天无票：$f[1][0]&#x3D;0$</li>
<li>第 $1$ 天有票：$f[1][1]&#x3D;-w[i]$</li>
</ul>
</li>
<li><p>目标值：</p>
<ul>
<li>第 $n$ 天事件结束时手上无票：$f[n][0]$</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>]; <span class="comment">// f[i][0]:第i天手上没有股票的最大利润,f[i][1]:第i天手上有股票</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;w[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>]=-w[<span class="number">1</span>]; <span class="comment">// 买下</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 第i天无股票,可能是第i-1天无股票或者有股票卖了转移来的</span></span><br><span class="line">		<span class="comment">// 第i天有股票,可能是第i-1天有股票没卖或者无股票才买来的</span></span><br><span class="line">		f[i][<span class="number">0</span>]=max(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]+w[i]);</span><br><span class="line">		f[i][<span class="number">1</span>]=max(f[i<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">0</span>]-w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][<span class="number">0</span>]; <span class="comment">// 第n天无股票一定最大</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="62-股票买卖-k-笔交易">6.2. 股票买卖 $k$ 笔交易</span></h3><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1ka4y1s7ER/?spm_id_from=333.788.recommend_more_video.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E23 线性DP 股票买卖K笔交易_bilibili</a></p>
</blockquote>
<h4><span id="621-三维数组">6.2.1. 三维数组</span></h4><ul>
<li><p>状态表示：</p>
<ul>
<li>$f[i][j][0]$：前 $i$ 天已经进行了 $j$ 次交易，当前手中无票，能获取的最大利润</li>
<li>$f[i][j][1]$：前 $i$ 天已经进行了 $j$ 次交易，当前手中有票，能获取的最大利润</li>
</ul>
</li>
<li><p>状态属性：$max$</p>
</li>
<li><p>状态转移：</p>
<ul>
<li><p>当前手中无票，可能昨天也无票，并且没有买入，故有 $f[i][j][0]&#x3D;f[i-1][j][0]$；也可能前一天有票，但是卖出了，正好完成了第 $j$ 交易，此时收入为 $f[i][j][0]&#x3D;f[i-1][j][1]+w[i]$，所以无票时状态转移方程为：$f[i][0]&#x3D;max(f[i-1][j][0],f[i][j][0]&#x3D;f[i-1][j][1]+w[i])$</p>
</li>
<li><p>当前手中有票，可能是上一个状态手中本来有票，但未卖出股票，故有 $f[i][j][1]&#x3D;f[i-1][j][1]$；也可以前一天无票，但是买入了，那么说明前 $j-1$ 次交易已完成，当前正要计算的是第 $j$ 次交易，故有 $f[i][j][1]&#x3D;f[i-1][j-1][0]-w[i]$，所以有票时状态转移方程为：$f[i][j][1]&#x3D;max(f[i-1][j][1],f[i-1][j-1][0]-w[i])$</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426155643592.png" alt="image-20240426155643592"></p>
<ul>
<li><p>边界初值：</p>
<ul>
<li>第 $0$ 天无票：$f[0][j][0]&#x3D;0$，第 $0$ 天有票：$f[0][j][1]&#x3D;-1e6$（该状态非法，且我们要找最大值，所以赋一个极小值）</li>
<li>每一天还未进行交易时：$f[i][0][0]&#x3D;0$</li>
</ul>
</li>
<li><p>目标值：</p>
<ul>
<li>第 $n$ 天事件结束时刚好进行了 $k$ 次交易且手上无票：$f[n][k][0]$</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">2</span>; <span class="comment">// 最大天数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e2</span>+<span class="number">2</span>; <span class="comment">// 最大交易次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 每天股票的价格</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 天数和交易次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;w[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化第0天的情况</span></span><br><span class="line">	<span class="comment">// 合法则赋可取的有限值</span></span><br><span class="line">	<span class="comment">// 非法则赋负无穷(找最大值)或正无穷(找最小值)</span></span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="comment">// 第0天,手中无票,初值为0,手中有票,状态非法,负无穷(为找最大值)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) f[<span class="number">0</span>][j][<span class="number">1</span>]=<span class="number">-1e6</span>;</span><br><span class="line">	<span class="comment">// 第0笔,f[i][0][0]=0, 已经memset了</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 三维数组!!!</span></span><br><span class="line">	<span class="comment">// 第1~n天,交易次数为1~k</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">			<span class="comment">// 1) 前一天没买股票</span></span><br><span class="line">			<span class="comment">// 2) 前一天卖了股票,完成第j次交易</span></span><br><span class="line">			f[i][j][<span class="number">0</span>]=max(f[i<span class="number">-1</span>][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j][<span class="number">1</span>]+w[i]);</span><br><span class="line">			<span class="comment">// 1) 前一天没卖股票</span></span><br><span class="line">			<span class="comment">// 2) 前一天买了股票,说明前一天已经完成了前j-1次交易,今天买股票处在第j次交易之中</span></span><br><span class="line">			f[i][j][<span class="number">1</span>]=max(f[i<span class="number">-1</span>][j][<span class="number">1</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-w[i]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][k][<span class="number">0</span>]; <span class="comment">// 第n天完成k次交易且手中无票</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="622-二维数组">6.2.2. 二维数组</span></h4><ul>
<li>观察三维数组的代码我们会发现，当前状态只与上一层状态有关，所以可以类似于 $01$ 背包那样优化掉一维，直接把第一维去掉即可，那为什么不用像 $01$ 背包那样逆序遍历背包容量呢？</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426161021747.png" alt="image-20240426161021747"></p>
<ul>
<li>继续观察三维时的状态转移方程，会发现 $f[i][j][0]$ 和 $f[i][j][1]$ 都独立的用上一层的两个状态来进行更新，二者之间没有相互影响，所以无论是逆序还是正序都不会出错</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426161330033.png" alt="image-20240426161330033"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">2</span>; <span class="comment">// 最大天数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e2</span>+<span class="number">2</span>; <span class="comment">// 最大交易次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ff[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 每天股票的价格</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 天数和交易次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;w[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 二维滚动数组优化!!!注意听为什么不用逆序</span></span><br><span class="line">	<span class="comment">// 直接去掉第一维即可 且不逆序</span></span><br><span class="line">	<span class="comment">// 关于为什么直接去掉一维就可以了我也不得而知啊啊啊 dp有点难</span></span><br><span class="line">	<span class="built_in">memset</span>(ff,<span class="number">0</span>,<span class="keyword">sizeof</span> ff);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++) ff[j][<span class="number">1</span>]=<span class="number">-1e6</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++) &#123;</span><br><span class="line">			ff[j][<span class="number">0</span>]=max(ff[j][<span class="number">0</span>],ff[j][<span class="number">1</span>]+w[i]);</span><br><span class="line">			ff[j][<span class="number">1</span>]=max(ff[j][<span class="number">1</span>],ff[j<span class="number">-1</span>][<span class="number">0</span>]-w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ff[k][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="63-股票买卖含冷冻期">6.3. 股票买卖含冷冻期</span></h3><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV15v411r7WD/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">E24 线性DP 股票买卖含冷冻期 bilibili</a></p>
</blockquote>
<ul>
<li><p>引入了一天的冷冻期之后，我们在状态转移时就不能单单从昨天来看，要引入新一天：前天</p>
</li>
<li><p>状态表示：</p>
<ul>
<li>$f[i][0]$：第 $i$ 天手中无票时获取的最大利润</li>
<li>$f[i][1]$：第 $i$ 天手中有票时获取的最大利润</li>
</ul>
</li>
<li><p>状态属性：$max$</p>
</li>
<li><p>状态转移：</p>
<ul>
<li><p>当前手中无票，可能是上一个状态未买入股票，故有 $f[i][0]&#x3D;f[i-1][0]$；也可以前一天有票，但是卖出了，此时收入为 $f[i][0]&#x3D;f[i-1][1]+w[i]$，所以无票时状态转移方程为：$f[i][0]&#x3D;max(f[i-1][0],f[i-1][1]+w[i])$</p>
</li>
<li><p>当前手中有票，可能是上一个状态手中本来有票，但未卖出股票，故有 $f[i][1]&#x3D;f[i-1][1]$；也可能是之前无票，但是买入了股票，注意此时只能从 $i-2$ （前天）的状态转移，因为如果昨天恰好是卖出股票的第一天，就出大问题了，此时收入为 $f[i][1]&#x3D;f[i-2][0]-w[i]$，所以有票时状态转移方程为：$f[i][1]&#x3D;max(f[i-1][1],f[i-2][0]-w[i])$</p>
</li>
<li><p>那么这个状态转移方程就和第一个问题的方程非常非常类似了</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240426155643592.png" alt="image-20240426155643592"></p>
<ul>
<li><p>边界初值：</p>
<ul>
<li>为何要从第 $0$ 天开始判断？因为我们引入了前天的概念</li>
<li>第 $0$ 天无票：$f[0][0]&#x3D;0$</li>
<li>第 $0$ 天有票：$f[0][1]&#x3D;-1e6$，状态非法，又因为找最大值所以给极小值（$DP$ 问题初始化技巧）</li>
</ul>
</li>
<li><p>目标值：</p>
<ul>
<li>第 $n$ 天事件结束时手上无票：$f[n][0]$</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 加了一个限制,卖出股票后第二天不能买入股票(1天冷冻期)</span></span><br><span class="line"><span class="comment">// 所以需要考虑的状态有前天,昨天和今天</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>]; <span class="comment">// f[i][0]:第i天手上无票,f[i][1]:第i天手上有票</span></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">5 2 6 1 3 4 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;w[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1)初始化</span></span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">// 第0天手上无票自然为0,dp入口</span></span><br><span class="line">	f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">-1e9</span>; <span class="comment">// 第0天手上有票为非法状态,因为找最大值所以初始化为负无穷</span></span><br><span class="line">	<span class="comment">// 2)dp</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 第i天无票,前一天本身无票或前一天卖出</span></span><br><span class="line">		f[i][<span class="number">0</span>]=max(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]+w[i]);</span><br><span class="line">		<span class="comment">// 第i天有票,前一天有票未卖出或前两天买入(有冷冻期存在)</span></span><br><span class="line">		f[i][<span class="number">1</span>]=max(f[i<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-2</span>][<span class="number">0</span>]-w[i]);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;天:&quot;</span>&lt;&lt;<span class="string">&quot; f[0]=&quot;</span>&lt;&lt;f[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot; ,f[1]=&quot;</span>&lt;&lt;f[i][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>动态规划</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>背包DP</title>
    <url>/2024/11/07/%E8%83%8C%E5%8C%85DP/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="背包dp">背包DP</span></h1><!-- toc -->

<ul>
<li><a href="#1-01%E8%83%8C%E5%8C%85">1. 01背包</a><ul>
<li><a href="#11-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">1.1. 二维数组</a></li>
<li><a href="#12-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">1.2. 一维数组</a></li>
</ul>
</li>
<li><a href="#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">2. 完全背包</a><ul>
<li><a href="#21-%E6%9C%B4%E7%B4%A0%E5%81%9A%E6%B3%95">2.1. 朴素做法</a></li>
<li><a href="#22-%E5%85%AC%E5%BC%8F%E4%BC%98%E5%8C%96">2.2. 公式优化</a></li>
<li><a href="#23-%E5%86%8D%E4%BC%98%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">2.3. 再优化一维数组</a></li>
</ul>
</li>
<li><a href="#3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85">3. 多重背包</a><ul>
<li><a href="#31-%E6%9C%B4%E7%B4%A0%E5%81%9A%E6%B3%95">3.1. 朴素做法</a></li>
<li><a href="#32-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96">3.2. 二进制优化</a></li>
<li><a href="#33-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96">3.3. 单调队列优化</a></li>
</ul>
</li>
<li><a href="#4-%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85">4. 混合背包</a></li>
<li><a href="#5-%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85">5. 二维费用背包</a></li>
<li><a href="#6-%E5%B8%A6%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85">6. 带依赖的背包</a></li>
<li><a href="#7-%E8%83%8C%E5%8C%85%E6%B1%82%E6%96%B9%E6%A1%88%E6%95%B0">7. 背包求方案数</a></li>
<li><a href="#8-%E8%83%8C%E5%8C%85%E6%B1%82%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88">8. 背包求具体方案</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-01背包">1. 01背包</span></h2><h3><span id="11-二维数组">1.1. 二维数组</span></h3><blockquote>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(n^2)$</p>
</blockquote>
<ul>
<li>非常熟悉和基础，没什么可讲的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]); <span class="comment">// v:重量,w:价值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 枚举背包容量</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="comment">// 如果能拿物品i</span></span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]); <span class="comment">// v:体积,w:价值</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 当取n个物品时最大总价值,其实也就是f[n][m]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) res=max(res,f[n][i]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-一维数组">1.2. 一维数组</span></h3><blockquote>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(n)$</p>
</blockquote>
<ul>
<li>因为 $f[i][j]$ 只与 $f[i-1][j]$ 、$f[i-1][j-v[i]]+w[i]$ 有关，即只与上一个状态（上一次选择）有关，那么我们只需要开一个一维数组记录上一次选择即可，这个数组名为滚动数组</li>
<li>由于滚动数组已经表示了上一次选择的状态，所以代码 $f[i][j]&#x3D;f[i-1][j]$ 可以去掉</li>
<li>枚举背包体积时必须从大到小，原因已经在代码中解释，如果还是 $for(int\ j&#x3D;0;j&lt;&#x3D;m;j++)$ ，那么用到的实际上还是 $f[i]$ 这个状态而不是 $f[i-1]$ 这个状态</li>
<li>如果把所有的 $f[i]$ 都初始化为 $0$，那么 $f[m]$ 表示的是当背包体积 $&lt;&#x3D;m$ 时的最大价值是多少；如果只把 $f[0]$ 初始化为 $0$ ，而其他初始化为 $-INF$，那么 $f[m]$ 表示的是体积刚好等于 $m$ 时的最大价值，所以全部初始化为 $0$ 的话 $f[m]$ 就是答案</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>; <span class="comment">// 最大物品数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e3</span>+<span class="number">5</span>; <span class="comment">// 最大容量</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">// f[i]:物品容量为i时的背包最大容量</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 因为f[i][j]只与f[i-1][j]/f[i-1][j-v[i]]+w[i],只与上一个状态有关</span></span><br><span class="line">		<span class="comment">// 所以二维数组中有很多空间被浪费,计算完就可以丢掉了</span></span><br><span class="line">		<span class="comment">// 所以用滚动数组,但是在枚举背包体积的时候必须从大到小排序,若顺序的话再用到上一个状态时就已经被更新过了</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--) </span><br><span class="line">			f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) res=max(res,f[i]);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-完全背包">2. 完全背包</span></h2><h3><span id="21-朴素做法">2.1. 朴素做法</span></h3><blockquote>
<p>时间复杂度：$O(n^3)$，空间复杂度：$O(n^2)$</p>
</blockquote>
<ul>
<li>时间复杂度和空间复杂度都较高，手动枚举每个物品可选择数量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e3</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 朴素做法,枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 枚举背包容量</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// 枚举物品可挑选数量</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++) &#123;</span><br><span class="line">				f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]*k]+w[i]*k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-公式优化">2.2. 公式优化</span></h3><blockquote>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(n)$</p>
</blockquote>
<ul>
<li>$f[i,j]&#x3D;max(f[i-1,j],f[i-1,j-v]+w,\ f[i-1,j-2v]+2w,\ f[i-1,j-3v]+3v,\ …)$，①$f[i,j-v]&#x3D;max(f[i-1,j-v],f[i-1,j-2v]+w,\ f[i-1,j-3v]+2w,\ f[i-1,j-4v]+3w,\ …)$②，</li>
<li>可以看出②式是①式第二项起 $+w$ 的结果，所以 $f[i,j]&#x3D;max(f[i-1,j],\ f[i,j-v]+w)$，即转移时与上一个状态无关，所以我们就可以顺序枚举物品容量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="comment">// 至少能装下一个</span></span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); <span class="comment">// 和01背包的区别就在于可以与当前状态有关</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-再优化一维数组">2.3. 再优化一维数组</span></h3><blockquote>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(n)$</p>
</blockquote>
<ul>
<li>注意注释中是如何分析当 $f$ 数组是一维时状态转移的是当前状态还是上一次的状态</li>
<li>因为滚动数组本身代表上一次的状态，所以 $f[i,j]&#x3D;f[i-1,j]$ 直接优化成 $f[j]&#x3D;f[j]$，无意义，所以不用写</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// f[i][j]=f[i-1][j]直接删掉一维,即f[j]=f[j](一维滚动数组直接代表上一次的状态,所以不需要这句代码)</span></span><br><span class="line">		<span class="comment">// j是从小到大枚举的</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// j-v[i]是&lt;j的,所以算f[j]的时候f[j-v[i]]已经被算过了,所以是第i层的f[i][j-v[i]]</span></span><br><span class="line">			f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-多重背包">3. 多重背包</span></h2><h3><span id="31-朴素做法">3.1. 朴素做法</span></h3><blockquote>
<p>时间复杂度：$O(n^3)$，空间复杂度：$O(n^2)$</p>
</blockquote>
<ul>
<li>类似于完全背包的朴素做法，直接第三层去枚举物品的个数，不过多了一个限制条件，$k&lt;&#x3D;s[i]$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v[i],&amp;w[i],&amp;s[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 枚举物品</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// 能拿的个数从0~s[i],且k*v[i]能被背包装下</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=s[i] &amp;&amp; k*v[i]&lt;=j;k++) &#123;</span><br><span class="line">				f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-二进制优化">3.2. 二进制优化</span></h3><blockquote>
<p>时间复杂度：$O(n^2log^n)$，空间复杂度：$O(n)$</p>
</blockquote>
<ul>
<li><p>如果按照类似于完全背包从状态转移方程式入手的角度来优化是不可行的，因为完全背包问题不会多最后一项出来，多了一个 $if$ 的判定条件，最后一项会因为超出了 $j$ 而被舍去</p>
</li>
<li><p>如何优化呢？若 $s&#x3D;1023$，那么 $1023$ 能由其 $sum(2^n)&lt;&#x3D;1023$ 的这 $n$ 个 $2$ 的指数组成（$n&#x3D;9$），把 $1023$ 个物品当作是 $1023$ 次 $01$ 背包，再通过二进制优化的方式把从枚举 $1023$ 次转换为只需要枚举 $9$ 次（倍增法思想）</p>
</li>
<li><p>比如 $s&#x3D;200$，$\sum_{i&#x3D;1}^n\ 2^i&lt;&#x3D;200$ 可得 ${1,\ 2,\ 4,\ 8,\ 16,\ 32,\ 64}$，这几个数字之和为 $127$，则只需要再来一个 $73$ 就可以凑出 $[0,200]$ 的数字；即对于任意一个 $s$ ，我们可以凑成 ${1,\ 2,\ 4,\ 8,\ …,\ 2^k,\ c}$，其中 $c&lt;2^{k+1}$</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">5</span>; <span class="comment">// 1000*log(2000),2w4左右</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;s);</span><br><span class="line">		<span class="type">int</span> k=<span class="number">1</span>; <span class="comment">// 从2^0开始,每组初始物品数</span></span><br><span class="line">		<span class="keyword">while</span>(k&lt;=s) &#123;</span><br><span class="line">			<span class="comment">// 每次把k个第i个物品打包在一起</span></span><br><span class="line">			cnt++; <span class="comment">// 编号++</span></span><br><span class="line">			v[cnt]=a*k;</span><br><span class="line">			w[cnt]=b*k;</span><br><span class="line">			s-=k;</span><br><span class="line">			k*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 补常数</span></span><br><span class="line">		<span class="keyword">if</span>(s&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			cnt++; <span class="comment">// 第i个物品的最后一次分组</span></span><br><span class="line">			v[cnt]=a*s;</span><br><span class="line">			w[cnt]=b*s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n=cnt; <span class="comment">// 物品个数变成总的打包数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 至少能拿一个物品,所以j&gt;=v[i]</span></span><br><span class="line">		<span class="comment">// 从大到小枚举</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--) &#123;</span><br><span class="line">			f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="33-单调队列优化">3.3. 单调队列优化</span></h3><ul>
<li>看不懂，溜了溜了</li>
</ul>
<h2><span id="4-混合背包">4. 混合背包</span></h2><blockquote>
<p>时间复杂度：$O(n^2log^2)$，空间复杂度：$O(n)$</p>
</blockquote>
<ul>
<li>关键点在于将多重背包二进制优化后变成 $01$背包和 $01$背包一起处理，完全背包单独处理，其实就是混合考了几种背包的处理方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 三种物品三种放法,运用每组问题的解题思路即可</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> kind; <span class="comment">// 01?完全?多重?</span></span><br><span class="line">	<span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Thing&gt; things;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> v,w,s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v,&amp;w,&amp;s);</span><br><span class="line">		<span class="comment">// 01背包问题</span></span><br><span class="line">		<span class="keyword">if</span>(s&lt;<span class="number">0</span>) things.push_back(&#123;<span class="number">-1</span>,v,w&#125;);</span><br><span class="line">		<span class="comment">// 完全背包问题</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="number">0</span>) things.push_back(&#123;<span class="number">0</span>,v,w&#125;);</span><br><span class="line">		<span class="comment">// 多重背包问题</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>) &#123;</span><br><span class="line">				s-=k;</span><br><span class="line">				things.push_back(&#123;<span class="number">-1</span>,v*k,w*k&#125;); <span class="comment">// 转换成01背包</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(s&gt;<span class="number">0</span>) things.push_back(&#123;<span class="number">-1</span>,v*s,w*s&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 处理所有thing</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:things) &#123;</span><br><span class="line">		<span class="comment">// 01背包/多重背包的处理→</span></span><br><span class="line">		<span class="keyword">if</span>(item.kind&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=item.v;j--) &#123;</span><br><span class="line">				f[j]=max(f[j],f[j-item.v]+item.w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 完全背包的处理→</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=item.v;j&lt;=m;j++) &#123;</span><br><span class="line">				f[j]=max(f[j],f[j-item.v]+item.w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-二维费用背包">5. 二维费用背包</span></h2><blockquote>
<p>时间复杂度：$O(n^3)$，空间复杂度：$O(n^2)$</p>
</blockquote>
<ul>
<li>除了体积限制外加入了重量限制，处理方法和 $01$背包完全类似，只不过多了一重循环，和一维空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> V=<span class="number">1e2</span>+<span class="number">5</span>; <span class="comment">// 最大体积</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e2</span>+<span class="number">5</span>; <span class="comment">// 最大载重</span></span><br><span class="line"><span class="type">int</span> n,v,m;</span><br><span class="line"><span class="type">int</span> f[V][M]; <span class="comment">// 体积是i重量是j的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 边输入边处理</span></span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=a;j--) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=m;k&gt;=b;k--) &#123;</span><br><span class="line">				f[j][k]=max(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[v][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="6-带依赖的背包">6. 带依赖的背包</span></h2><blockquote>
<p>时间复杂度：$O(n^3)$，空间复杂度：$O(n)$</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 选子物品前必须要选父物品</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j]:在选节点j的情况下总体积&lt;=j,以i为根的子树的最大总收益是多少?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个子节点是一个物品组,每个组里面只能选一个,就变成了分组背包问题</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a];</span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="comment">// 循环物品组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> son=e[i]; </span><br><span class="line">		dfs(son);</span><br><span class="line">		<span class="comment">// 枚举背包容量,因为一定要选择根节点</span></span><br><span class="line">		<span class="comment">// 所以j-v[u],01背包从大到小枚举</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m-v[u];j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">			<span class="comment">// 枚举决策,这个组里面选哪个</span></span><br><span class="line">			<span class="comment">// 枚举这个子节点用哪个体积</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=j;k++) &#123;</span><br><span class="line">				f[u][j]=max(f[u][j],f[u][j-k]+f[son][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果体积大于等于当前物品体积,把之前空出来的位置把物品价值加进去</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=v[u];i--) f[u][i]=f[u][i-v[u]]+w[u];</span><br><span class="line">	<span class="comment">// 如果体积小于当前物品体积,整棵子树一个点都不能选</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[u];i++) f[u][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> p;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v[i],&amp;w[i],&amp;p); <span class="comment">// p表示依赖关系</span></span><br><span class="line">		<span class="keyword">if</span>(p==<span class="number">-1</span>) root=i; <span class="comment">// -1表示根节点</span></span><br><span class="line">		<span class="keyword">else</span> add(p,i);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[root][m]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 根节点为root背包最大容量为m的最大价值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="7-背包求方案数">7. 背包求方案数</span></h2><blockquote>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(n)$</p>
</blockquote>
<ul>
<li>在 $01$ 背包的基础上要求求出能得到最大价值的方案数共有多少种</li>
<li>若初始化 $f[1]$ 到 $f[m]$，那么 $f[j]$ 代表的是背包容量不超过 $j$ 时所得最大价值，为了便于统计，我们想让 $f[j]$ 表示背包容量恰为 $j$ 时的最大价值，所以需要把 $f[1]$ 到 $f[m]$ 初始化为 $-INF$</li>
<li>因为最优解不一定在 $f[m]$ 空间不一定用完，所以还需要枚举出最大价值，再把最大价值对应的方案数累加起来，才是最终结果</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 求最大价值的选法有多少种</span></span><br><span class="line"><span class="comment">// 为了便于统计,我们要让物理意义变为背包容量恰为j时的最大价值</span></span><br><span class="line"><span class="comment">// 所以要初始化为负无穷</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>; <span class="comment">// 答案很大</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	g[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 初始化,背包容量为0时方案数是1</span></span><br><span class="line">	<span class="comment">// 背包容量为[1,m]时最大价值初始化为-INF</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		f[i]=-INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> v,w;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v;j--) &#123;</span><br><span class="line">			<span class="comment">// 选与不选的最大值</span></span><br><span class="line">			<span class="type">int</span> t=max(f[j],f[j-v]+w);</span><br><span class="line">			<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 看哪种方案更优,把其方案数拿过来</span></span><br><span class="line">			<span class="comment">// 因为有可能f[j]=f[j-v]+w,即从两个状态转移过来都可以</span></span><br><span class="line">			<span class="comment">// 所以写两个并列的if,可以都加</span></span><br><span class="line">			<span class="keyword">if</span>(t==f[j]) s+=g[j];</span><br><span class="line">			<span class="keyword">if</span>(t==f[j-v]+w) s+=g[j-v];</span><br><span class="line">			<span class="keyword">if</span>(s&gt;=mod) s-=mod; <span class="comment">// 手动取模</span></span><br><span class="line">			f[j]=t;</span><br><span class="line">			g[j]=s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxw=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 求最优解,最优解不一定是m,因为物理意义变了</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) maxw=max(maxw,f[i]);</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 求总的方案数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(maxw==f[i]) &#123;</span><br><span class="line">			res+=g[i];</span><br><span class="line">			<span class="keyword">if</span>(res&gt;=mod) res-=mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="8-背包求具体方案">8. 背包求具体方案</span></h2><blockquote>
<p>时间复杂度：$O(n^2)$，空间复杂度：$O(n^2)$</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 要求输出字典序最小的一种选法(123&lt;31)按位比</span></span><br><span class="line"><span class="comment">// 看f[n][m]是从哪个状态转移过来的,若为f[n-1][m](没选),若为f[n-1][m-v[i]]+w[i](选了)</span></span><br><span class="line"><span class="comment">// 贪心求,如果能选第一个物品,那么必须选第一个物品,这样字典序是最小的,前面的物品能选则选</span></span><br><span class="line"><span class="comment">// 从后往前推,求方案从前往后推</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N],f[N][N]; <span class="comment">// 前i个物品中背包容量不超过j的方案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从后往前推,这样求出来的方案才是字典序最小的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="comment">// 二维</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			f[i][j]=f[i+<span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=v[i]) &#123;</span><br><span class="line">				f[i][j]=max(f[i][j],f[i+<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,j=m; <span class="comment">// 从后往前推,最大值是f[1][m]</span></span><br><span class="line">	<span class="comment">// 从前往后推最大值</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=v[i] &amp;&amp; f[i+<span class="number">1</span>][j-v[i]]+w[i]&gt;=f[i+<span class="number">1</span>][j]) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			j-=v[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>动态规划</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2024/11/08/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="线段树">线段树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E9%80%92%E5%BD%92%E5%BB%BA%E6%A0%91">1. 递归建树</a></li>
<li><a href="#2-%E7%82%B9%E4%BF%AE%E6%94%B9">2. 点修改</a></li>
<li><a href="#3-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">3. 区间查询</a></li>
<li><a href="#4-%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9">4. 区间修改</a><ul>
<li><a href="#41-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84">4.1. 线段树的结构</a></li>
<li><a href="#42-%E5%90%91%E4%B8%8A%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0">4.2. 向上更新函数</a></li>
<li><a href="#43-%E5%90%91%E4%B8%8B%E4%BC%A0%E9%80%92%E6%87%92%E6%A0%87%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0">4.3. 向下传递懒标记的函数</a></li>
</ul>
</li>
<li><a href="#5-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">5. 完整代码</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>线段树是基于分治思想的二叉树，用来维护区间信息（区间和，区间最值，区间GCD等），可以在 $O(log^n)$ 的时间内执行区间修改和区间查询（树状数组是区间查询，单点修改和单点查询、区间修改，遇到复杂问题直接无脑线段树）</li>
<li>现在看起来，线段树和归并排序非常的类似，这个数据结构比较简单</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230728163803113.png" alt="image-20230728163803113" style="zoom: 80%;">



<h2><span id="1-递归建树">1. 递归建树</span></h2><blockquote>
<p>build函数：在一段区间上初始化线段树</p>
</blockquote>
<ul>
<li>二叉树的性质：父节点编号为p，那么左孩子编号为2p，右孩子编号为2p+1</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230728164819785.png" alt="image-20230728164819785" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,w[maxn]; <span class="comment">// w是要维护的一维数组</span></span><br><span class="line"><span class="comment">// l:区间的左端点</span></span><br><span class="line"><span class="comment">// r:区间的右端点</span></span><br><span class="line"><span class="comment">// sum:区间和</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum;</span><br><span class="line">&#125;t[maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// p:根节点的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	t[p]=&#123;l,r,w[l]&#125;; <span class="comment">// w[l]对叶子节点才有意义,最后回溯赋值</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 如果是叶子节点,返回</span></span><br><span class="line">	<span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">// 不是叶子,则分裂,m是中点</span></span><br><span class="line">	<span class="built_in">build</span>(lc,l,m);</span><br><span class="line">	<span class="built_in">build</span>(rc,m<span class="number">+1</span>,r);</span><br><span class="line">	t[p].sum=t[lc].sum+t[rc].sum; <span class="comment">// 更新父节点的sum值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由图可知，当有10个节点时，深度至少都为4（$10&gt;2^3$ &amp;&amp; $10&lt;2^4$ ），此时编号最多能有31个（$2^5-1$）【下一层填满】，设第四层为n，那么前三层的和为n-1，倘若第五层填满（此时构成满二叉树），则根据二叉树的性质有2n个节点，此时节点一共有 $n-1+n+2n$ (最多的情况)，可以发现是最多是n的四倍，所以我们预备 $4×maxn$ 的空间。</li>
</ul>
<h2><span id="2-点修改">2. 点修改</span></h2><blockquote>
<p>update函数：用子节点的信息更新当前节点信息</p>
</blockquote>
<ul>
<li>算法思路：从根节点开始，递归找到叶子节点，把该节点的值增加 $k$ ，找到后从下往上通过回溯的方式为父节点不断更新值</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230728171352718.png" alt="image-20230728171352718"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点修改</span></span><br><span class="line"><span class="comment">// p:根节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果是叶子节点</span></span><br><span class="line">	<span class="keyword">if</span>(t[p].l==x &amp;&amp; t[p].r==x) &#123;</span><br><span class="line">		t[p].sum+=k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 非叶子节点裂开,中间点为m</span></span><br><span class="line">	<span class="type">int</span> m=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=m)</span><br><span class="line">		<span class="built_in">update</span>(lc,x,k);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;m)</span><br><span class="line">		<span class="built_in">update</span>(rc,x,k);</span><br><span class="line">	<span class="comment">// 更新父节点的sum值</span></span><br><span class="line">	t[p].sum=t[lc].sum+t[rc].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-区间查询">3. 区间查询</span></h2><blockquote>
<p>query函数：区间查询</p>
</blockquote>
<ul>
<li><p>算法思路：拆分和拼凑，思想，例如：查询区间[4,9]可以拆分为[4,5],[6,8],[9,9]，通过合并三个结果的答案得到最终答案</p>
</li>
<li><p>从根节点进入，递归执行以下过程：</p>
<ol>
<li>若查询区间[x,y]完全覆盖当前节点区间，则立即回溯，并返回该节点的sum值</li>
<li>若左子节点与[x,y]有重叠，则递归访问左子树</li>
<li>若右子节点与[x,y]有重叠，则递归访问右子树</li>
</ol>
</li>
<li><p>举个例子，如果找[4,9]的元素和，从根节点开始，[4,9]与[1,5]有重叠，所以访问左子树，与[1,3]无重叠，所以访问[4,5]，发现[4,5]包含在[4,9]中，所以作为答案的一部分加起来；访问完了，回溯回溯，[4,9]与[6,10]有重叠，所以访问右子树，[6,10]的左子树[6,8]是[4,9]的一部分，所以作为答案的一部分加起来，继续访问右子树[9,10]与[4,9]有重叠而不是包含关系，所以访问右子树，找到[9,9]包含在[4,9]中，所以作为答案的一部分加起来，右子树[10,10]与[4,9]无重叠，不访问，全部访问完了，回溯回溯回溯，递归结束。</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230728172242397.png" alt="image-20230728172242397" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="comment">// p:根节点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果完全覆盖了,说明你是答案的一部分,则加上</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=t[p].l &amp;&amp; t[p].r&lt;=y) &#123;</span><br><span class="line">		<span class="keyword">return</span> t[p].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>; <span class="comment">// 如果不覆盖则分裂</span></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 与左边界有重叠,则去递归查询左子树</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=m)</span><br><span class="line">		sum+=<span class="built_in">query</span>(lc,x,y);</span><br><span class="line">	<span class="comment">// 与右边界有重叠,则去递归查询右子树</span></span><br><span class="line">	<span class="keyword">if</span>(y&gt;m)</span><br><span class="line">		sum+=<span class="built_in">query</span>(rc,x,y);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-区间修改">4. 区间修改</span></h2><blockquote>
<p>modify函数：区间修改</p>
</blockquote>
<ul>
<li>算法思路：例如，对区间[4,9]的每个数加上5，如果修改区间[x,y]所覆盖的每个叶子节点，时间将会是O(n)，如果我们做<strong>懒惰修改</strong>（通过一个变量来记账，并没有真正的修改这个节点中的值），先修改该区间的sum值，再打上一个“懒标记”，然后立即返回。等下次需要时，再下传“懒标记”（这个时候才是真正的赋值），这样，就可以把每次修改和查询的时间都控制到O(log<sup>n</sup>)。</li>
<li>举个例子：同样还是[4,9]+5的例子，从根节点开始，分裂成[1,5]和[6,10]，未完全覆盖，继续往下，找到[4,5]，完全覆盖了，因为[4,5]的宽度为2，所以节点5的sum+&#x3D;10(2×5)，打上懒标记add&#x3D;5，此时对于节点5(sum&#x3D;20, add&#x3D;5)，找到过后回溯到2，对于1来说递归完了左子树，继续递归右子树，对于节点3，未完全覆盖，往下找到[6,8]，此时已完全覆盖，节点3的宽度为3，所以节点3的sum+&#x3D;15(5×3)，打上懒标记add&#x3D;5，此时对于节点3(sum&#x3D;25, add&#x3D;6)，回溯，递归3的右子树，向下找到完全覆盖的[9,9]，此时宽度为1，所以节点7的sum加上5，打上懒标记add&#x3D;5，回溯，通过sum更新父节点的值，直至根节点，结束！</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230728193520637.png" alt="image-20230728193520637" style="zoom:80%;">



<h3><span id="41-线段树的结构">4.1. 线段树的结构</span></h3><ul>
<li>由于引入了懒标记add，所以结构体变为：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> l; <span class="comment">// 左子树编号 </span></span><br><span class="line">	<span class="type">int</span> r; <span class="comment">// 右子树编号</span></span><br><span class="line">	<span class="type">int</span> sum; <span class="comment">// 该节点所拥有的叶子节点的值之和</span></span><br><span class="line">	<span class="type">int</span> add; <span class="comment">// 懒标记(用于区间修改中)</span></span><br><span class="line">&#125;t[maxn*<span class="number">4</span>];</span><br></pre></td></tr></table></figure>



<h3><span id="42-向上更新函数">4.2. 向上更新函数</span></h3><ul>
<li>将t[p].sum&#x3D;t[lc].sum+t[rc].sum 总结成一个函数，增强可读性，用于更新结点的sum</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上更新节点的sum值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	t[p].sum=t[lc].sum+t[rc].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="43-向下传递懒标记的函数">4.3. 向下传递懒标记的函数</span></h3><ul>
<li>向下传递懒标记是为了真正要用到这个点的时候(当然没用到这个点的时候，要求和直接用父节点的sum就行了)，能以时间复杂度O(n)的方式来为其赋值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下更新节点的sum值(通过父节点打上的懒标记)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果有懒标记</span></span><br><span class="line">	<span class="keyword">if</span>(t[p].add) &#123;</span><br><span class="line">		<span class="comment">// 左子树的sum值增加宽度*懒标记的值,比如左子树是[3,4](设懒标记为5),那么这个节点的值sum增加10,add为5</span></span><br><span class="line">		<span class="comment">// 如果后续还需要下传懒标记,再传递给[3,3]和[4,4],sum分别增加宽度为1*add(5)=5,很好理解吧?</span></span><br><span class="line">		t[lc].sum+=t[p].add*(t[lc].r-t[lc].l<span class="number">+1</span>); <span class="comment">// right-left+1 是求宽度 </span></span><br><span class="line">		t[rc].sum+=t[p].add*(t[rc].r-t[lc].l<span class="number">+1</span>);</span><br><span class="line">		t[lc].add+=t[p].add; <span class="comment">// 懒标记增加父节点的懒标记(下传了,这个值要存起来)</span></span><br><span class="line">		t[rc].add+=t[p].add;</span><br><span class="line">		t[p].add=<span class="number">0</span>; <span class="comment">// 传完了,懒标记置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-完整代码">5. 完整代码</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,w[maxn]; <span class="comment">// w是要维护的一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> l; <span class="comment">// 左子树编号 </span></span><br><span class="line">	<span class="type">int</span> r; <span class="comment">// 右子树编号</span></span><br><span class="line">	<span class="type">int</span> sum; <span class="comment">// 该节点所拥有的叶子节点的值之和</span></span><br><span class="line">	<span class="type">int</span> add; <span class="comment">// 懒标记(用于区间修改中)</span></span><br><span class="line">&#125;t[maxn*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上更新节点的sum值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	t[p].sum=t[lc].sum+t[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下更新节点的sum值(通过父节点打上的懒标记)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果有懒标记</span></span><br><span class="line">	<span class="keyword">if</span>(t[p].add) &#123;</span><br><span class="line">		<span class="comment">// 左子树的sum值增加宽度*懒标记的值,比如左子树是[3,4](设懒标记为5),那么这个节点的值sum增加10,add为5</span></span><br><span class="line">		<span class="comment">// 如果后续还需要下传懒标记,再传递给[3,3]和[4,4],sum分别增加宽度为1*add(5)=5,很好理解吧?</span></span><br><span class="line">		t[lc].sum+=t[p].add*(t[lc].r-t[lc].l<span class="number">+1</span>); <span class="comment">// right-left+1 是求宽度 </span></span><br><span class="line">		t[rc].sum+=t[p].add*(t[rc].r-t[rc].l<span class="number">+1</span>);</span><br><span class="line">		t[lc].add+=t[p].add; <span class="comment">// 懒标记增加父节点的懒标记(下传了,这个值要存起来)</span></span><br><span class="line">		t[rc].add+=t[p].add;</span><br><span class="line">		t[p].add=<span class="number">0</span>; <span class="comment">// 传完了,懒标记置为0</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	auto &amp;u=t[p],&amp;l=t[lc],&amp;r=t[rc];</span></span><br><span class="line"><span class="comment">//	if(u.add) &#123;</span></span><br><span class="line"><span class="comment">//		l.sum+=u.add*(l.r-l.l+1),</span></span><br><span class="line"><span class="comment">//		r.sum+=u.add*(r.r-r.l+1),</span></span><br><span class="line"><span class="comment">//		l.add+=u.add,</span></span><br><span class="line"><span class="comment">//		r.add+=u.add,</span></span><br><span class="line"><span class="comment">//		u.add=0;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造线段树</span></span><br><span class="line"><span class="comment">// p:根节点的编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	t[p]=&#123;l,r,w[l],<span class="number">0</span>&#125;; <span class="comment">// w[l]对叶子节点才有意义,最后回溯赋值</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 如果是叶子节点,返回</span></span><br><span class="line">	<span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">// 不是叶子,则分裂,m是中点</span></span><br><span class="line">	<span class="built_in">build</span>(lc,l,m);</span><br><span class="line">	<span class="built_in">build</span>(rc,m<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">// 更新父节点的sum值</span></span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点修改</span></span><br><span class="line"><span class="comment">// p:根节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果是叶子节点</span></span><br><span class="line">	<span class="keyword">if</span>(t[p].l==x &amp;&amp; t[p].r==x) &#123;</span><br><span class="line">		t[p].sum+=k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 非叶子节点裂开,中间点为m</span></span><br><span class="line">	<span class="type">int</span> m=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=m)</span><br><span class="line">		<span class="built_in">update</span>(lc,x,k);</span><br><span class="line">	<span class="keyword">if</span>(x&gt;m)</span><br><span class="line">		<span class="built_in">update</span>(rc,x,k);</span><br><span class="line">	<span class="comment">// 更新父节点的sum值</span></span><br><span class="line">	t[p].sum=t[lc].sum+t[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="comment">// p:根节点编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果完全覆盖了,说明你是答案的一部分,则加上</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=t[p].l &amp;&amp; t[p].r&lt;=y) &#123;</span><br><span class="line">		<span class="keyword">return</span> t[p].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>; <span class="comment">// 如果不覆盖则分裂</span></span><br><span class="line">	<span class="built_in">pushdown</span>(p); <span class="comment">// 下传懒标记</span></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 与左边界有重叠,则去递归查询左子树</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=m)</span><br><span class="line">		sum+=<span class="built_in">query</span>(lc,x,y);</span><br><span class="line">	<span class="comment">// 与右边界有重叠,则去递归查询右子树</span></span><br><span class="line">	<span class="keyword">if</span>(y&gt;m)</span><br><span class="line">		sum+=<span class="built_in">query</span>(rc,x,y);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间更新</span></span><br><span class="line"><span class="comment">// p:根节点,x~y:区间,k:增加的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 完全覆盖才更新值</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=t[p].l &amp;&amp; t[p].r&lt;=y) &#123;</span><br><span class="line">		t[p].sum+=(t[p].r-t[p].l<span class="number">+1</span>)*k; <span class="comment">// 增加区间宽度*k</span></span><br><span class="line">		t[p].add+=k; <span class="comment">// 打上懒标记</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果没覆盖,则分裂,m是中间点</span></span><br><span class="line">	<span class="type">int</span> m=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(p); <span class="comment">// 下传懒标记</span></span><br><span class="line">	<span class="comment">// 如果有重叠,去更新左子树</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=m)</span><br><span class="line">		<span class="built_in">update</span>(lc,x,y,k);</span><br><span class="line">	<span class="comment">// 如果有重叠,去更新右子树</span></span><br><span class="line">	<span class="keyword">if</span>(y&gt;m)</span><br><span class="line">		<span class="built_in">update</span>(rc,x,y,k);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m; <span class="comment">// n是数列个数,m是操作次数</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入要维护的一维数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;w[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据一维数组来构造线段树,意为:根节点为1,从1~n</span></span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n); <span class="comment">// 构造线段树</span></span><br><span class="line">	<span class="type">int</span> op; <span class="comment">// 操作类型</span></span><br><span class="line">	<span class="type">int</span> l,r; <span class="comment">// 左右区间</span></span><br><span class="line">	<span class="type">int</span> k; <span class="comment">// 增加的值</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">			<span class="comment">// 区间更新</span></span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>,l,r,k); <span class="comment">// 更新</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="comment">// 区间求和</span></span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5个数字,5个操作</span></span><br><span class="line"><span class="comment">1 x y k 将[x,y]加上k</span></span><br><span class="line"><span class="comment">2 x y 输出[x,y]每个数的和</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">1 5 4 2 3</span></span><br><span class="line"><span class="comment">2 2 4</span></span><br><span class="line"><span class="comment">1 2 3 2</span></span><br><span class="line"><span class="comment">2 3 4</span></span><br><span class="line"><span class="comment">1 1 5 1</span></span><br><span class="line"><span class="comment">2 1 4</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">20</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>树</tag>
        <tag>高级数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心区间问题</title>
    <url>/2024/10/05/%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="贪心区间问题">贪心区间问题</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9">1. 最大不相交区间数（区间选点）</a></li>
<li><a href="#2-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84">2. 区间分组</a></li>
<li><a href="#3-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96">3. 区间覆盖</a></li>
<li><a href="#4-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">4. 区间合并</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<blockquote>
<p>以下例题来自于AcWing 906~908</p>
</blockquote>
<h2><span id="1-最大不相交区间数区间选点">1. 最大不相交区间数（区间选点）</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240307214934220.png" alt="image-20240307214934220"></p>
<ul>
<li>翻译一下题目吧<ol>
<li>最大不相交区间数：也就是说给定$N$个闭区间，问能从中选出多少个区间使其互不相交（同活动安排问题）</li>
<li>区间选点：给定 $N$ 个区间，在数轴上选择尽量少的点，使每个区间至少包含一个选出的点（同整数区间问题：找到一个含元素个数最少的集合，使对每一个区间都至少有一个整数属于该集合，输出该集合的元素个数）</li>
<li>为什么这两个问题其实是同一个问题？观察下方图像，在找不相交区间的时候其实就是把 $N$ 个区间划分成 $M$ 个集合，从这 $M$ 个集合中分别选出一个区间，那么这 $M$ 个集合是一定不相交的，此时 $M$ 就是答案，区间选点中点的个数其实就是集合的个数，只要 $range[i].l&gt;last_r$ 就说明需要新开一个集合了，所以 $ans++$</li>
</ol>
</li>
<li>贪心策略：新建一个结构体存储区间的左端点和右端点，将这$N$个区间按照右端点从小到大排序（因为活动选择<strong>越早结束越好</strong>），遍历所有的区间，如果当前遍历到的区间左端点的值大于了上一个区间的右端点的值，说明此时区间没有重合，则区间个数$+1$</li>
<li>如果假设选的点都出现在区间的右端点，此时为了让每个区间都至少包含一个交点，就可以作图如下：</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529204230868.png" alt="image-20240529204230868"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 活动安排+最大不相交区间+区间选点 </span></span><br><span class="line"><span class="comment">  1) 用一个变量记录上一个区间右端点,把所有区间依据区间右端点从小到大排序</span></span><br><span class="line"><span class="comment">  2) 如果某个区间的左端点＞上一个区间右端点,则选点数+1,或不相交区间的个数+1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l; </span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N]; <span class="comment">// 每个区间有左右端点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照右端点从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Range a,Range b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> front_r=INT_MIN; <span class="comment">// 保证至少有一个集合,即range[i].l一定比初始front_r大 </span></span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n,cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以定义res=1,front_r=(sorted)range[1].r,下面的for循环从i=2开始</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(range[i].l&gt;front_r) &#123;</span><br><span class="line">			front_r=range[i].r; <span class="comment">// 更新右端点</span></span><br><span class="line">			res++; <span class="comment">// 点数+1</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/solution/P1250">P1250 种树 - 洛谷 </a></p>
</blockquote>
<ul>
<li>题目大意：在区间 $[a,b]$ 内至少种 $c$ 棵树，问树最少的个数</li>
<li>解题思路：<ul>
<li>即让尽可能多的树同时在多个区间出现，对每个区间先统计已有树的数量，如果不足 $c$ 棵则补差</li>
<li>为了让树尽可能能被下一个区间用上，补差时应当从末尾补差</li>
<li>因为每个坐标点只能种一棵树，所以还需要一个状态数组 $st$ 辅助存储</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: </span></span><br><span class="line"><span class="comment">  1) 要在[a,b]种至少c棵树,树最少,即让尽可能多的树同时在多个区间出现,再对多个区间补差</span></span><br><span class="line"><span class="comment">  2) 在补差的时候一定要补在该区间的尾部,因为这样是最后可能让下一个区间用上的</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> n; <span class="comment">// 树的个数</span></span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> used[N]; <span class="comment">// 判断是否已经有树了(一个点不能种两棵树)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Range a,Range b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r; <span class="comment">// 按右端点从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r,&amp;range[i].n); 	</span><br><span class="line">	&#125;</span><br><span class="line">	sort(range+<span class="number">1</span>,range+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>; <span class="comment">// 存储该区间内已有的树的个数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=range[i].l;j&lt;=range[i].r;j++) <span class="keyword">if</span>(used[j]) k++;</span><br><span class="line">		<span class="comment">// 1) 已满足range[i].n棵树则退出</span></span><br><span class="line">		<span class="keyword">if</span>(k&gt;=range[i].n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 2) 不满足,则需要补差,补差需要从末尾补,最有可能给下一个区间用</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=range[i].r;j&gt;=range[i].l;j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!used[j]) &#123;</span><br><span class="line">				used[j]=<span class="literal">true</span>;</span><br><span class="line">				k++;</span><br><span class="line">				ans++; <span class="comment">// 树的数量只在此处增加,即所有的树其实都是从末尾补的</span></span><br><span class="line">				<span class="keyword">if</span>(k==range[i].n) <span class="keyword">break</span>; <span class="comment">// 已够n棵</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-区间分组">2. 区间分组</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240308190931030.png" alt="image-20240308190931030"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529205928100.png" alt="image-20240529205928100"></p>
<ul>
<li>翻译一下题目，现在有$N$个区间，问最少分多少组，能让这些分组中的所有区间两两之间包括端点都没有交集</li>
<li>贪心策略：将所有区间按照左端点从小到大排序，从前往后处理每个区间，判断是否能把这个区间放到现有的某个分组中，即判断 $range[i].l \ &gt; \ 某一分组最大右端点$<ol>
<li>如果存在这样的分组（与某个分组间没有交集），则将区间 $ i $ 放进去，并且更新这个分组的最大右端点（注意，如果与多个分组都有交集则可以放到任意一个分组中，不影响结果，可自行模拟证明）</li>
<li>如果不存在这样的分组（与每个分组间都有交集），则开一个新组，再把区间 $i$ 放进去</li>
<li>在判断当前区间是否与某一分组有交集时，只需要与所有分组中最小的分组最大右端点进行比较即可，因为这是最有可能满足 $range[i].l \ &gt; \ 某一分组最大右端点$ 的情况，对于所有分组中最小的分组最大右端点，只需要用一个小根堆来维护即可</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: </span></span><br><span class="line"><span class="comment">  1) 先将所有区间按照左端点从小到大排序</span></span><br><span class="line"><span class="comment">  2) 用优先队列维护所有分组的整体右端点的最小值,因为在遍历区间时需要用range[i].l与所有分组的max_r比较,而min(max_r)是最容易比range[i].l小的,即最容易插入该分组中</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Range a,Range b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 按照左端点从小到大排序</span></span><br><span class="line">	<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 维护每个分组的最右边界的最小值</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 枚举区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果每个分组的最小的max_r都比当前区间左端点大</span></span><br><span class="line">		<span class="comment">// 说明与每个分组中的区间都要产生交集,则不能放入任何分组</span></span><br><span class="line">		<span class="comment">// 此时新开一个分组</span></span><br><span class="line">		<span class="keyword">if</span>(pq.<span class="built_in">empty</span>() || pq.<span class="built_in">top</span>()&gt;=range[i].l) &#123;</span><br><span class="line">			pq.<span class="built_in">push</span>(range[i].r); <span class="comment">// 新开分组,保存右端点</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果无交集,此时可以放进这个分组中</span></span><br><span class="line">			<span class="comment">// 并维护所有分组中最大右端点的最小值</span></span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			pq.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 小根堆的大小就是分组的个数</span></span><br><span class="line">	cout&lt;&lt;pq.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-区间覆盖">3. 区间覆盖</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240308203244259.png" alt="image-20240308203244259"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529211220012.png" alt="image-20240529211220012"></p>
<ul>
<li>翻译一下题目，···，这道题没什么可翻译的</li>
<li>贪心策略：将所有区间按照左端点从小到大排序，从前往后依次枚举每个区间，在所有能覆盖 $start$ 的区间中选择一个右端点最大的区间，然后将 $start$ 更新成为右端点的最大值，继续向后覆盖，如果所有区间都遍历过了但并没有覆盖到 $end$ 的话说明无法完全覆盖，则输出 $-1$</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 对区间按照左端点从小到大排序,因为每次都要保证覆盖start</span></span><br><span class="line"><span class="comment">  再从满足覆盖start的区间中选出右端点最大的,这样就能保证覆盖线段的区间数最小</span></span><br><span class="line"><span class="comment">  再更新start的值,如果遍历完所有区间能使start&gt;=end,则可覆盖,输出区间数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// 重载运算符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> st,en;</span><br><span class="line">	cin&gt;&gt;st&gt;&gt;en;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 统计区间数</span></span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>; <span class="comment">// 是否能覆盖完整个区间</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历所有区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// front_r:当前覆盖到的区域</span></span><br><span class="line">		<span class="comment">// j:每次从第i个区间后开始找</span></span><br><span class="line">		<span class="type">int</span> j=i,front_r=INT_MIN;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=n &amp;&amp; range[j].l&lt;=st) &#123;</span><br><span class="line">			front_r=<span class="built_in">max</span>(front_r,range[j].r); <span class="comment">// 找最大的右端点</span></span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果最大的front_r仍小于st,说明线段不可被已有区间覆盖</span></span><br><span class="line">		<span class="keyword">if</span>(front_r&lt;st) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 如果找得到,区间数+1</span></span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="comment">// 已经完全覆盖线段</span></span><br><span class="line">		<span class="keyword">if</span>(front_r&gt;=en) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则更新i和j</span></span><br><span class="line">		st=front_r; <span class="comment">// 迭代st,后面的区间继续和st比</span></span><br><span class="line">		i=j<span class="number">-1</span>; <span class="comment">// 双指针,加速遍历</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(!flag) cnt=<span class="number">-1</span>;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-区间合并">4. 区间合并</span></h2><ul>
<li>题目最简单的一集，$N$ 个区间，端点重叠也可合并，求合并后的区间数量和左右端点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 区间合并,端点也算重叠,将有重叠的区间合并后输出</span></span><br><span class="line"><span class="comment">  1) 区间按左端点从小到大排序,有重叠则合并更新区间右端点</span></span><br><span class="line"><span class="comment">  2) range数组一个存储合并前的区间,一个存储合并后的区间,最后遍历输出即可</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// range:原区间,ans:合并后区间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接return a.l&lt;b.l ,如果右端点也从小到大排序则合并次数多了,常数反而大了</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Range a,Range b)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.l!=b.l) <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(range+<span class="number">1</span>,range+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 枚举所有区间进行合并</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	ans[++cnt]=range[<span class="number">1</span>]; <span class="comment">// 结构体之间等价赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 可合并</span></span><br><span class="line">		<span class="keyword">if</span>(range[i].l&lt;=ans[cnt].r) &#123;</span><br><span class="line">			ans[cnt].r=max(ans[cnt].r,range[i].r); <span class="comment">// 更新右端点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不可合并,开新区间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans[++cnt]=range[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 区间个数</span></span><br><span class="line">	<span class="comment">// 输出合并后的区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans[i].l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2024/10/02/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="进制转换">进制转换</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%B8%B8%E7%94%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C-%E5%85%AB-%E5%8D%81-%E5%8D%81%E5%85%AD">1. 常用转换（二、八、十、十六）</a></li>
<li><a href="#2-%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%9C%80%E9%AB%98%E4%B8%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">2. 任意进制（最高三十六进制）转换为十进制数</a></li>
<li><a href="#3-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%95%B0%E6%9C%80%E9%AB%98%E4%B8%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">3. 十进制数转换为任意进制数（最高三十六进制）</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-常用转换二-八-十-十六">1. 常用转换（二、八、十、十六）</span></h2><blockquote>
<p>$C++$ 中常见进制数</p>
</blockquote>
<ul>
<li>$%d$ ：十进制数</li>
<li>$%x$ ：十六进制数</li>
<li>$%o$ ：八进制数</li>
<li>$%b$ ：二进制数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 十进制转换为其他常用进制</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">	cin&gt;&gt;dec&gt;&gt;n;</span><br><span class="line">	<span class="function">bitset&lt;20&gt; <span class="title">bt</span><span class="params">(n)</span></span>; <span class="comment">// 转换成二进制(最大20位)</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;2进制:&quot;</span>&lt;&lt;bt&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;8进制:&quot;</span>&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;16进制:&quot;</span>&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;16进制(字母大写输出):&quot;</span>&lt;&lt;hex&lt;&lt;<span class="built_in">setiosflags</span>(ios::uppercase)&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 同理,其他常用进制可以互相转换</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">	cin&gt;&gt;hex&gt;&gt;x;</span><br><span class="line">	<span class="function">bitset&lt;20&gt; <span class="title">bt1</span><span class="params">(x)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;2进制:&quot;</span>&lt;&lt;bt1&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;8进制:&quot;</span>&lt;&lt;oct&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;10进制:&quot;</span>&lt;&lt;dec&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-任意进制最高三十六进制转换为十进制数">2. 任意进制（最高三十六进制）转换为十进制数</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 任何进制数转换为十进制数</span></span><br><span class="line"><span class="comment">// s:这个任意进制数的字符串形式</span></span><br><span class="line"><span class="comment">// R:这个字符串当前的进制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Atoi</span><span class="params">(<span class="built_in">string</span> s,<span class="type">int</span> R)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">			res=res*R+s[i]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 每次*=R升权</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">			res=res*R+s[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>; <span class="comment">// 因为A表示10</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Atoi(<span class="string">&quot;ZDBAEFEA&quot;</span>,<span class="number">36</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Atoi(<span class="string">&quot;100&quot;</span>,<span class="number">16</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-十进制数转换为任意进制数最高三十六进制">3. 十进制数转换为任意进制数（最高三十六进制）</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转换为任意进制</span></span><br><span class="line"><span class="comment">// num:这个十进制的数</span></span><br><span class="line"><span class="comment">// R:要转换成多少进制</span></span><br><span class="line"><span class="function">string <span class="title">Itoa</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="type">int</span> rmd; <span class="comment">// 记录每次做除法的余数</span></span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">0</span>) str=<span class="string">&quot;0&quot;</span>; <span class="comment">// 特判任意进制的0</span></span><br><span class="line">	<span class="keyword">while</span>(num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		rmd=num%R; <span class="comment">// 每次对R取余,可以类比一下十进制转二进制</span></span><br><span class="line">		ch=(rmd&lt;<span class="number">10</span>)?(rmd+<span class="string">&#x27;0&#x27;</span>):(rmd<span class="number">-10</span>+<span class="string">&#x27;A&#x27;</span>); <span class="comment">// 小于10表示为[0,9],否则减去10+&#x27;A&#x27;</span></span><br><span class="line">		str=ch+str; <span class="comment">// 字符串拼接</span></span><br><span class="line">		num/=R;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里按照题目要求补前导0等操作</span></span><br><span class="line">	<span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">1</span>) str=<span class="string">&quot;0&quot;</span>+str; </span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Itoa</span>(<span class="number">196</span>,<span class="number">16</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>递推</title>
    <url>/2024/10/03/%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="递推">递推</span></h1><!-- toc -->

<ul>
<li><a href="#%E4%B8%80%E6%9C%AC%E9%80%9A-1188%E8%8F%B2%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%972">一本通 1188：菲波那契数列(2)</a></li>
<li><a href="#%E4%B8%80%E6%9C%AC%E9%80%9A-1189pell%E6%95%B0%E5%88%97">一本通 1189：Pell数列</a></li>
<li><a href="#%E4%B8%80%E6%9C%AC%E9%80%9A-1190%E4%B8%8A%E5%8F%B0%E9%98%B6">一本通 1190：上台阶</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="一本通-1188菲波那契数列2">一本通 1188：菲波那契数列(2)</span></h2><blockquote>
<p>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1188">信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)</a></p>
</blockquote>
<ul>
<li>斐波那契数列问题我们经常用递归解决，但是本题由于数据范围比较大，所以递归层数会非常多，会遇到爆栈的问题，必定会TLE</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因此我们选择用递推解决，同时还有一个问题，题目要求的是菲波那契数列中第$a$个数对$1000$取模得到的结果，我们只需要在计算$Fibonacci$数列的时候一边计算一边对$1000$取模就可以了，这并不会最终结果</li>
<li>如果我们不一边计算一边取模，而是对单独我们要的那个值进行取模会遇到什么结果？在计算数列的时候就已经爆$int$、$long\ long$了，那么在累加求解的过程中就会溢出，最终得到的是负数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 想想能不能用递归做呢?不能,因为数据范围很大,递归会爆栈,一定会TLE</span></span><br><span class="line"><span class="comment">//int fib(int n) &#123;</span></span><br><span class="line"><span class="comment">//	if(n==1 || n==2) </span></span><br><span class="line"><span class="comment">//		return 1;</span></span><br><span class="line"><span class="comment">//	else </span></span><br><span class="line"><span class="comment">//		return (fib(n-1)+fib(n-2))%1000;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> fib[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">// 预处理计算出所有的fib,再处理查询</span></span><br><span class="line">	<span class="comment">// 初始化:</span></span><br><span class="line">	fib[<span class="number">1</span>]=fib[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=N;i++) &#123;</span><br><span class="line">		fib[i]=(fib[i<span class="number">-1</span>]+fib[i<span class="number">-2</span>])%<span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line"><span class="comment">//		scanf(&quot;%d&quot;,&amp;temp);</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;fib(temp)%1000&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 用递推做法</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">		cout&lt;&lt;fib[temp]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="一本通-1189pell数列">一本通 1189：Pell数列</span></h2><blockquote>
<p>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1189">信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)</a></p>
</blockquote>
<ul>
<li>当作业咯</li>
</ul>
<h2><span id="一本通-1190上台阶">一本通 1190：上台阶</span></h2><blockquote>
<p>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1190">信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)</a></p>
</blockquote>
<ul>
<li>其实这道题是动态规划中线性$DP$中非常经典的题目，非常适合新手初步接触动态规划类型题目，从动态规划的四要素来分析该问题</li>
</ul>
<ol>
<li>状态表示，$dp[i]$：到达第$i$步台阶的方案数</li>
<li>初始化，$dp[1]&#x3D;1$，到达台阶一的方案只有一种，那就是直接走一步，$dp[2]&#x3D;2$，到达台阶二的方案有两种，那就是走两个一步，或者直接走两步，$dp[3]&#x3D;4$，到达台阶三的方案有四种，要么走四个一步，要么走两个两步，要么先走两步，再走两个一步，要么先走两个一步，再走一个两步</li>
<li>状态转移，$dp[i]&#x3D;dp[i-1]+dp[i-2]+dp<a href="n%3E=3">i-3</a>$：到达第台阶$i$要么是从第$i-1$步台阶走一步上来的，要么是从第$i-2$步台阶走两步上来的，要么是从第$i-3$步台阶走三步上来的</li>
<li>目标值，要求到达第$n$步台阶方案数，所以直接输出$dp[n]$即可</li>
</ol>
<ul>
<li>注意就算最大台阶只有$70$步，但数据增长速度很快，所以需要开$long \ long$才能通过</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">70</span><span class="number">+5</span>; <span class="comment">// 最大台阶数</span></span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	dp[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 预处理所有方案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=N;i++) &#123;</span><br><span class="line">		dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]+dp[i<span class="number">-3</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>) &#123;</span><br><span class="line">		cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接矩阵</title>
    <url>/2024/10/04/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="邻接矩阵">邻接矩阵</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">0. 邻接矩阵</a></li>
<li><a href="#1-%E6%B4%9B%E8%B0%B73643-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8">1. 洛谷3643 图的存储</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="0-邻接矩阵">0. 邻接矩阵</span></h2><ul>
<li>邻接矩阵相比于上一篇博客邻接表的讲解要简单得多</li>
</ul>
<ol>
<li>数据结构，如果将二维数组 $g$ 定义为全局变量，那默认初始化应该为 $0$ ，如果题目中存在自环，可以做特判，$memset$ 初始化数组 $g$ 为 $0x3f3f3f3f$ 表示无穷大，$0$ 表示自环</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的度</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>以下模板是无向图的邻接矩阵模板，如果改成有向图，和邻接表一样，不需要对称建边，比如有一条边是 $(1,3)$，则 $d[1]++,\ g[1][3]&#x3D;1 $ 即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入边</span></span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="comment">// 邻接矩阵建边</span></span><br><span class="line">    d[u]++,d[v]++; <span class="comment">// 顶点u和顶点v度数+1</span></span><br><span class="line">    g[u][v]=<span class="number">1</span>,g[v][u]=<span class="number">1</span>; <span class="comment">// 互相可达,为0表示不可达(如果题目涉及自环可用memset初始化为0x3f3f3f3f表示不可达)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整代码如下，注意代码采用无向图模板</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 图的存储-邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span>+<span class="number">5</span>)*<span class="number">2</span>; <span class="comment">// 无向图建边最大边数为题目最大边数*2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的度</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 假设题目编号默认从1开始</span></span><br><span class="line">	<span class="type">int</span> n,m; <span class="comment">// 存储顶点数和边数</span></span><br><span class="line">	<span class="comment">// 输入边</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="comment">// 邻接矩阵建边</span></span><br><span class="line">		d[u]++,d[v]++; <span class="comment">// 顶点u和顶点v度数+1</span></span><br><span class="line">		g[u][v]=<span class="number">1</span>,g[v][u]=<span class="number">1</span>; <span class="comment">// 互相可达,为0表示不可达(如果题目涉及自环可用memset初始化为0x3f3f3f3f表示不可达)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;g[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="1-洛谷3643-图的存储">1. 洛谷3643 图的存储</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/B3643">B3643 图的存储 - 洛谷</a></p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240309115736673.png" alt="image-20240309115736673"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+10</span>; <span class="comment">// 最大顶点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span><span class="number">+10</span>)*<span class="number">2</span>; <span class="comment">// 最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 顶点数和边数</span></span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存度数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:编号i的顶点的</span></span><br><span class="line"><span class="type">int</span> ne[M];</span><br><span class="line"><span class="type">int</span> e[M];</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星(头插法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="comment">// 邻接矩阵建边</span></span><br><span class="line">		d[u]++,d[v]++; <span class="comment">// 度数+1</span></span><br><span class="line">		g[u][v]=<span class="number">1</span>,g[v][u]=<span class="number">1</span>; <span class="comment">// 互达</span></span><br><span class="line">		<span class="comment">// 邻接表建边</span></span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">		<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			cout&lt;&lt;g[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历邻接表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cout&lt;&lt;d[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 先输出点i的度数</span></span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=h[i];j!=<span class="number">-1</span>;j=ne[j]) &#123;</span><br><span class="line">			<span class="type">int</span> t=e[j];</span><br><span class="line">			s.<span class="built_in">push_back</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 编号从小到大排序</span></span><br><span class="line">		<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> t:s) cout&lt;&lt;t&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接表+链式前向星</title>
    <url>/2024/10/04/%E9%82%BB%E6%8E%A5%E8%A1%A8+%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="邻接表">邻接表</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E9%82%BB%E6%8E%A5%E8%A1%A8">1. 邻接表</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-邻接表">1. 邻接表</span></h2><ul>
<li>邻接表存储图需要注意的要点有：</li>
</ul>
<ol>
<li>模板采用的是无向图，所以最大边数 $M$ 开到了题目所给最大边数的两倍，如果是有向图，那么在建边的时候，只需要建一次即可，比如 $a$ 到 $b$ 有一条边，那么只需要 $add(a,b)$ ，不需要 $add(b,a)$ 对称建边</li>
<li>链式前向星（也称数组模拟邻接表）的数据结构为：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:第i个顶点的起始边编号,默认从-1开始</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[idx]:第idx条边的下一条边的编号</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[idx]:第idx条边指向的节点的编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，数组 $h$ 应被初始化为 $-1$ ，表示所有顶点的起始边编号是 $-1$ ，可以理解为头结点，因为采用的是头插法，如果顶点 $i$ 没有与其直接相连的边，那么 $h[i]&#x3D;-1$，如果顶点 $i$ 有与其直接相连的边，那么顶点 $i$ 的邻接表的最后一个元素是 $-1$</li>
</ul>
<blockquote>
<p>此处表格参考博客：<a href="https://blog.csdn.net/hnjzsyjyj/article/details/119895317">CSDN博客</a></p>
</blockquote>
<ol start="3">
<li>重点讲解链式前向星，假设现在有五条边<strong>有向边</strong>， $(1,4),\ (4,3),\ (1,2),\ (2,4),\ (1,3)$ ，对应执行 $add(1,4),\ add(4,3),\ add(1,2),\ add(2,4),\ add(1,3)$，我们手动模拟一下建边过程应该是这样的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建边(链式前向星)[头插法]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b; <span class="comment">// 第idx条边指向顶点b</span></span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 第idx条边的下一条边是顶点a的起始边[体现头插法思想]</span></span><br><span class="line">	h[a]=idx++; <span class="comment">// 顶点a的下一条边是第idx条边,编号+1以表示下一条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">add(a,b)</th>
<th align="center">idx</th>
<th align="center">e[idx]&#x3D;b, ne[idx]&#x3D;h[a],h[a]&#x3D;idx++</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(1,4)</td>
<td align="center">1</td>
<td align="center">e[1]&#x3D;4, ne[1]&#x3D;h[1]&#x3D;-1, h[1]&#x3D;1, idx&#x3D;2</td>
</tr>
<tr>
<td align="center">(4,3)</td>
<td align="center">2</td>
<td align="center">e[2]&#x3D;3, ne[2]&#x3D;h[4]&#x3D;-1, h[4]&#x3D;2, idx&#x3D;3</td>
</tr>
<tr>
<td align="center">(1,2)</td>
<td align="center">3</td>
<td align="center">e[3]&#x3D;2, ne[3]&#x3D;h[1]&#x3D;1, h[1]&#x3D;3, idx&#x3D;4</td>
</tr>
<tr>
<td align="center">(2,4)</td>
<td align="center">4</td>
<td align="center">e[4]&#x3D;2, ne[4]&#x3D;h[2]&#x3D;-1, h[2]&#x3D;4, idx&#x3D;5</td>
</tr>
<tr>
<td align="center">(1,3)</td>
<td align="center">5</td>
<td align="center">e[5]&#x3D;3, ne[5]&#x3D;h[1]&#x3D;3, h[1]&#x3D;5, idx&#x3D;6</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>建边完成后，每个数组的情况应该是（下标均从 $0$ 开始）：</p>
<ul>
<li><p>$h&#x3D;[-1, 4, 3, -1, 1, -1]$</p>
</li>
<li><p>$ne&#x3D;[-1, -1, 0, -1, 2]$</p>
</li>
<li><p>$e&#x3D;[4, 3, 2, 4, 3]$</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>比如我们现在要输出与顶点 $1$ 直接相连的边，代码最终会输出 $3\ 2\ 4$，因为采用的是头插法，所以边的遍历顺序是 $(1,3),\ (1,2),\ (1,4)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// j初始化为顶点1的起始边,因为最后一条边的编号一定为-1(头插法),然后j通过ne数组迭代到下一条相连边的编号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=h[<span class="number">1</span>];j!=<span class="number">-1</span>;j=ne[j]) &#123;</span><br><span class="line">    cout&lt;&lt;e[j]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// e[j]:编号为j的边指向的顶点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整样例代码，注意代码中的模拟数据和前文不同，并且采用无向图建边，如果从无向图建边改为有向图建边前文已介绍</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 邻接表、链式前向星模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span><span class="number">+5</span>)*<span class="number">2</span>; <span class="comment">// 最大边数,因为无向图是双向建边,所以要*2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:第i个顶点的起始边编号,默认从-1开始</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[idx]:第idx条边的下一条边的编号</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[idx]:第idx条边指向的节点的编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建边(链式前向星)[头插法]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b; <span class="comment">// 第idx条边指向顶点b</span></span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 第idx条边的下一条边是顶点a的起始边[体现头插法思想]</span></span><br><span class="line">	h[a]=idx++; <span class="comment">// 顶点a的下一条边是第idx条边,编号+1以表示下一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 每个顶点的起始边编号初始化为-1</span></span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">add</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>),<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">add</span>(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">3</span>),<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>),<span class="built_in">add</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 遍历每个顶点,输出与其直接相邻的所有顶点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">		<span class="comment">// 从顶点i的起始边开始搜索,因为是头插,所以-1最终会变成最后一个边的编号,遇到则停止,通过ne数组迭代到下一条边的编号</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=h[i];j!=<span class="number">-1</span>;j=ne[j]) &#123;</span><br><span class="line">			s.<span class="built_in">push_back</span>(e[j]); <span class="comment">// e里面存储的是顶点编号</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;与顶点 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; 直接相连的顶点有:&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> item:s) cout&lt;&lt;item&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2024/10/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="高精度">高精度</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%E9%AB%98%E7%B2%BE%E9%AB%98%E7%B2%BE">1. 高精度加法（高精+高精）</a></li>
<li><a href="#2-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95%E9%AB%98%E7%B2%BE-%E9%AB%98%E7%B2%BE">2. 高精度减法（高精-高精）</a></li>
<li><a href="#3-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95">3. 高精度乘法</a><ul>
<li><a href="#31-%E9%AB%98%E7%B2%BE%E4%BD%8E%E7%B2%BE">3.1. 高精×低精</a></li>
<li><a href="#32-%E9%AB%98%E7%B2%BE%E9%AB%98%E7%B2%BE">3.2. 高精×高精</a></li>
</ul>
</li>
<li><a href="#4-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95">4. 高精度除法</a><ul>
<li><a href="#41-%E9%AB%98%E7%B2%BE%E4%BD%8E%E7%B2%BE">4.1. 高精÷低精</a></li>
<li><a href="#42-%E9%AB%98%E7%B2%BE%E9%AB%98%E7%B2%BE">4.2. 高精÷高精</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<span id="more"></span>



<h2><span id="1-高精度加法高精高精">1. 高精度加法（高精+高精）</span></h2><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量,初始化每个元素都为0</span></span><br><span class="line"><span class="type">int</span> a[MAX_SIZE];</span><br><span class="line"><span class="type">int</span> b[MAX_SIZE];</span><br><span class="line"><span class="type">int</span> c[MAX_SIZE<span class="number">+1</span>]; <span class="comment">// 最多200+1位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 高精度加法问题</span></span><br><span class="line">	<span class="comment">// 输入大整数</span></span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> n1=s<span class="number">1.l</span>ength();</span><br><span class="line">	<span class="type">int</span> n2=s<span class="number">2.l</span>ength();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序存储大整数到数组中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		a[i]=s1[n1<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">		b[i]=s2[n2<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 模拟竖式加法进行计算</span></span><br><span class="line">	<span class="type">int</span> n3=<span class="built_in">max</span>(n1,n2)<span class="number">+1</span>; <span class="comment">// 最多再进一位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n3;i++) &#123;</span><br><span class="line">		c[i]+=a[i]+b[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i]/<span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">// c[i+1]+=c[i]/10; // 这里也可以改为c[i+1]+=1 因为最多也就9+9=18,进1位</span></span><br><span class="line">			c[i<span class="number">+1</span>]+=<span class="number">1</span>;</span><br><span class="line">			c[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[n3]==<span class="number">0</span> &amp;&amp; n3&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		n3--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n3;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>; <span class="comment">// 最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加引用是为了提高效率,没有引用的话会再copy一遍</span></span><br><span class="line"><span class="comment">// C=A+B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 保留上一位的进位</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// &quot;||&quot;保证了A和B谁的数位更高或更低都能计算</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || i&lt;B.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果最高位还要进位的话,就补个1</span></span><br><span class="line">	<span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> C=<span class="built_in">add</span>(A,B); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-高精度减法高精-高精">2. 高精度减法（高精-高精）</span></h2><blockquote>
<p>重点在于判定是A大还是B大</p>
</blockquote>
<ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="type">int</span> c[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 高精度减法两种情况</span></span><br><span class="line">	<span class="comment">// 输入大整数</span></span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> n1=s<span class="number">1.l</span>ength();</span><br><span class="line">	<span class="type">int</span> n2=s<span class="number">2.l</span>ength();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断哪个数字更大</span></span><br><span class="line">	<span class="keyword">if</span>(n1&lt;n2 || (n1==n2 &amp;&amp; s1&lt;s2)) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(s1,s2);</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		<span class="comment">// 如果交换了,n1和n2要更新一下</span></span><br><span class="line">		n1=s<span class="number">1.l</span>ength();</span><br><span class="line">		n2=s<span class="number">2.l</span>ength();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序存储,最后都用a-b</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		a[i]=s1[n1-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">		b[i]=s2[n2-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 竖式相减</span></span><br><span class="line">	<span class="type">int</span> n3=<span class="built_in">max</span>(n1,n2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n3;i++) &#123;</span><br><span class="line">		c[i]+=a[i]-b[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			c[i<span class="number">+1</span>]--;</span><br><span class="line">			c[i]+=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[n3]==<span class="number">0</span> &amp;&amp; n3&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		n3--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n3;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">			<span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明A==B,也是A&gt;=B的子集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C=A-B(A&gt;=B)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 保留进位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		t=A[i]-t;</span><br><span class="line">		<span class="comment">// 判断B[i]是否存在,因为B的位数可能比A更小</span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t-=B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>((t<span class="number">+10</span>)%<span class="number">10</span>); <span class="comment">// 如果t&gt;=0,则(t+10)%10=t;如果t&lt;0,则(t+10)%10变为正数</span></span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=<span class="number">1</span>; <span class="comment">// 借位,再算下一位的时候要多减去一个1</span></span><br><span class="line">		<span class="keyword">else</span> t=<span class="number">0</span>; <span class="comment">// 不借位</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去前导0(vector做高精加的话就不会出现前导0,相减的话可能出现003这种数字)</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B)) &#123;</span><br><span class="line">		<span class="keyword">auto</span> C=<span class="built_in">sub</span>(A,B);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> C=<span class="built_in">sub</span>(B,A);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-高精度乘法">3. 高精度乘法</span></h2><h3><span id="31-高精低精">3.1. 高精×低精</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> len1,len2;</span><br><span class="line"><span class="type">int</span> a[N],b,c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1||t;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=len1) t+=a[i]*b;</span><br><span class="line">		c[++len2]=t%<span class="number">10</span>;</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[len2]==<span class="number">0</span> &amp;&amp; len2&gt;<span class="number">1</span>) len2--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;str&gt;&gt;b;</span><br><span class="line">	len1=str.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++) a[i]=str[len1-i]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将数a倒序</span></span><br><span class="line">	<span class="built_in">mul</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len2;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;c[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果有&quot;||t&quot;就不用单独处理剩余的t了,只要t不是0就会一直处理t的进位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || t;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i]*b;</span><br><span class="line">		C.<span class="built_in">push_back</span>(t%<span class="number">10</span>); <span class="comment">// 只取个位</span></span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理最后剩余的t</span></span><br><span class="line"><span class="comment">//	while(t) &#123;</span></span><br><span class="line"><span class="comment">//		C.push_back(t%10);</span></span><br><span class="line"><span class="comment">//		t/=10;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">// 为了避免1234*0=0000的这种情况,还是需要去除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C=<span class="built_in">mul</span>(A,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-高精高精">3.2. 高精×高精</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s1[MAXN];</span><br><span class="line"><span class="type">char</span> s2[MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="type">int</span> c[MAXN+MAXN]; <span class="comment">// 100(3)*100(3)=10000(6)</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 高精度乘法</span></span><br><span class="line">	<span class="comment">// 输入大整数</span></span><br><span class="line">	<span class="comment">// 这里如果用gets,在信奥一本通上无法通过</span></span><br><span class="line">	<span class="comment">// cin.getline(s1,MAXN);</span></span><br><span class="line">	<span class="comment">// cin.getline(s2,MAXN);</span></span><br><span class="line">	cin&gt;&gt;s1;</span><br><span class="line">	cin&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> n1=<span class="built_in">strlen</span>(s1);</span><br><span class="line">	<span class="type">int</span> n2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		a[i]=s1[n1-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">		b[i]=s2[n2-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 竖式乘法</span></span><br><span class="line">	<span class="type">int</span> n3=n1+n2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n2;j++) &#123;</span><br><span class="line">			c[i+j]+=a[i]*b[j];</span><br><span class="line">			<span class="keyword">if</span>(c[i+j]&gt;=<span class="number">10</span>) <span class="comment">// 说明要进位</span></span><br><span class="line">			&#123;</span><br><span class="line">				c[i+j<span class="number">+1</span>]+=c[i+j]/<span class="number">10</span>;</span><br><span class="line">				c[i+j]%=<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	// 处理进位问题</span></span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;n3;i++) &#123;</span></span><br><span class="line"><span class="comment">//		c[i+1]+=c[i]/10; </span></span><br><span class="line"><span class="comment">//		c[i]%=10;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 处理前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[n3]==<span class="number">0</span> &amp;&amp; n3&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		n3--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n3;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">C</span><span class="params">(A.size()+B.size(),<span class="number">0</span>)</span>; <span class="comment">// C最大数位为size_A+size_B,如100(3)×100(3)=10000(5)</span></span><br><span class="line">	<span class="comment">// 对C预开大小,是为了用类似于数组的方式来操控C</span></span><br><span class="line">	<span class="comment">// 因为A[i]要乘以每一位B[j]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.size();i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;B.size();j++) &#123;</span><br><span class="line">			C[i+j]+=A[i]*B[j];</span><br><span class="line">			<span class="comment">// 说明需要进位</span></span><br><span class="line">			<span class="keyword">if</span>(C[i+j]&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">				C[i+j+<span class="number">1</span>]+=C[i+j]/<span class="number">10</span>;</span><br><span class="line">				C[i+j]%=<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去除前导0,因为开了大小为A.size()+B.size()的全为0的数组,有可能用不完这些空间</span></span><br><span class="line">	<span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>) C.pop_back();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.push_back(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.push_back(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C=mul(A,B);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;C[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-高精度除法">4. 高精度除法</span></h2><h3><span id="41-高精低精">4.1. 高精÷低精</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N[maxn]; <span class="comment">// 存放大整数</span></span><br><span class="line"><span class="type">int</span> ans[maxn]; <span class="comment">// 存放商数</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">13</span>; <span class="comment">// 余数</span></span><br><span class="line"><span class="comment">// 高精度除以低精度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> n1=s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		ans[i]=(x*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>))/b; <span class="comment">// 记录余数</span></span><br><span class="line">		x=(x*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>))%b; <span class="comment">// 余数继续参与计算</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去除ans的前导0</span></span><br><span class="line">	<span class="type">int</span> n2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ans[n2]==<span class="number">0</span> &amp;&amp; n2&lt;n1) &#123;</span><br><span class="line">		n2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印出商数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n2;i&lt;n1;i++) &#123;</span><br><span class="line">		cout&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 打印余数</span></span><br><span class="line">	cout&lt;&lt;x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传地址方便直接对余数r进行修改</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> B,<span class="type">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		r=r*<span class="number">10</span>+A[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(r/B); <span class="comment">// 商</span></span><br><span class="line">		r=r%B; <span class="comment">// 余数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 由于除法运算中高位到低位运算,因此C的前导0都在vector的前面而不是尾部</span></span><br><span class="line">	<span class="comment">// 所以反转C,这样0就位于数组尾部,从而用pop删除前导0</span></span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="type">int</span> B,r=<span class="number">0</span>; <span class="comment">// 代表余数</span></span><br><span class="line">	cin&gt;&gt;str&gt;&gt;B;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++) A.<span class="built_in">push_back</span>(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C=<span class="built_in">div</span>(A,B,r);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i]; <span class="comment">// 再逆序一遍变成正序</span></span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl; <span class="comment">// 余数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="42-高精高精">4.2. 高精÷高精</span></h3><blockquote>
<p>用数组模拟是非常麻烦的，这里只介绍基于STL库中的vector实现方法</p>
</blockquote>
<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较A和B谁更大</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]!=B[i]) <span class="keyword">return</span> A[i]&gt;B[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用高精度减法来模拟高精度除法(高精÷高精)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||t;i++)&#123;</span><br><span class="line">		t = A[i] - t;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>((t<span class="number">+10</span>)%<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r:存储每次迭代后的余数</span></span><br><span class="line"><span class="comment">// C:存储每次返回后组成的商数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B, vector&lt;<span class="type">int</span>&gt; &amp;r)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C; </span><br><span class="line">	<span class="type">int</span> j = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 比如12345÷67,j=2,那么初始余数就为45</span></span><br><span class="line">	r.<span class="built_in">assign</span>(A.<span class="built_in">end</span>()-j,A.<span class="built_in">end</span>()); <span class="comment">// 初始化余数r为A的最后j位</span></span><br><span class="line">	<span class="comment">// 当j小于等于A的长度时循环</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;=A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 当余数r大于等于B时循环</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cmp</span>(r,B))&#123;</span><br><span class="line">			<span class="comment">// 利用高精减计算r-B的结果</span></span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; s = <span class="built_in">sub</span>(r,B);</span><br><span class="line">			r.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="comment">// 将结果赋值给r</span></span><br><span class="line">			r.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">			k++; <span class="comment">// 商+1</span></span><br><span class="line">		&#125; </span><br><span class="line">		C.<span class="built_in">push_back</span>(k); <span class="comment">// 存储商</span></span><br><span class="line">		<span class="comment">// 如果j小于A的长度,则将A中的下一位加入到余数r的最前面</span></span><br><span class="line">		<span class="keyword">if</span>(j&lt;A.<span class="built_in">size</span>()) r.<span class="built_in">insert</span>(r.<span class="built_in">begin</span>(),A[A.<span class="built_in">size</span>()-j<span class="number">-1</span>]);</span><br><span class="line">		<span class="comment">// 去掉余数0,因为随时要进行下一轮的计算</span></span><br><span class="line">		<span class="keyword">if</span>(r.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;r.<span class="built_in">back</span>()==<span class="number">0</span>) r.<span class="built_in">pop_back</span>();</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 反转结果,因为要利用高精减必须从低位开始</span></span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 去掉前导0</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A,B,r;</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> C = <span class="built_in">div</span>(A,B,r);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
</search>
