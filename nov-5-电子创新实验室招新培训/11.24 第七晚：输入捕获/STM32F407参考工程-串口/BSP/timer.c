#include "timer.h"
#include "led.h"
#include "usart.h"

//TIM14 PWM部分初始化 
//PWM输出初始化
//arr：自动重装值
//psc：时钟预分频数
void TIM14_PWM_Init(u32 arr,u32 psc)
{		 					 
	//此部分需手动修改IO口设置
	
	GPIO_InitTypeDef GPIO_InitStructure;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	TIM_OCInitTypeDef  TIM_OCInitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14,ENABLE);  	//TIM14时钟使能    
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE); 	//使能PORTF时钟	
	
	GPIO_PinAFConfig(GPIOF,GPIO_PinSource9,GPIO_AF_TIM14); //GPIOF9复用位定时器14
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //GPIOA9 
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	//速度100MHz
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉
	GPIO_Init(GPIOF,&GPIO_InitStructure); //初始化PF9
	
	TIM_TimeBaseStructure.TIM_Prescaler=psc;  //定时器分频
	TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上计数模式
	TIM_TimeBaseStructure.TIM_Period=arr;   //自动重装载值
	TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1; // 不分频
	
	TIM_TimeBaseInit(TIM14,&TIM_TimeBaseStructure);
	
	// 初始化TIM14 Channel1 PWM模式	 
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //选择定时器模式:TIM脉冲宽度调制模式2
 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low; //输出极性:TIM输出比较极性高
	TIM_OCInitStructure.TIM_Pulse=0;
	TIM_OC1Init(TIM14, &TIM_OCInitStructure);  //根据T指定的参数初始化外设TIM3 OC2

	TIM_OC2PreloadConfig(TIM14, TIM_OCPreload_Enable);  //使能TIM3在CCR2上的预装载寄存器
 
	TIM_ARRPreloadConfig(TIM14,ENABLE);
	
	TIM_Cmd(TIM14, ENABLE);  //使能TIM14		

}  

// 定义为全局变量
TIM_ICInitTypeDef  TIM5_ICInitStructure; // 输入捕获初始化结构体

//定时器5通道1输入捕获配置
//arr：自动重装值(TIM2,TIM5是32位的!!)
//psc：时钟预分频数
void TIM5_CH1_Cap_Init(u32 arr,u16 psc)
{
	GPIO_InitTypeDef GPIO_InitStructure; // GPIO初始化结构体→配置PA0
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure; // 定时器基础初始化结构体
	NVIC_InitTypeDef NVIC_InitStructure; // 嵌套向量中断控制器初始化结构体→设置中断优先级等
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // 设置系统中断优先级分组2

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5,ENABLE);  	// TIM5时钟使能 
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); 	// 使能PORTA时钟	

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; // GPIOA0
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; // 复用功能
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	// 速度100MHz
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // 推挽复用输出
	// 下拉→无信号输入时处于低电平状态，因为我们首先捕获上升沿再捕获下降沿，这样设计符合逻辑需求
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN; // 下拉
	GPIO_Init(GPIOA,&GPIO_InitStructure); // 初始化PA0

	GPIO_PinAFConfig(GPIOA,GPIO_PinSource0,GPIO_AF_TIM5); // PA0复用位定时器5
	  
	TIM_TimeBaseStructure.TIM_Prescaler=psc;  // 定时器分频
	TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; // 向上计数模式
	TIM_TimeBaseStructure.TIM_Period=arr;   // 自动重装载值
	TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1; // 不分频

	TIM_TimeBaseInit(TIM5,&TIM_TimeBaseStructure);

	// 初始化TIM5输入捕获参数
	TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; // 使用TIM5_CH1
	TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	// 上升沿捕获
	TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; // TI是Timer Input，表示直接映射到输入信号端
	TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	 // 配置输入分频,不分频 
	TIM5_ICInitStructure.TIM_ICFilter = 0x00; // IC1F=0000 配置输入滤波器 不滤波（输入捕获信号可能守电磁干扰或噪声影响）
	TIM_ICInit(TIM5, &TIM5_ICInitStructure);
		
	TIM_ITConfig(TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE); // 允许更新中断 ,允许CC1IE捕获中断	

	TIM_Cmd(TIM5,ENABLE ); 	//使能定时器5

	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2; // 抢占优先级2
	NVIC_InitStructure.NVIC_IRQChannelSubPriority =0;		// 子优先级0
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			// IRQ通道使能
	NVIC_Init(&NVIC_InitStructure);	// 根据指定的参数初始化NVIC寄存器
}
// 捕获状态
// [7]:0, 没有成功的捕获;1,成功捕获到一个完整周期
// [6]:0, 还没捕获到下降沿; 1,已经捕获到下降沿了.
// [5:0]: 捕获低电平后溢出的次数
u8  TIM5CH1_CAPTURE_STA=0;	// 输入捕获状态，STA表示status的意思		    				
u32	TIM5CH1_CAPTURE_VAL;	// 输入捕获值(TIM2/TIM5是32位)
// 定时器5中断服务程序	 
// 中断服务程序会在两种情况下进入，发生TIM_IT_Update事件（更新溢出时间）、TIM_IT_CC1事件（输入捕获事件）
void TIM5_IRQHandler(void)
{ 		    
	// 0X80→1000 0000(最高位是1)，与运算，为1表示捕获到上升沿→转而去捕获下降沿
 	if((TIM5CH1_CAPTURE_STA&0X80)==0) // 还未成功捕获	
	{
		// TIM_IT_Update→中断溢出时间，==RESET 未溢出，==SET 溢出
		if(TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)//溢出
		{	     
			// 0X40→0100 0000，与运算，为1表示捕获到下降沿，为0表示未捕获到下降沿
			// 已经捕获到下降沿
			if(TIM5CH1_CAPTURE_STA&0X40)
			{
				// 但是计时器溢出了，说明高电平持续时间太长了，计时器都溢出了还没捕获到下降沿，...
				if((TIM5CH1_CAPTURE_STA&0X3F)==0X3F)
				{
					// 或运算，把最高位置1，表示成功捕获到一次
					TIM5CH1_CAPTURE_STA|=0X80;	// 标记成功捕获了一次 
					TIM5CH1_CAPTURE_VAL=0XFFFFFFFF; // 把这次捕获标记为异常，都溢出了0X3F次了还没捕获到，只好标记为异常了
				}
				else TIM5CH1_CAPTURE_STA++; // 否则STA++
			}	 
		}
		
		// TIM_IT_CC1：通道1发生输入捕获事件
		// RESET→未发生，SET→发生
		// 检测到上升沿或下降沿时会触发捕获事件
		
		if(TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET) // 通道1发生捕获事件
		{	
			// 一开始走else，因为初始化的时候默认捕捉上升沿
			if(TIM5CH1_CAPTURE_STA&0X40)	// 捕获下降沿的时候走这条，表示经过一次完整捕获	
			{	  			
				TIM5CH1_CAPTURE_STA|=0X80;	// 标记成功捕获到一次高电平脉宽
			  TIM5CH1_CAPTURE_VAL=TIM_GetCapture1(TIM5); // 获取当前的捕获值.
	 			TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); // CC1P=0 设置为上升沿捕获
			}
			else 
			{
				// 因为是一个过程的开始，所以把STA和VAL置为0，表示一个周期的开始
				TIM5CH1_CAPTURE_STA=0; 
				TIM5CH1_CAPTURE_VAL=0;
				// 触发了中断，但不是更新事件，说明发生了捕获事件 → 捕获到上升沿
				TIM5CH1_CAPTURE_STA|=0X40; // 把第六位变成1，表示捕获到上升沿了，现在去捕获下降沿
				TIM_Cmd(TIM5,DISABLE );  // 关闭定时器5
	 			TIM_SetCounter(TIM5,0); // TIM5的CNT清0，这样捕获到下降沿的时候，把CNT与0相减就是我们的值
	 			TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling);	 // 设置为下降沿捕获
				TIM_Cmd(TIM5,ENABLE ); 	// 使能定时器5
			}		    
		}			     	    					   
 	}
	TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update); // 清除中断标志位，这样就可以接受下一次中断
}