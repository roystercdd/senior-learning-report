<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="生活,思考,代码,博客,摄影" />
       
      <meta name="description" content="欢迎光临CDD的个人网站~~~" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 漂至</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/deadpool.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="漂至" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">漂至</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['生有热烈，藏与俗常', '没有人永远叛逆，但永远有人叛逆', '保持善良茁壮成长活着活着就要像太阳'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-乘法逆元"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/07/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"
    >乘法逆元</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/07/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/" class="article-date">
  <time datetime="2024-10-07T02:44:53.000Z" itemprop="datePublished">2024-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="乘法逆元">乘法逆元</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9D%BF%E5%AD%90">1. 板子</a></li>
<li><a href="#2-%E6%80%A7%E8%B4%A8">2. 性质</a></li>
<li><a href="#3-%E7%BA%BF%E6%80%A7%E6%B1%82%E9%80%86%E5%85%83%E6%9D%BF%E5%AD%90">3. 线性求逆元板子</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>同余式：如果 $a,b$ 模 $m$ 的余数相同，则称 $a,b$ 模 $m$ 同余，记为 $a\equiv b$，例如：$8 \equiv 2\ (mod\ 3)$</p>
</li>
<li><p>乘法逆元：若 $a,b$ 互质，且满足同余方程 $ax\equiv 1\ (mod \ b)$，则称 $x$ 为 $a\ mod \ b$ 的乘法逆元，记作 $a^{-1}$，例如：$8x \equiv 1\ (mod\ 5)$，解得 $x&#x3D;2,7,12…$</p>
</li>
<li><p>费马小定理：若 $p$ 为质数，且 $a,p$ 互质，则 $a^{p-1}\equiv1\ (mod\ p)$，例如：$4^{3-1}\equiv 1(mod\ 3)$</p>
</li>
<li><p>费马小定理求乘法逆元：$a^{p-1}\equiv1\ (mod\ p)$，得 $a×a^{p-2}\equiv 1\ (mod\ p)$，根据乘法逆元的定义，所以 $a^{p-2}$ 就是 $a$ 模 $p$ 的乘法逆元</p>
</li>
</ul>
<h2><span id="1-板子">1. 板子</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 幂取余,a^b%p</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>; <span class="comment">// 累乘因子</span></span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*a%p; <span class="comment">// 提权</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;p;</span><br><span class="line">    <span class="comment">// 快速幂计算a^(p-2),就是a%p的乘法逆元</span></span><br><span class="line">    <span class="comment">// 如果a,p互质,才有a%p乘法逆元</span></span><br><span class="line">    <span class="keyword">if</span>(a%p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qmi(a,p<span class="number">-2</span>,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-性质">2. 性质</span></h2><ul>
<li><p>$14&#x2F;4\ (mod\ 5)&#x3D;7&#x2F;2 \ (mod\ 5)&#x3D;7×3\ (mod\ 5)$，这是因为 $2×3\ mod\ 5&#x3D;1$，也可以理解为 $3$ 和 $2$ 在模 $5$ 下互为倒数</p>
</li>
<li><p>求乘法逆元的方法：$2^{-1} \ mod\ 7$，模  $7$ 下 $2$ 的乘法逆元是，求谁乘以 $2$ 再模 $7$ 等于 $1$，很容易口算得到 $4×2\ (mod\ 7)&#x3D;1$</p>
<ul>
<li>通过费马小定理计算，$a^{p-2}$ 即 $2^{7-2}&#x3D;32$</li>
<li>模 $n$ 下互为乘法逆元，一般只考虑比 $n$ 小的，所以 $32$ 对 $7$ 取模得到 $4$，那么模 $7$ 下 $2$ 的乘法逆元是 $4$</li>
</ul>
</li>
<li><p>$a$ 在模 $n$ 内的乘法逆元 $a^{-1}\ (1&lt;&#x3D;a^{-1}&lt;n)$ 是唯一的，比如模 $5$ 下 $2$ 和 $3$ 互为乘法逆元，除此外再无别的逆元</p>
</li>
<li><p>$1$  不管模谁都是余 $1$</p>
</li>
<li><p>$a$ 的乘法逆元的乘法逆元是 $a$，$z&#x3D;a^{-1},\ z^{-1}&#x3D;(a^{-1})^{-1}&#x3D;a$</p>
</li>
<li><p><strong>什么时候用乘法逆元？当题目中推导出来的公式带有除法，并且要让结果对某个数作模运算时</strong>，应用乘法逆元把除法变为乘法，一直除再作模运算是会出错的，可以这样想，加减乘都是从低位起开始运算，只有除法是从高位开始运算，而模运算又是取低几位，所以应该把除法转换为乘法</p>
</li>
</ul>
<h2><span id="3-线性求逆元板子">3. 线性求逆元板子</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">3e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="comment">// 给定n,p,计算1~n中所有整数在模p意义下的乘法逆元</span></span><br><span class="line"><span class="comment">// a模p的乘法逆元定义为 a*a_inv等价于1(mod p),去找a_inv是多少</span></span><br><span class="line"><span class="comment">// 线性求逆元</span></span><br><span class="line"><span class="type">int</span> inv[maxn]; <span class="comment">// 存储每个数字的逆元</span></span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,p;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p; <span class="comment">// n是范围,p是模数</span></span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">// 1的逆元是1, (1*1)mod p=1</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;inv[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		inv[i]=-(p/i)*inv[p%i]; <span class="comment">// x_inv=-k*r_inv (怎么推导的···看b站视频吧)</span></span><br><span class="line">		inv[i]=(inv[i]%p+p)%p; <span class="comment">// 防止负数产生</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;inv[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/" rel="tag">乘法逆元</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-欧拉筛"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/07/%E6%AC%A7%E6%8B%89%E7%AD%9B/"
    >欧拉筛</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/07/%E6%AC%A7%E6%8B%89%E7%AD%9B/" class="article-date">
  <time datetime="2024-10-07T02:40:26.000Z" itemprop="datePublished">2024-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E7%B1%BB/">分类</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="欧拉筛">欧拉筛</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E4%BC%A0%E7%BB%9F%E6%89%BE%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%9B%E9%80%89%E6%AC%A1%E6%95%B0">1. 传统找质数的方法（优化筛选次数）</a></li>
<li><a href="#2-%E6%AC%A7%E6%8B%89%E7%AD%9B">2. 欧拉筛</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-传统找质数的方法优化筛选次数">1. 传统找质数的方法（优化筛选次数）</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要找从 $[1,1e6]$ 中的所有质数，时间复杂度很高</li>
</ul>
<h2><span id="2-欧拉筛">2. 欧拉筛</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230720102317937.png" alt="image-20230720102317937"></p>
<ul>
<li>算法思想：遍历到 $2$ 的时候，筛掉范围内所有 $2$ 的倍数（因为除了 $1$ 和自身以外，一定能被 $2$ 整除），到 $3$ 的时候，筛掉所有 $3$ 的倍数···</li>
<li>注意：如果计算 $[l,r]$ 之间出现的质数的个数？可以用前缀和的思想；当 $n$ 过大时，$i×i$ 容易出现数组越界的错误，即可能 $RuntimeError$ ，此时要将线性筛中第二个 $for$ 中的 $j&#x3D;i×i$ 改为 $j&#x3D;i+i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 下标为i时,记录1~i出现的所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 是否已经访问过</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 用于存放素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx是存放素数的遍历因子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果vis[i]为false才需要遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]<span class="number">+1</span>; <span class="comment">// 计算前缀和</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 是素数,存起来</span></span><br><span class="line">            <span class="comment">// 如果出现RuntimeError,将j=i+i,这样就不会数组越界</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) <span class="comment">// 将素数i的倍数全部标记为合数,则无需遍历</span></span><br><span class="line">				vis[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如:输入1000即打印0~1000以内的素数</span></span><br><span class="line">	cin&gt;&gt;n;  </span><br><span class="line">	<span class="type">int</span> l,r; <span class="comment">// 左右区间</span></span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">get_primes</span>(n);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;1~&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;之间的素数分别是:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=idx;i++) &#123;</span><br><span class="line">		cout&lt;&lt;p[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=idx)</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot;所出现的素数个数为:&quot;</span>&lt;&lt;f[r]-f[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最简单的模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+5</span>; <span class="comment">// 注意这里没有开到2^9,只要比sqrt(2^9)大即可</span></span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> ans[N],len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++) &#123;</span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么特判x&gt;=N的情况?因为为了节省内存或者没必要,本题中只要保证MAXN比sqrt(理论最大值)大即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> !st[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;primes[i]&lt;=x/primes[i];i++)</span><br><span class="line">		<span class="keyword">if</span>(x%primes[i]==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B/" rel="tag">欧拉筛</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-快速幂"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/07/%E5%BF%AB%E9%80%9F%E5%B9%82/"
    >快速幂</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/07/%E5%BF%AB%E9%80%9F%E5%B9%82/" class="article-date">
  <time datetime="2024-10-07T02:35:27.000Z" itemprop="datePublished">2024-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="快速幂">快速幂</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%BA%94%E7%94%A8%E4%B8%80-%E5%B9%82%E5%8F%96%E4%BD%99%E8%AE%A1%E7%AE%97-anmod-m">1. 应用一、幂取余：计算 $a^n(mod\ m)$</a></li>
<li><a href="#2-%E5%BA%94%E7%94%A8%E4%BA%8C-%E8%AE%A1%E7%AE%97%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">2. 应用二、计算斐波那契数列的第n项【矩阵快速幂】</a></li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E4%B8%89-%E5%B0%86%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E9%87%8D%E5%A4%8D-n-%E6%AC%A1%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">3. 应用三、将线性变换重复 $n$ 次【矩阵快速幂】</a></li>
<li><a href="#4-%E5%BA%94%E7%94%A8%E5%9B%9B-%E6%9E%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E9%BE%9F%E9%80%9F%E4%B9%98">4. 应用四、极斐波那契【矩阵快速幂+龟速乘】</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726135336870.png" alt="image-20230726135336870" style="zoom:67%;">

<ul>
<li>关键在于把a的n次方中的n拆分成二进制的表示形式</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726135625768.png" alt="image-20230726135625768" style="zoom: 80%;">

<ul>
<li><p>对于 $n$ 的二进制，我们从低到高不断遍历每一位，如果遍历到的那一位是 $1$ ，就 $r×a$</p>
</li>
<li><p>伪代码中的 $n(mod\ 2)$ 可以用 $n&amp;1$ 来表示，$n&#x3D;floor(n&#x2F;2)$ 也可以用无符号右移一位来表示，即 $n&gt;&gt;2$</p>
</li>
</ul>
<h2><span id="1-应用一-幂取余计算-anmod-m">1. 应用一、幂取余：计算 $a^n(mod\ m)$</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726140139764.png" alt="image-20230726140139764" style="zoom:67%;">

<ul>
<li>只需要在快速幂算法中合适的位置上加上 $mod\ m$，即可得到幂取模的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算a的n次方模m</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ModExpFast</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	a=a%m;</span><br><span class="line">	res=<span class="number">1</span>; <span class="comment">// 乘法操作的初始值(累积变量)</span></span><br><span class="line">	<span class="keyword">while</span>(n!=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">			res=(res*a)%m;</span><br><span class="line">		&#125;</span><br><span class="line">		a=(a*a)%m;</span><br><span class="line">		n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res; <span class="comment">// 得到最终的余数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,n,m;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot;^&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; mod &quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">ModExpFast</span>(a,n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>幂取模运算在密码学和数论中有着非常重要的应用，比如，幂取模运算是RSA公钥加密的核心运算之一。</li>
</ul>
<h2><span id="2-应用二-计算斐波那契数列的第n项矩阵快速幂">2. 应用二、计算斐波那契数列的第n项【矩阵快速幂】</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726142215151.png" alt="image-20230726142215151" style="zoom:67%;">

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240207111727658.png" alt="image-20240207111727658" style="zoom:80%;">

<ul>
<li><p>以上是适用于矩阵快速幂的数据范围</p>
</li>
<li><p>只需要计算出 $[1\ 1; 1\ 0]$ 的 $n$次方和已知 $F0$ 与 $F1$，就可以计算出第 $n$ 项</p>
</li>
<li><p>以下是一个利用矩阵快速幂计算第 $n$ 项并维护前 $n$ 项和的矩阵快速幂模板</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 矩阵快速幂求斐波那契数列,[fn, fn+1] × [0 1; 1 1]= f[n+1, fn+2]</span></span><br><span class="line"><span class="comment">// 这道题还要求斐波那契数列前n项的和,所以除了fn以外还需要维护Sn</span></span><br><span class="line"><span class="comment">// [fn, fn+1, sn] × [0 1 0; 1 1 0; 0 1 1] = f[n+1, fn+2, sn+1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3</span>; <span class="comment">// 矩阵3×3</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 本题要求计算出前n项和mod m的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维×二维两重循环,c=a*b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[],<span class="type">int</span> a[],<span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">			temp[i]=(temp[i]+(ll)a[j]*b[j][i])%m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意:传进来的指针和本身的指针有区别(形参),如果这里sizeof c</span></span><br><span class="line">	<span class="comment">// 传回来的是指针的长度,而不是数组的长度,所以sizeof temp</span></span><br><span class="line">	<span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维×二维三重循环,c=a*b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N],<span class="type">int</span> a[][N],<span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;N;k++) &#123;</span><br><span class="line">				temp[i][j]=(temp[i][j]+(ll)a[i][k]*b[k][j])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> f1[N]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">// f1,f2,s1;存储答案,f1[2]就是Sn</span></span><br><span class="line">	<span class="comment">// 推导出来的幂矩阵</span></span><br><span class="line">	<span class="type">int</span> a[N][N]= &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 计算f1×a^n</span></span><br><span class="line">	<span class="comment">// 迭代计算,类似于滚动数组,没有利用额外的空间</span></span><br><span class="line">	n--; <span class="comment">// 调整斐波那契数列的起始位置</span></span><br><span class="line">	<span class="comment">// 快速幂思想</span></span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="built_in">mul</span>(f1,f1,a); <span class="comment">// res=res*a,调用一维矩阵×二维矩阵的mul方程</span></span><br><span class="line">		<span class="built_in">mul</span>(a,a,a); <span class="comment">// a=a*a,调用二维矩阵×二维矩阵的mul方程</span></span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f1[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-应用三-将线性变换重复-n-次矩阵快速幂">3. 应用三、将线性变换重复 $n$ 次【矩阵快速幂】</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726142534642.png" alt="image-20230726142534642" style="zoom:67%;">



<h2><span id="4-应用四-极斐波那契矩阵快速幂龟速乘">4. 应用四、极斐波那契【矩阵快速幂+龟速乘】</span></h2><ul>
<li>对我来说有难度，暂时不上代码</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" rel="tag">快速幂</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-简单数论"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/07/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/"
    >简单数论</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/07/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/" class="article-date">
  <time datetime="2024-10-07T02:27:02.000Z" itemprop="datePublished">2024-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="简单数论">简单数论</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E8%B4%A8%E6%95%B0%E7%AD%9B">1. 质数筛</a></li>
<li><a href="#2-%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8B%86">2. 进制数拆</a></li>
<li><a href="#3-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0">3. 分解质因数</a></li>
<li><a href="#4-%E8%B4%A8%E6%95%B0%E7%AD%9B">4. 质数筛</a><ul>
<li><a href="#41-%E8%AF%95%E9%99%A4%E6%B3%95%E6%9E%9A%E4%B8%BE%E4%BC%98%E5%8C%96">4.1. 试除法（枚举优化）</a></li>
<li><a href="#42-%E6%AC%A7%E6%8B%89%E7%AD%9B">4.2. 欧拉筛</a></li>
</ul>
</li>
<li><a href="#5-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">5. 最大公约数与最小公倍数</a><ul>
<li><a href="#51-%E4%B8%A4%E4%B8%AA%E6%95%B0">5.1. 两个数</a></li>
<li><a href="#52-n%E4%B8%AA%E6%95%B0">5.2. n个数</a><ul>
<li><a href="#521-%E6%B1%82%E5%85%AC%E5%85%B1gcd">5.2.1. 求公共GCD</a></li>
<li><a href="#522-%E6%B1%82%E5%85%AC%E5%85%B1lcm">5.2.2. 求公共LCM</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-质数筛">1. 质数筛</span></h2><blockquote>
<p>先从最简单的质数开始吧，用优化遍历大小的朴素法或者欧拉筛(线性筛)可以完成，时间复杂度分别是O(n)和O(logn)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 最小的质数是2</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-进制数拆">2. 进制数拆</span></h2><blockquote>
<p>比如把任意一个正整数拆成二进制表现的形式，如7&#x3D;2的2次方+2的1次方+2的0次方</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n:待拆分十进制数</span></span><br><span class="line"><span class="comment">// m:拆分成多少进制的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>; <span class="comment">// 权</span></span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%m) &#123;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;<span class="string">&#x27;^&#x27;</span>&lt;&lt;s&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;<span class="built_in">pow</span>(m,s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			v.<span class="built_in">push_back</span>(<span class="built_in">pow</span>(m,s));</span><br><span class="line">		&#125;</span><br><span class="line">		n/=m;</span><br><span class="line">		s++;</span><br><span class="line">	&#125; cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		cout&lt;&lt;v[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=v.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;+&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-分解质因数">3. 分解质因数</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 分解质因数,一边找质因子一边将质因子的值和幂存储起来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[]:存储质因子,p[cnt]=x,第cnt个质因子是x</span></span><br><span class="line"><span class="comment">// g[]:存储质因子的幂,g[cnt]=y,第cnt个质因子是x,幂是y</span></span><br><span class="line"><span class="comment">// cnt:记录个数</span></span><br><span class="line"><span class="type">int</span> n,p[N],g[N],cnt; </span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime_fact</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i*i&lt;=n:枚举优化,从2开始,2是最小的质数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) cnt++; <span class="comment">// i是n的因子,cnt++</span></span><br><span class="line">		<span class="comment">// 计算i的幂</span></span><br><span class="line">		<span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			p[cnt]=i;</span><br><span class="line">			g[cnt]++; <span class="comment">// 次幂+1</span></span><br><span class="line">			n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分解完后如果n&gt;1,说明最终剩下的数字是一个质数,也单独算成质因数</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		p[++cnt]=n;</span><br><span class="line">		g[cnt]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">prime_fact</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;质因数: %d, 幂为:%d\n&quot;</span>,p[i],g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按唯一分解定理形式打印</span></span><br><span class="line">	cout&lt;&lt;n&lt;&lt;<span class="string">&quot;=&quot;</span>;</span><br><span class="line">	<span class="comment">// 遍历p,g数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="comment">// 打印g[i]次p[i]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=g[i];j++) &#123;</span><br><span class="line">			cout&lt;&lt;p[i];</span><br><span class="line">			<span class="keyword">if</span>(j!=g[i]) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(i!=cnt) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-质数筛">4. 质数筛</span></h2><h3><span id="41-试除法枚举优化">4.1. 试除法（枚举优化）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要找从 $[1,10000]$ 中的所有质数，时间复杂度很高</li>
</ul>
<h3><span id="42-欧拉筛">4.2. 欧拉筛</span></h3><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230720102317937.png" alt="image-20230720102317937"></p>
<ul>
<li>算法思想：遍历到 $2$ 的时候，筛掉范围内所有 $2$ 的倍数，到 $3$ 的时候，筛掉所有 $3$ 的倍数，被筛掉的数会被标记为合数，合数不会进入到 $if$ 中扩展其倍数，相当于每个数只被遍历过一次，因而时间复杂度是 $O(n)$，欧拉筛也被称为线性筛</li>
<li>注意：如果计算 $[l,r]$ 之间出现的质数的个数？可以用前缀和的思想；<br>当 $n$ 过大时，$i×i$ 容易出现数组越界的错误，即可能 $RuntimeError$，此时要将线性筛中第二个 $for$ 中的$j&#x3D;i×i$ 改为 $j&#x3D;i+i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 欧拉筛</span></span><br><span class="line"><span class="comment">  先从最小的质数开始,每次在数据范围内将它的倍数标记为合数,那么留下的一定是素数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// f[i]:记录1~i中所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]:i的访问状态</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存放1~n中所有素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx:找素数迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i未放问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]<span class="number">+1</span>; <span class="comment">// 计算前缀和,维护数量</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 存储素数</span></span><br><span class="line">			<span class="comment">// 如果出现RE,将j=i*i改成j=i+i,这样就不会越界</span></span><br><span class="line">			<span class="comment">// 将i的倍数全部标记为合数,无需遍历</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">get_primes</span>(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1~%d 之间的质数分别是:&quot;</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=idx;i++) &#123;</span><br><span class="line">		cout&lt;&lt;p[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=idx) cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125; cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d~%d 之间存在的质数个数是:%d\n&quot;</span>,l,r,f[r]-f[l<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-最大公约数与最小公倍数">5. 最大公约数与最小公倍数</span></h2><blockquote>
<p>辗转相除法的时间复杂度：近似 $O(max(a,b))$</p>
</blockquote>
<h3><span id="51-两个数">5.1. 两个数</span></h3><ul>
<li>辗转相除法（欧几里得算法）求解最大公约数，最小公倍数就是两数的成绩除以最大公约数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求两个数的最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>(m%n) &#123;</span><br><span class="line">		r=m%n;</span><br><span class="line">		m=n;</span><br><span class="line">		n=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简单易背的方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两数的最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCM</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m*n/<span class="built_in">GCD</span>(m,n);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3><span id="52-n个数">5.2. n个数</span></h3><h4><span id="521-求公共gcd">5.2.1. 求公共GCD</span></h4><ul>
<li>求多个数的 $GCD$ 的思路是先求两个数的 $GCD$，再用这个结果与后续的每一个数分别求出 $GCD$</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过循环求出公共GCD</span></span><br><span class="line">	<span class="type">int</span> res=a[<span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=gcd(res,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述求解方法的时间复杂度最坏是 $O(n^2)$，所以数据量比较大时，推荐用下述方法求解公共 $GCD$</li>
</ul>
<ol>
<li><p>对这组数从大到小排序</p>
</li>
<li><p>对每两个相邻的数 $A,B$（假设 $A$ 在前，故有 $A&gt;B$），如果 $A&#x3D;n×B$，则令 $A&#x3D;B$；否则令 $A&#x3D;A%B$</p>
</li>
<li><p>重复上述步骤，直到数组中每个数字都相同，此时这个数就为公共 $GCD$</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi_gcd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 直到所有数字相等</span></span><br><span class="line">	<span class="keyword">while</span>(a[<span class="number">1</span>]!=a[n]) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]%a[i+<span class="number">1</span>]==<span class="number">0</span>) a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> a[i]=a[i]%a[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="522-求公共lcm">5.2.2. 求公共LCM</span></h4><ul>
<li>同样的，我们可以对这组数据依次求最小公倍数，但是时间复杂度在最坏时达到 $O(n^2)$</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi_lcm</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=res*a[i]/gcd(res,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来介绍质因子分解法，如：求 $10,12,4$ 的最小公倍数<br>$① 10&#x3D;2×5,\ ② 12&#x3D;2×3×3,\ ③4&#x3D;2×2$<br>可见，$2$ 在①②③式中都出现了， $3$ 只在②式中出现， $5$ 只在①式中出现<br>所以最小公倍数：$2^3×3^1×5^1&#x3D;60$，即对每个质因子的最高次幂做乘积得到的就是公共 $LCM$</p>
</li>
<li><p>用这种方法也可以避免遍历时做乘法超出数据类型所能表示的最大范围的情况</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 求公共LCM</span></span><br><span class="line"><span class="comment">  1) 先用欧拉筛预处理出数据范围内所有质数</span></span><br><span class="line"><span class="comment">  2) 将数组a中的数字依次分解质因数,按照欧拉筛筛出来的质数分解</span></span><br><span class="line"><span class="comment">  3) 用一个map记录所有质因子出现的最小次数(计算GCD)或最大次数(计算LCM)</span></span><br><span class="line"><span class="comment">  4) 枚举map中的质因子及其出现次数乘在一起算出GCD和LCM即可</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// f[i]:记录1~i中所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]:i的访问状态</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存放1~n中所有素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx:找素数迭代器 </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m_max; <span class="comment">// m_max[i]:对a[i]进行质因数分解后每个质因数的最大次数</span></span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i未放问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>; <span class="comment">// 计算前缀和,维护数量</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 存储素数</span></span><br><span class="line">			<span class="comment">// 如果出现RE,将j=i*i改成j=i+i,这样就不会越界</span></span><br><span class="line">			<span class="comment">// 将i的倍数全部标记为合数,无需遍历</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_facts</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 对于数组a中的每一个数字,分解质因数,计算在这n个数中的最大次数	</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=idx;j++) &#123;</span><br><span class="line">			<span class="comment">// 剪枝,如p[j]×p[j]&gt;a[i],说明p[j]不可能为a[i]质因数</span></span><br><span class="line">			<span class="keyword">if</span>(p[j]*p[j]&gt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 遍历质数数组</span></span><br><span class="line">			<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 分解后p[i]的次数</span></span><br><span class="line">			<span class="keyword">while</span>(a[i]%p[j]==<span class="number">0</span>) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				a[i]/=p[j];</span><br><span class="line">			&#125;</span><br><span class="line">			m_max[p[j]]=max(m_max[p[j]],cnt); <span class="comment">// 更新质因数p[i]出现的最大次数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 本身是质数</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			m_max[a[i]]=<span class="number">1</span>; <span class="comment">// 次幂只能为1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	get_primes(<span class="number">1000</span>);</span><br><span class="line">	get_facts(a);</span><br><span class="line">	<span class="comment">// 打印测试</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it=m_max.begin();it!=m_max.end();it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=it-&gt;second;i++) &#123;</span><br><span class="line">			res*=(it-&gt;first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 公共LCM</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">12 24 30 32 36 42</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">10080</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-KMP算法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/07/KMP%E7%AE%97%E6%B3%95/"
    >KMP算法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/07/KMP%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2024-10-07T02:22:05.000Z" itemprop="datePublished">2024-10-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="kmp算法">KMP算法</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84">1. 求解next数组</a></li>
<li><a href="#2-%E6%B1%82%E8%A7%A3%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">2. 求解匹配位置的核心函数</a></li>
<li><a href="#3-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">3. 完整代码</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>在做模式串与文本串的匹配问题时，匹配失败时，如果每次都只向后递进一位，时间复杂度为 $O(n+m)$，很容易被卡成 $O(m×n)$ ，所以为了降低字符串匹配算法的时间复杂度，对模式串中的每一位，设置<strong>唯一</strong>的<strong>特定变化位置</strong>，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间</li>
<li><strong>如果主串已匹配相等的前缀序列中有某个后缀恰等于模式串的前缀，那么可以直接将模式串向后滑动到与这些相等字符对其的位置</strong>，用 $ne$ 数组记录到它为止的<strong>模式串前缀的真前缀和真后缀最大相同的位置</strong></li>
<li>当 $i&#x3D;1$ 或 $i&#x3D;2$ 时，$ne[i]$ 的返回值是 $1$，即 $ne[1]&#x3D;ne[2]&#x3D;1$ (当下标从 $1$ 开始)，因为当 $n&#x3D;1$ 时（只有一个元素，此时无前后缀），当 $n&#x3D;2$ 时（两个元素，一个是前缀一个是后缀，仍然回溯到第一个位置）</li>
</ul>
<h2><span id="1-求解next数组">1. 求解next数组</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求next数组的过程[s1与自己匹配,通过前后缀来更新ne数组]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s1[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">        j=ne[j]; <span class="comment">// 如果不匹配的话,j就一直后退</span></span><br><span class="line">    <span class="keyword">if</span>(s1[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">        j++; <span class="comment">// 如果当前匹配成功的,j向前递推一位</span></span><br><span class="line">    ne[i]=j; <span class="comment">// 记录并且更新当前j的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当看不懂或者忘了的时候建议自己调试模拟跟踪一遍</p>
</li>
<li><p>因为 $ne$ 数组是全局初始化，$while()$ 语句中的 $j$ 保证了 $ne[1]&#x3D;ne[2]$ </p>
</li>
<li><p>注意next数组的值是根据模式串的前缀和后缀的最大相同位置来的，所以匹配自己。</p>
</li>
</ul>
<h2><span id="2-求解匹配位置的核心函数">2. 求解匹配位置的核心函数</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求匹配的过程[i遍历文本串]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len2;i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果不匹配的话,j回退</span></span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s2[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="comment">// 如果相等的话,j向前递推一位</span></span><br><span class="line">    <span class="keyword">if</span>(s2[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 刚好长度相等的话说明匹配上了,把下标打印出来</span></span><br><span class="line">    <span class="keyword">if</span>(j==len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文本串的位置减去长度即为下标,加1得到位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-len1<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">        <span class="comment">// 需要让j回退到一定位置,再让i加1继续进行比较</span></span><br><span class="line">        <span class="comment">// 回退到ne[j]可以保证j最大,即已经成功匹配的部分最长</span></span><br><span class="line">        j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心实现和求解 $next$ 数组的函数差不多，主要是是模式串和文本串之间的匹配，当 $j&#x3D;&#x3D;len1$ 的时候说明大小相等即匹配上了，这个时候把相应的下标位置输出出来，同时 $j$ 还是要回溯，因为怕遇到位置重叠的情况。</li>
</ul>
<h2><span id="3-完整代码">3. 完整代码</span></h2><blockquote>
<p>题目链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP - 洛谷</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> len1,len2; <span class="comment">// n是模板串长度,m是文本串</span></span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// next[i] 就是使子串 s2[0···i] 有最长相等前后缀的前缀的最后一位的下标</span></span><br><span class="line"><span class="type">char</span> s1[N],s2[N]; <span class="comment">// s1[]存储模式串,s2[]存储文本串</span></span><br><span class="line"><span class="comment">// 计算p[]在s[]中出现的位置</span></span><br><span class="line"><span class="comment">// ne代表next数组,因为next在C++中是关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;s1<span class="number">+1</span>&gt;&gt;s2<span class="number">+1</span>; <span class="comment">// 先输入模式串,再输入文本串[从下标1开始]</span></span><br><span class="line">	len1=<span class="built_in">strlen</span>(s1<span class="number">+1</span>);</span><br><span class="line">	len2=<span class="built_in">strlen</span>(s2<span class="number">+1</span>);</span><br><span class="line">	cout&lt;&lt;len1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;len2&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 求next数组的过程[s1与自己匹配,通过前后缀来更新ne数组]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s1[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j]; <span class="comment">// 如果不匹配的话,j就一直后退</span></span><br><span class="line">		<span class="keyword">if</span>(s1[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">			j++; <span class="comment">// 如果当前匹配成功的,j向前递推一位</span></span><br><span class="line">		ne[i]=j; <span class="comment">// 记录并且更新当前j的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求匹配的过程[i遍历文本串]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len2;i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果不匹配的话,j回退</span></span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s2[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j];</span><br><span class="line">		<span class="comment">// 如果相等的话,j向前递推一位</span></span><br><span class="line">		<span class="keyword">if</span>(s2[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">// 刚好长度相等的话说明匹配上了,把下标打印出来</span></span><br><span class="line">		<span class="keyword">if</span>(j==len1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 文本串的位置减去长度即为下标</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-len1);</span><br><span class="line">			<span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">			<span class="comment">// 需要让j回退到一定位置,再让i加1继续进行比较</span></span><br><span class="line">			<span class="comment">// 回退到ne[j]可以保证 j 最大,即已经成功匹配的部分最长</span></span><br><span class="line">			j=ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 还需要把next数组输出出来</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> num:ne) </span><br><span class="line">		cout&lt;&lt;num&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" rel="tag">模式匹配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-贪心区间问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/05/%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"
    >贪心区间问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/05/%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2024-10-05T08:33:48.000Z" itemprop="datePublished">2024-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E7%B1%BB/">分类</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="贪心区间问题">贪心区间问题</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9">1. 最大不相交区间数（区间选点）</a></li>
<li><a href="#2-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84">2. 区间分组</a></li>
<li><a href="#3-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96">3. 区间覆盖</a></li>
<li><a href="#4-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">4. 区间合并</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>以下例题来自于AcWing 906~908</p>
</blockquote>
<h2><span id="1-最大不相交区间数区间选点">1. 最大不相交区间数（区间选点）</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240307214934220.png" alt="image-20240307214934220"></p>
<ul>
<li>翻译一下题目吧<ol>
<li>最大不相交区间数：也就是说给定$N$个闭区间，问能从中选出多少个区间使其互不相交（同活动安排问题）</li>
<li>区间选点：给定 $N$ 个区间，在数轴上选择尽量少的点，使每个区间至少包含一个选出的点（同整数区间问题：找到一个含元素个数最少的集合，使对每一个区间都至少有一个整数属于该集合，输出该集合的元素个数）</li>
<li>为什么这两个问题其实是同一个问题？观察下方图像，在找不相交区间的时候其实就是把 $N$ 个区间划分成 $M$ 个集合，从这 $M$ 个集合中分别选出一个区间，那么这 $M$ 个集合是一定不相交的，此时 $M$ 就是答案，区间选点中点的个数其实就是集合的个数，只要 $range[i].l&gt;last_r$ 就说明需要新开一个集合了，所以 $ans++$</li>
</ol>
</li>
<li>贪心策略：新建一个结构体存储区间的左端点和右端点，将这$N$个区间按照右端点从小到大排序（因为活动选择<strong>越早结束越好</strong>），遍历所有的区间，如果当前遍历到的区间左端点的值大于了上一个区间的右端点的值，说明此时区间没有重合，则区间个数$+1$</li>
<li>如果假设选的点都出现在区间的右端点，此时为了让每个区间都至少包含一个交点，就可以作图如下：</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529204230868.png" alt="image-20240529204230868"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 活动安排+最大不相交区间+区间选点 </span></span><br><span class="line"><span class="comment">  1) 用一个变量记录上一个区间右端点,把所有区间依据区间右端点从小到大排序</span></span><br><span class="line"><span class="comment">  2) 如果某个区间的左端点＞上一个区间右端点,则选点数+1,或不相交区间的个数+1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l; </span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N]; <span class="comment">// 每个区间有左右端点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照右端点从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Range a,Range b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> front_r=INT_MIN; <span class="comment">// 保证至少有一个集合,即range[i].l一定比初始front_r大 </span></span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n,cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以定义res=1,front_r=(sorted)range[1].r,下面的for循环从i=2开始</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(range[i].l&gt;front_r) &#123;</span><br><span class="line">			front_r=range[i].r; <span class="comment">// 更新右端点</span></span><br><span class="line">			res++; <span class="comment">// 点数+1</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P1250">P1250 种树 - 洛谷 </a></p>
</blockquote>
<ul>
<li>题目大意：在区间 $[a,b]$ 内至少种 $c$ 棵树，问树最少的个数</li>
<li>解题思路：<ul>
<li>即让尽可能多的树同时在多个区间出现，对每个区间先统计已有树的数量，如果不足 $c$ 棵则补差</li>
<li>为了让树尽可能能被下一个区间用上，补差时应当从末尾补差</li>
<li>因为每个坐标点只能种一棵树，所以还需要一个状态数组 $st$ 辅助存储</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: </span></span><br><span class="line"><span class="comment">  1) 要在[a,b]种至少c棵树,树最少,即让尽可能多的树同时在多个区间出现,再对多个区间补差</span></span><br><span class="line"><span class="comment">  2) 在补差的时候一定要补在该区间的尾部,因为这样是最后可能让下一个区间用上的</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> n; <span class="comment">// 树的个数</span></span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> used[N]; <span class="comment">// 判断是否已经有树了(一个点不能种两棵树)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Range a,Range b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r; <span class="comment">// 按右端点从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r,&amp;range[i].n); 	</span><br><span class="line">	&#125;</span><br><span class="line">	sort(range+<span class="number">1</span>,range+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>; <span class="comment">// 存储该区间内已有的树的个数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=range[i].l;j&lt;=range[i].r;j++) <span class="keyword">if</span>(used[j]) k++;</span><br><span class="line">		<span class="comment">// 1) 已满足range[i].n棵树则退出</span></span><br><span class="line">		<span class="keyword">if</span>(k&gt;=range[i].n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 2) 不满足,则需要补差,补差需要从末尾补,最有可能给下一个区间用</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=range[i].r;j&gt;=range[i].l;j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!used[j]) &#123;</span><br><span class="line">				used[j]=<span class="literal">true</span>;</span><br><span class="line">				k++;</span><br><span class="line">				ans++; <span class="comment">// 树的数量只在此处增加,即所有的树其实都是从末尾补的</span></span><br><span class="line">				<span class="keyword">if</span>(k==range[i].n) <span class="keyword">break</span>; <span class="comment">// 已够n棵</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-区间分组">2. 区间分组</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240308190931030.png" alt="image-20240308190931030"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529205928100.png" alt="image-20240529205928100"></p>
<ul>
<li>翻译一下题目，现在有$N$个区间，问最少分多少组，能让这些分组中的所有区间两两之间包括端点都没有交集</li>
<li>贪心策略：将所有区间按照左端点从小到大排序，从前往后处理每个区间，判断是否能把这个区间放到现有的某个分组中，即判断 $range[i].l \ &gt; \ 某一分组最大右端点$<ol>
<li>如果存在这样的分组（与某个分组间没有交集），则将区间 $ i $ 放进去，并且更新这个分组的最大右端点（注意，如果与多个分组都有交集则可以放到任意一个分组中，不影响结果，可自行模拟证明）</li>
<li>如果不存在这样的分组（与每个分组间都有交集），则开一个新组，再把区间 $i$ 放进去</li>
<li>在判断当前区间是否与某一分组有交集时，只需要与所有分组中最小的分组最大右端点进行比较即可，因为这是最有可能满足 $range[i].l \ &gt; \ 某一分组最大右端点$ 的情况，对于所有分组中最小的分组最大右端点，只需要用一个小根堆来维护即可</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: </span></span><br><span class="line"><span class="comment">  1) 先将所有区间按照左端点从小到大排序</span></span><br><span class="line"><span class="comment">  2) 用优先队列维护所有分组的整体右端点的最小值,因为在遍历区间时需要用range[i].l与所有分组的max_r比较,而min(max_r)是最容易比range[i].l小的,即最容易插入该分组中</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Range a,Range b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 按照左端点从小到大排序</span></span><br><span class="line">	<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 维护每个分组的最右边界的最小值</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 枚举区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果每个分组的最小的max_r都比当前区间左端点大</span></span><br><span class="line">		<span class="comment">// 说明与每个分组中的区间都要产生交集,则不能放入任何分组</span></span><br><span class="line">		<span class="comment">// 此时新开一个分组</span></span><br><span class="line">		<span class="keyword">if</span>(pq.<span class="built_in">empty</span>() || pq.<span class="built_in">top</span>()&gt;=range[i].l) &#123;</span><br><span class="line">			pq.<span class="built_in">push</span>(range[i].r); <span class="comment">// 新开分组,保存右端点</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果无交集,此时可以放进这个分组中</span></span><br><span class="line">			<span class="comment">// 并维护所有分组中最大右端点的最小值</span></span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			pq.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 小根堆的大小就是分组的个数</span></span><br><span class="line">	cout&lt;&lt;pq.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-区间覆盖">3. 区间覆盖</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240308203244259.png" alt="image-20240308203244259"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529211220012.png" alt="image-20240529211220012"></p>
<ul>
<li>翻译一下题目，···，这道题没什么可翻译的</li>
<li>贪心策略：将所有区间按照左端点从小到大排序，从前往后依次枚举每个区间，在所有能覆盖 $start$ 的区间中选择一个右端点最大的区间，然后将 $start$ 更新成为右端点的最大值，继续向后覆盖，如果所有区间都遍历过了但并没有覆盖到 $end$ 的话说明无法完全覆盖，则输出 $-1$</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 对区间按照左端点从小到大排序,因为每次都要保证覆盖start</span></span><br><span class="line"><span class="comment">  再从满足覆盖start的区间中选出右端点最大的,这样就能保证覆盖线段的区间数最小</span></span><br><span class="line"><span class="comment">  再更新start的值,如果遍历完所有区间能使start&gt;=end,则可覆盖,输出区间数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// 重载运算符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> st,en;</span><br><span class="line">	cin&gt;&gt;st&gt;&gt;en;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 统计区间数</span></span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>; <span class="comment">// 是否能覆盖完整个区间</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历所有区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// front_r:当前覆盖到的区域</span></span><br><span class="line">		<span class="comment">// j:每次从第i个区间后开始找</span></span><br><span class="line">		<span class="type">int</span> j=i,front_r=INT_MIN;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=n &amp;&amp; range[j].l&lt;=st) &#123;</span><br><span class="line">			front_r=<span class="built_in">max</span>(front_r,range[j].r); <span class="comment">// 找最大的右端点</span></span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果最大的front_r仍小于st,说明线段不可被已有区间覆盖</span></span><br><span class="line">		<span class="keyword">if</span>(front_r&lt;st) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 如果找得到,区间数+1</span></span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="comment">// 已经完全覆盖线段</span></span><br><span class="line">		<span class="keyword">if</span>(front_r&gt;=en) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则更新i和j</span></span><br><span class="line">		st=front_r; <span class="comment">// 迭代st,后面的区间继续和st比</span></span><br><span class="line">		i=j<span class="number">-1</span>; <span class="comment">// 双指针,加速遍历</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(!flag) cnt=<span class="number">-1</span>;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-区间合并">4. 区间合并</span></h2><ul>
<li>题目最简单的一集，$N$ 个区间，端点重叠也可合并，求合并后的区间数量和左右端点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 区间合并,端点也算重叠,将有重叠的区间合并后输出</span></span><br><span class="line"><span class="comment">  1) 区间按左端点从小到大排序,有重叠则合并更新区间右端点</span></span><br><span class="line"><span class="comment">  2) range数组一个存储合并前的区间,一个存储合并后的区间,最后遍历输出即可</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// range:原区间,ans:合并后区间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接return a.l&lt;b.l ,如果右端点也从小到大排序则合并次数多了,常数反而大了</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Range a,Range b)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.l!=b.l) <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(range+<span class="number">1</span>,range+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 枚举所有区间进行合并</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	ans[++cnt]=range[<span class="number">1</span>]; <span class="comment">// 结构体之间等价赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 可合并</span></span><br><span class="line">		<span class="keyword">if</span>(range[i].l&lt;=ans[cnt].r) &#123;</span><br><span class="line">			ans[cnt].r=max(ans[cnt].r,range[i].r); <span class="comment">// 更新右端点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不可合并,开新区间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans[++cnt]=range[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 区间个数</span></span><br><span class="line">	<span class="comment">// 输出合并后的区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans[i].l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-搜索开关问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/05/%E6%90%9C%E7%B4%A2%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/"
    >搜索开关问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/05/%E6%90%9C%E7%B4%A2%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2024-10-05T08:28:05.000Z" itemprop="datePublished">2024-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="搜索开关问题">搜索开关问题</span></h1><!-- toc -->

<ul>
<li><a href="#%E4%BE%8B1-%E7%BF%BB%E7%A1%AC%E5%B8%81">[例1]. 翻硬币</a></li>
<li><a href="#%E4%BE%8B2-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3">[例2]. 费解的开关</a></li>
<li><a href="#%E4%BE%8B3-%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F">[例3]. 飞行员兄弟</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>开关问题是RoysterCDD自己取的名字，表示一类用位运算解决的搜索变种问题</p>
</blockquote>
<h2><span id="例1-翻硬币">[例1]. 翻硬币</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211111035470.png" alt="image-20240211111035470" style="zoom:80%;">

<ul>
<li>本题的思路是直接用两个字符数组$start$和$finish$来存储初始状态和结束状态，因为题目说一定有解，所以对比两个数组，出现状态不同，则翻转该硬币和相邻硬币即可，假设每两个硬币间存在一个开关，按下该开关即可翻转相邻两枚硬币的状态</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 给你一个初始状态,一个目标状态,还有某种操作,最常用做法:BFS,同样的题目还有八数码</span></span><br><span class="line"><span class="comment">// 但是BFS时间复杂度比较高,局面很多的话应考虑其他做法,可以考虑和费解的开关相同的做法</span></span><br><span class="line"><span class="comment">// 假设每两个灯泡之间中间有一个开关,这个开关按下后可以翻转其两侧灯泡的亮灭状态</span></span><br><span class="line"><span class="comment">// 这样的话想从初始状态到最终状态(假设每个开关只摁一次)只有唯一的一组解</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> start[N],finish[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start[i]==<span class="string">&#x27;*&#x27;</span>) start[i]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> start[i]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;start&gt;&gt;finish;</span><br><span class="line">	n=<span class="built_in">strlen</span>(start); <span class="comment">// 初始状态的长度,即硬币的总个数</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 如果状态不相同,则翻转该硬币和相邻硬币的状态</span></span><br><span class="line">		<span class="keyword">if</span>(start[i]!=finish[i]) &#123;</span><br><span class="line">			<span class="built_in">turn</span>(i),<span class="built_in">turn</span>(i<span class="number">+1</span>);</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="例2-费解的开关">[例2]. 费解的开关</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211100922703.png" alt="image-20240211100922703"></p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211104635922.png" alt="image-20240211104635922" style="zoom:67%;">

<ul>
<li>题目的思路：输入图的状态后，我们对第一行灯的操作，实际上就能够确定剩下四行我们应该对灯进行什么操作，所以枚举第一行的每种操作，从$00000$到$11111$，$1$表示翻转，$0$表示不翻转，$[0,31]$共$32$种情况，所以枚举$op&#x3D;[0,31]$，用位运算的方式判断每一位是否为$1$</li>
<li>当第一行的操作确定后，比如$g[0,2]&#x3D;&#x3D;0$，那我们就要去点亮第二行的$g[1,2]$，用上下左右的上方向去点亮第一行未被点亮的灯，对于剩余行的操作都是一样的，遍历完后如果我们发现最后一行有未被点亮的灯或者操作数多于6次，那么就无法达到，输出$-1$即可</li>
<li>对于每种第一行的操作，我们用$res&#x3D;min(res,step)$来更新最小的答案，本题的技巧还有位运算的技巧、二进制状态表示、准备一个备份数组$backup[N][N]$用于状态复原等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6</span>;</span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N]; <span class="comment">// 图和备份</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;; <span class="comment">// 五个方位(0,0表示本身这个点)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a=x+dx[i], b=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=<span class="number">5</span> || b&lt;<span class="number">0</span> || b&gt;=<span class="number">5</span>) <span class="keyword">continue</span>; <span class="comment">// 越界处理</span></span><br><span class="line">		<span class="comment">// 因为0和1的ASCII码表示分别为48(110000和49(110001)</span></span><br><span class="line">		<span class="comment">// 所以只需要亦或一个1,亦或0不变,亦或1反转,亦或一个1反转最后一位</span></span><br><span class="line">		g[a][b]^=<span class="number">1</span>; <span class="comment">// 即可让48-&gt;49,49-&gt;48</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 每一行开关的操作完全被前一行灯的亮灭状态所确定</span></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) cin&gt;&gt;g[i]; <span class="comment">// 输入图</span></span><br><span class="line">		<span class="type">int</span> res=<span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们枚举第一行的操作</span></span><br><span class="line">		<span class="comment">// 0~31表示的是00000到11111(遍历每一种操作,1表示我们翻转,0表示不翻转)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">32</span>;op++) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 复制g给backup,操作g</span></span><br><span class="line">			<span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 判断第一行中op共5位中哪一位是1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">				<span class="comment">// op&gt;&gt;i&amp;1:先右移i位,现在第i位变成最低位,再看是否为1</span></span><br><span class="line">				<span class="keyword">if</span>(op&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					step++; <span class="comment">// 经过一次操作</span></span><br><span class="line">					<span class="built_in">turn</span>(<span class="number">0</span>,i); <span class="comment">// 翻转为1的这一位的状态</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 所以第一行的状态影响了接下来所有行的状态</span></span><br><span class="line">			<span class="comment">// 遍历第一行到倒数第二行,如果为0的话就翻转</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						step++; <span class="comment">// 如果为0那么需要翻转一次</span></span><br><span class="line">						<span class="built_in">turn</span>(i<span class="number">+1</span>,j); <span class="comment">// 下一行的第j个元素需要翻转</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">bool</span> dark=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">				<span class="comment">// 如果最后一行有没亮的,那就别无他法了</span></span><br><span class="line">				<span class="keyword">if</span>(g[<span class="number">4</span>][i]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">					dark=<span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!dark) res=<span class="built_in">min</span>(res,step);</span><br><span class="line">			<span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g); <span class="comment">// 恢复状态</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;<span class="number">6</span>) res=<span class="number">-1</span>; <span class="comment">// 题目要求不能超过6步</span></span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="例3-飞行员兄弟">[例3]. 飞行员兄弟</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105824073.png" alt="image-20240211105824073" style="zoom:80%;">

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105917746.png" alt="image-20240211105917746"></p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105930997.png" alt="image-20240211105930997" style="zoom:80%;">

<ul>
<li>本题的思路类似，一共$16$个开关，所以方案总数是$2^{16}&#x3D;65535$种，故枚举$[0,2&lt;&lt;16]$来表示对于这$16$的开关的操作，所以这个$int$型的二进制表示中某一位的值是$1$表示我们要改变这个开关的状态，$0$则表示不改变，枚举每种操作，最后看是否能够使所有把手都打开，如果可以的话把方案加入到$vector$数组中，最后打印即可</li>
<li>技巧：$get(x,y)$函数返回的值代表二维数组中对应位置在二进制表示中的第几个开关（下标）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 本题的难点在于每个灯泡可以被很多开关所控制</span></span><br><span class="line"><span class="comment">// 用暴力法来做,只有4*4=16个开关,所以每个开关嗯的方案数是2^16=65536</span></span><br><span class="line"><span class="comment">// 枚举所有方案→0~2^16-1,用二进制表示,某位为1是摁下,为0表示不摁</span></span><br><span class="line"><span class="comment">// 按照该方案对所有灯泡进行操作,判断灯泡是不是全亮,是的话则记录方案</span></span><br><span class="line"><span class="comment">// 现在要求:步数最小/字典序最小(从小到大排序就可以了)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是(x,y)上的数是第几个开关,从上往下从左往右编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*<span class="number">4</span>+y; <span class="comment">// 从0~15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+&quot;和&quot;-&quot;翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_one</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g[x][y]==<span class="string">&#x27;+&#x27;</span>) g[x][y]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> g[x][y]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_all</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">turn_one</span>(x,i); <span class="comment">// 这一行上的数翻转状态</span></span><br><span class="line">		<span class="built_in">turn_one</span>(i,y); <span class="comment">// 这一列上的数翻转状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">turn_one</span>(x,y); <span class="comment">// 因为(x,y)在这一行和这一列交汇处,所以翻转两次相当于没有翻转,再单独翻转一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		cin&gt;&gt;g[i];</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;PII&gt; res; <span class="comment">// 存储所有的方案</span></span><br><span class="line">	<span class="comment">// 枚举每种操作情况,每个开关对应开和不开两种状态,方案数是2^16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">1</span>&lt;&lt;<span class="number">16</span>;op++) &#123;</span><br><span class="line">		vector&lt;PII&gt; temp; <span class="comment">// 每次新开一个,相当于清空了</span></span><br><span class="line">		<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 备份图</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">				<span class="comment">// 如果op在这一位上的值为1</span></span><br><span class="line">				<span class="keyword">if</span>(op&gt;&gt;<span class="built_in">get</span>(i,j)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// 向temp中记录一下操作数</span></span><br><span class="line">					temp.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">					<span class="built_in">turn_all</span>(i,j); <span class="comment">// 进行一次反转操作</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">// 判断所有灯泡是否全亮</span></span><br><span class="line">		<span class="type">bool</span> has_closed=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">					has_closed=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(has_closed==<span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(res.<span class="built_in">empty</span>()||res.<span class="built_in">size</span>()&gt;temp.<span class="built_in">size</span>()) res=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g); <span class="comment">// 还原</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 方案总数</span></span><br><span class="line">	<span class="comment">// 打印每一种方案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> op:res) cout&lt;&lt;op.x<span class="number">+1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;op.y<span class="number">+1</span>&lt;&lt;endl; <span class="comment">// 坐标+1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-最小生成树"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"
    >最小生成树</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="article-date">
  <time datetime="2024-10-05T08:25:18.000Z" itemprop="datePublished">2024-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="最小生成树">最小生成树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9C%B4%E7%B4%A0prim%E7%AE%97%E6%B3%95">1. 朴素Prim算法</a></li>
<li><a href="#2-kruskal%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96">2. Kruskal算法+并查集优化</a></li>
<li><a href="#3-kruskal%E5%BB%B6%E7%94%B3%E5%AF%B9%E8%BE%93%E5%87%BA%E6%8E%92%E5%BA%8F">3. Kruskal延申：对输出排序</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>以下模板能使用的前提是：不存在负权环</li>
</ul>
<h2><span id="1-朴素prim算法">1. 朴素Prim算法</span></h2><blockquote>
<p>时间复杂度：$O(n^2)$，适合稠密图，边数接近点数的平方</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素Prim,和dijkstra非常相似</span></span><br><span class="line"><span class="comment">// 1.dist数组初始化为不可达</span></span><br><span class="line"><span class="comment">// 2.遍历每个点,找到集合外距离最近的点</span></span><br><span class="line"><span class="comment">// 3.用t更新其他点到集合的距离</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>; <span class="comment">// 无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储各结点到生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 访问状态</span></span><br><span class="line"><span class="type">int</span> pre[N]; <span class="comment">// 节点的前驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 最终结果</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 从1号点开始生成</span></span><br><span class="line">	<span class="comment">// 对于每个点都遍历一遍</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="comment">// t是距离点集最近的点</span></span><br><span class="line">		<span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// 从点1~n中去找t</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="comment">// 如果j未被访问并且t是第一次更新,并且从t到源点距离比从j到源点距离更近</span></span><br><span class="line">			<span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">				t=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是孤立点,直接退出,无法构成最小生成树</span></span><br><span class="line">		<span class="keyword">if</span>(i &amp;&amp; dist[t]==<span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 先更新,再累加,防止把自环加进来</span></span><br><span class="line">		<span class="comment">// 状态更新</span></span><br><span class="line">		st[t]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 求和距离</span></span><br><span class="line">		res+=dist[t];</span><br><span class="line">		<span class="comment">// 更新dist[j]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dist[j]=min(dist[j],g[t][j]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果要输出边</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=n;j++) &#123;</span></span><br><span class="line"><span class="comment">//			if(dist[j]&gt;g[t][j]&amp;&amp;!st[j]) &#123;</span></span><br><span class="line"><span class="comment">//				dist[j]=g[t][j];</span></span><br><span class="line"><span class="comment">//				pre[j]=t; // 距离变短,前驱变为t</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;pre[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=g[b][a]=min(g[a][b],c); <span class="comment">// 去重边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=prim();</span><br><span class="line">	<span class="keyword">if</span>(t==INF)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//	getPath();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-kruskal算法并查集优化">2. Kruskal算法+并查集优化</span></h2><blockquote>
<p>时间复杂度：$O(mlog^n)$，适合稀疏图，以下模板能解决重边、自环、负权边<br>题目链接：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2</span>*(<span class="number">2e5</span>+<span class="number">5</span>); <span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点/终点/权值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Edge a,Edge b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// p[i]:顶点i的连通分量</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集查询连通分量,带路径压缩</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> p[x]=find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 加入图的边数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="comment">// 取出每条边中的信息</span></span><br><span class="line">		<span class="type">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].val;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果a和b已经相连则跳过</span></span><br><span class="line">		<span class="comment">// 1.如果是自环-&gt;(3,3)=5</span></span><br><span class="line">		<span class="comment">// 2.如果是重边-&gt;(1,2)=3,(2,1)=5,此时取小边(因为排过序了)</span></span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b)) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出这条边</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;a&lt;&lt;&quot;--&quot;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 选择这条边后的信息维护 </span></span><br><span class="line">		p[find(a)]=find(b); <span class="comment">// 连通两个并查集</span></span><br><span class="line">		ans+=w; <span class="comment">// 答案累加这条边的权值</span></span><br><span class="line">		cnt++; <span class="comment">// 边数+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 联通</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 并查集初始化:连通分量为自身</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		p[i]=i; 	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输入每条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="comment">//		scanf(&quot;%d%d%d&quot;,&amp;edges[i].a,&amp;edges[i].b,&amp;edges[i].val);</span></span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		edges[i]=&#123;a,b,c&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">if</span>(kruskal()) <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-kruskal延申对输出排序">3. Kruskal延申：对输出排序</span></h2><blockquote>
<p>将数组改成 $vector$，为结构体提供无参构造器和全参构造器 $m$，例题：信奥一本通 $p1348$，以下模板能解决重边、自环、负权边。<br>题目链接：<a target="_blank" rel="noopener" href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1348">  信息学奥赛一本通（C++版）</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e5</span><span class="number">+5</span>; <span class="comment">// 最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点/终点/边权</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	ll val;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> aa,<span class="type">int</span> bb,<span class="type">int</span> cc) &#123;</span><br><span class="line">		a=aa;</span><br><span class="line">		b=bb;</span><br><span class="line">		val=cc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">// 记录父节点</span></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges,tree; <span class="comment">// 存储所有边和生成树的边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边权越小越靠前</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_edges</span><span class="params">(Edge a,Edge b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对生成树的边二次排序,编号小的靠前</span></span><br><span class="line"><span class="comment">// 起始点相同,终点小的靠前;否则起始点小的靠前</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_trees</span><span class="params">(Edge x,Edge y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.a==y.a) <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询根节点带路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 已加入图的边</span></span><br><span class="line">	<span class="keyword">for</span>(Edge e:edges) &#123;</span><br><span class="line">		<span class="comment">// 提取边的信息</span></span><br><span class="line">		<span class="type">int</span> a=e.a, b=e.b, w=e.val;</span><br><span class="line">		<span class="type">int</span> v1=<span class="built_in">find</span>(a);</span><br><span class="line">		<span class="type">int</span> v2=<span class="built_in">find</span>(b);</span><br><span class="line">		<span class="comment">// 若a,b已相连</span></span><br><span class="line">		<span class="keyword">if</span>(v1==v2) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 选中这条边</span></span><br><span class="line">		cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		ans+=w;</span><br><span class="line">		fa[v1]=v2; <span class="comment">// 联通并查集</span></span><br><span class="line">		cnt++;</span><br><span class="line">		tree.<span class="built_in">push_back</span>(e); <span class="comment">// 添加到生成树边集中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 优化输入输出</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 初始化并查集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		fa[i]=i;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="comment">// 强行让小的编号在前,大的编号在后</span></span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(a,b,c));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),cmp_edges);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">kruskal</span>()) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 对生成树中的边再排序</span></span><br><span class="line">	<span class="built_in">sort</span>(tree.<span class="built_in">begin</span>(),tree.<span class="built_in">end</span>(),cmp_trees);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> e:tree) &#123;</span><br><span class="line">		cout&lt;&lt;e.a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;e.b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;e.val&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-搜索总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/05/%E6%90%9C%E7%B4%A2%E6%80%BB%E7%BB%93/"
    >搜索总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/05/%E6%90%9C%E7%B4%A2%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2024-10-05T08:21:50.000Z" itemprop="datePublished">2024-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="搜索总结">搜索总结</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs">1. 深度优先搜索DFS</a><ul>
<li><a href="#11-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98">1.1. 全排列问题</a></li>
<li><a href="#12-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">1.2. n皇后问题</a></li>
</ul>
</li>
<li><a href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs">2. 广度优先搜索BFS</a><ul>
<li><a href="#21-%E8%B5%B0%E8%BF%B7%E5%AE%AB">2.1. 走迷宫</a></li>
<li><a href="#22-%E5%85%AB%E6%95%B0%E7%A0%81">2.2. 八数码</a></li>
</ul>
</li>
<li><a href="#3-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8">3. 树和图的存储</a><ul>
<li><a href="#31-%E6%9C%89%E5%90%91%E5%9B%BE">3.1. 有向图</a><ul>
<li><a href="#311-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">3.1.1. 邻接矩阵</a></li>
<li><a href="#312-%E9%82%BB%E6%8E%A5%E8%A1%A8">3.1.2. 邻接表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">4. 树和图的遍历</a><ul>
<li><a href="#41-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">4.1. 深度优先遍历</a></li>
<li><a href="#42-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">4.2. 广度优先遍历</a></li>
<li><a href="#43-%E6%A8%A1%E6%9D%BF">4.3. 模板</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-深度优先搜索dfs">1. 深度优先搜索DFS</span></h2><blockquote>
<p>数据结构 stack，空间复杂度O(n)，不具有最短性，深搜问题没有模板</p>
</blockquote>
<ul>
<li>关键在于：剪枝和回溯</li>
</ul>
<h3><span id="11-全排列问题">1.1. 全排列问题</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[maxn]; <span class="comment">// 每一步填的数字</span></span><br><span class="line"><span class="type">bool</span> st[maxn]; <span class="comment">// 遍历状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 跳出条件</span></span><br><span class="line">	<span class="keyword">if</span>(u==n) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">			cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果还没有填满,从数字1开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			path[u]=i;</span><br><span class="line">			st[i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 进入下一层</span></span><br><span class="line">			<span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">			<span class="comment">// 回溯</span></span><br><span class="line">			st[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-n皇后问题">1.2. n皇后问题</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 皇后个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">9</span>; <span class="comment">// 最大皇后个数</span></span><br><span class="line"><span class="type">int</span> x[maxn<span class="number">+1</span>]; <span class="comment">// 存放皇后位置,x[i]表示第i个皇后的在第几列</span></span><br><span class="line"><span class="type">int</span> res; <span class="comment">// n皇后的可行解个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第i个皇后放置在x[i]列是否会发生冲突</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">place</span><span class="params">(<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// j=1~i-1是已经放置了皇后的行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;j;i++) &#123;</span><br><span class="line">		<span class="comment">// x数组的物理性质决定两个皇后不会发生行冲突</span></span><br><span class="line">		<span class="comment">// x[j]==x[i]:发生列冲突</span></span><br><span class="line">		<span class="comment">// abs(i-j)==abs(x[i]-x[j]):发生对角线冲突,可画图推导</span></span><br><span class="line">		<span class="keyword">if</span>(x[j]==x[i] || <span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(x[i]-x[j]))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 冲突就返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	res++; <span class="comment">// 答案+1</span></span><br><span class="line">	<span class="comment">// 遍历每个皇后</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 遍历每一列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="comment">// 如果皇后所在列就是j,打印&#x27;Q&#x27;</span></span><br><span class="line">			<span class="keyword">if</span>(x[i]==j)</span><br><span class="line">				cout&lt;&lt;<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放置每个皇后的深度优先搜索函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 遍历第1列到n列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">		<span class="comment">// 先把皇后放到第j列</span></span><br><span class="line">		x[u]=j;</span><br><span class="line">		<span class="comment">// 如果第u个皇后放在这列不冲突</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">place</span>(u)) &#123;</span><br><span class="line">			<span class="comment">// 找到了一个可行解,直接打印</span></span><br><span class="line">			<span class="keyword">if</span>(u==n)</span><br><span class="line">				<span class="built_in">print</span>();</span><br><span class="line">			<span class="comment">// 向下递归</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 从第一个皇后开始</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;可行解一共有 &quot;</span>&lt;&lt;res&lt;&lt;<span class="string">&quot; 个&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-广度优先搜索bfs">2. 广度优先搜索BFS</span></h2><blockquote>
<p>数据结构 queue，空间复杂度O(2^n)，最短路，宽搜问题有模板</p>
</blockquote>
<h3><span id="21-走迷宫">2.1. 走迷宫</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 地图范围</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图的情况</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 每个点到初始点的距离</span></span><br><span class="line">PII q[N*N]; <span class="comment">// BFS的队列</span></span><br><span class="line">PII Prev[N][N]; <span class="comment">// 记录遍历的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// hh:队头,当前要处理元素的下标</span></span><br><span class="line">	<span class="comment">// tt:队尾,最后一个入队元素的下标</span></span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化,表示害没有任何点经过</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">	d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 向量表示四个方向</span></span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt) &#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q[hh++]; <span class="comment">// 取出队头</span></span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">			<span class="comment">// 如果没有超出地图范围且g[x][y]=0且没有到过</span></span><br><span class="line">			<span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; g[x][y]==<span class="number">0</span> &amp;&amp; d[x][y]==<span class="number">-1</span>) &#123;</span><br><span class="line">				d[x][y]=d[t.first][t.second]<span class="number">+1</span>; <span class="comment">// 距离加1</span></span><br><span class="line">				Prev[x][y]=t; <span class="comment">// 记录上一步</span></span><br><span class="line">				q[++tt]=&#123;x,y&#125;; <span class="comment">// 把x,y放进队头</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出路径</span></span><br><span class="line"><span class="comment">//	int x=n-1,y=m-1;</span></span><br><span class="line"><span class="comment">//	// [0,1] [1,0]都可以输出</span></span><br><span class="line"><span class="comment">//	while(x||y) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		auto t=Prev[x][y];</span></span><br><span class="line"><span class="comment">//		x=t.first,y=t.second;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回距离</span></span><br><span class="line">	<span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			cin&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-八数码">2.2. 八数码</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 八重码:类似于一个数字华容道嘛,求移动的最少步数(BFS)</span></span><br><span class="line"><span class="comment">// 难点在于状态表示比较复杂,每个状态是一个3*3的小矩阵</span></span><br><span class="line"><span class="comment">// 问题一:队列,如果把每个状态放进队列中 &quot;12345678x&quot;</span></span><br><span class="line"><span class="comment">// 问题二:如何计算每个状态的距离 &quot;queue&lt;string&gt;,unordered_map&lt;string,int&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">queue&lt;string&gt; q; <span class="comment">// 定义队列</span></span><br><span class="line"><span class="comment">// 让字符串映射到int类型的值</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; d; <span class="comment">// 通过哈希表来让字符串变化时和移动的距离数值关联</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(st); <span class="comment">// 将字符串入队</span></span><br><span class="line">	d[st]=<span class="number">0</span>; <span class="comment">// 将初始状态的字符串的哈希值设定为0</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">// 定义四个方向向量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5在一维数组中的下标是4</span></span><br><span class="line">	string end=<span class="string">&quot;12345678x&quot;</span>; <span class="comment">// 定义宽度优先搜素的终止状态</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) <span class="comment">// 循环终止状态</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q.<span class="built_in">front</span>(); <span class="comment">// 将队列中存着的字符串赋值给t</span></span><br><span class="line">		q.<span class="built_in">pop</span>(); <span class="comment">// 队头元素弹出</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(t==end) </span><br><span class="line">			<span class="keyword">return</span> d[t]; <span class="comment">// 如果当前字符串等于终止状态搜索结束返回该字符串对应的哈希值</span></span><br><span class="line">		<span class="comment">//此处的哈希函数值对应于字符串移动的次数    </span></span><br><span class="line">		<span class="type">int</span> distance = d[t]; <span class="comment">// 定义一个临时变量distance存储形成t字符串当前的移动次数</span></span><br><span class="line">		<span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// k表示&#x27;x&#x27;字符在字符串当前的下标</span></span><br><span class="line">		<span class="comment">// 把&#x27;x&#x27;所在的下标转换成二维数组的形式,比如&quot;12345678x&quot;,x就是8,8/3=2,8%3=2,所以是第三行第三列</span></span><br><span class="line">		<span class="type">int</span> x = k/<span class="number">3</span>,y = k%<span class="number">3</span>; <span class="comment">// 由于字符串当前是一维的将一维下标转化为二维坐标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">// 分别遍历四个方向</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// 遍历&#x27;x&#x27;可以走的四个方向</span></span><br><span class="line">			<span class="type">int</span> a=x+dx[i],b=y+dy[i]; <span class="comment">//将下一个搜索位置的x,y坐标表示</span></span><br><span class="line">			<span class="comment">// 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">3</span>&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;<span class="number">3</span>) <span class="comment">//当二维坐标满足位于3X3矩阵中时</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将搜索位置和&#x27;x&#x27;相交换,a*3+b变回一维数组索引</span></span><br><span class="line">				<span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]); <span class="comment">//将字符串中的搜索位置与字符&#x27;x&#x27;交换</span></span><br><span class="line">				<span class="comment">// d.count(t)是统计d这个哈希表容器中t出现的次数,如果一次都没出现过,就放进队列,同时在dist[t]上做加减</span></span><br><span class="line">				<span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)) <span class="comment">// 如果当前的字符串的哈希值为0</span></span><br><span class="line">				&#123;</span><br><span class="line">					d[t]=distance<span class="number">+1</span>; <span class="comment">// 将该字符串对应的哈希值在原字符串对应的哈希值基础上加1</span></span><br><span class="line">					q.<span class="built_in">push</span>(t); <span class="comment">// 将该字符串入队</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]); <span class="comment">// 恢复现场,返回位置判断其他方向</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果无法移动到终止位置返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	string st;</span><br><span class="line">	<span class="comment">// 输入一个初始状态</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		st+=s; <span class="comment">//逐个输入字符串</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>(st)&lt;&lt;endl; <span class="comment">//输出宽度优先搜索的数值	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-树和图的存储">3. 树和图的存储</span></h2><blockquote>
<p>树是一种特殊的图，因此只讨论图</p>
</blockquote>
<h3><span id="31-有向图">3.1. 有向图</span></h3><h4><span id="311-邻接矩阵">3.1.1. 邻接矩阵</span></h4><ul>
<li>邻接矩阵不能存储重边，空间复杂度O(n²)，适合稠密图</li>
</ul>
<h4><span id="312-邻接表">3.1.2. 邻接表</span></h4><ul>
<li>每个结点开一个单链表，邻接表内部的顺序是无所谓的，邻接表插入新边后引入新的结点一般用头插法</li>
</ul>
<h2><span id="4-树和图的遍历">4. 树和图的遍历</span></h2><h3><span id="41-深度优先遍历">4.1. 深度优先遍历</span></h3><blockquote>
<p>时间复杂度O(n+m)，点数+边数</p>
</blockquote>
<ul>
<li>优点在于可以求出每一棵子树的大小。</li>
</ul>
<h3><span id="42-广度优先遍历">4.2. 广度优先遍历</span></h3><blockquote>
<p>时间复杂度O(n+m)，点数+边数</p>
</blockquote>
<ul>
<li>优点在于可以求出最短路径，但前提是每条路的权重相同</li>
</ul>
<h3><span id="43-模板">4.3. 模板</span></h3><blockquote>
<p>注意DFS是没有模板的，但基本可以分为终止条件、递归逻辑、剪枝、恢复现场几个步骤，在另一篇博客里给出了我自己对于DFS的模板，BFS有模板</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入输出规模在100w的时候必须用scanf</span></span><br><span class="line"><span class="comment">// 树和图的存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="comment">// h[i]:第i个结点的邻接表,头插,存储边</span></span><br><span class="line"><span class="comment">// e[j]:第j条边指向的结点</span></span><br><span class="line"><span class="comment">// ne[j]:第j条边的下一条边</span></span><br><span class="line"><span class="comment">// idx:边的编号</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 每个点的搜索状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N],d[N]; <span class="comment">// bfs队列和距离数组</span></span><br><span class="line"><span class="type">int</span> Prev[N]; <span class="comment">// 记录顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第idx条边指向的结点是b</span></span><br><span class="line">	<span class="comment">// 第idx条边的下一条边是a的单链表(头结点)</span></span><br><span class="line">	<span class="comment">// 结点a的邻接表的第一条边变为idx,idx++</span></span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs找最短路径为例:注意每条路的权重必须都相同,如这里的1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>; <span class="comment">// 队头和队尾</span></span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 头结点是1</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); <span class="comment">// 距离初始化为-1</span></span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 第1个结点到第1个结点的距离是0</span></span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt) &#123;</span><br><span class="line">		<span class="type">int</span> t=q[hh++]; <span class="comment">// 取出头结点,hh++</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果j还未访问过</span></span><br><span class="line">			<span class="keyword">if</span>(d[j]==<span class="number">-1</span>) &#123;</span><br><span class="line">				d[j]=d[j]<span class="number">+1</span>;</span><br><span class="line">				q[++tt]=j; <span class="comment">// 在队尾增加一个空位,再把j的值赋给q[tt]</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	st[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 从u的第一条边开始往下遍历每一条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="comment">// 如果还未被访问过,就继续dfs[j]</span></span><br><span class="line">		<span class="keyword">if</span>(!st[j])</span><br><span class="line">			dfs[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化为-1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-AC自动机"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/10/05/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"
    >AC自动机</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/05/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="article-date">
  <time datetime="2024-10-05T08:14:41.000Z" itemprop="datePublished">2024-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">



<h1><span id="ac自动机">AC自动机</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a><ul>
<li><a href="#1-%E6%9E%84%E5%BB%BAtrie%E6%A0%91">1. 构建Trie树</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0ac%E8%87%AA%E5%8A%A8%E6%9C%BA">2. 构造AC自动机</a><ul>
<li><a href="#21-%E5%9B%9E%E8%B7%B3%E8%BE%B9">2.1. 回跳边</a></li>
<li><a href="#22-%E8%BD%AC%E7%A7%BB%E8%BE%B9">2.2. 转移边</a></li>
<li><a href="#23-%E7%94%A8bfs%E6%9E%84%E9%80%A0ac%E8%87%AA%E5%8A%A8%E6%9C%BA">2.3. 用BFS构造AC自动机</a></li>
</ul>
</li>
<li><a href="#3-%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">3. 查找单词出现次数</a></li>
<li><a href="#4-kmp%E4%B8%8Eac%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AF%B9%E6%AF%94">4. KMP与AC自动机对比</a></li>
<li><a href="#5-%E4%BE%8B%E6%B4%9B%E8%B0%B7p3808-ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95">5. 【例】洛谷P3808 AC自动机(简单)</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<blockquote>
<p>跟学视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F08【模板】AC自动机_</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>$AC$自动机是多模式匹配算法，给定$n$个模式串和一个主串，查找有多少个模式串在主串中出现过。</li>
</ul>
<blockquote>
<p>复习一下字典树吧：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63586399/article/details/136725155?spm=1001.2014.3001.5502">【C++算法模板】字典树，超详细注释带例题讲解-CSDN博客</a></p>
</blockquote>
<h3><span id="1-构建trie树">1. 构建Trie树</span></h3><ul>
<li>我们先用n个模式串构造一颗Trie。</li>
<li>Trie中的一个节点表示一个从根到当前节点的字符串。</li>
<li>根节点表示空串，节点⑤表示“s”，节点6表示“sh”，节点7表示“she”。</li>
<li>如果节点是个模式串，则打个标记。例如，cnt[7]&#x3D;1。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213085433083.png" alt="image-20240213085433083"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树的insert函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123; <span class="comment">// 遍历主串</span></span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到下标0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 如果没有孩子节点,则创建一个</span></span><br><span class="line">		p=ch[p][j]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1,标记从根节点出发到该节点是一个模式串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="2-构造ac自动机">2. 构造AC自动机</span></h3><ul>
<li>构造AC自动机的过程就是在Trie树上构建两类边：<strong>回跳边</strong>和<strong>转移边</strong></li>
</ul>
<h4><span id="21-回跳边">2.1. 回跳边</span></h4><ul>
<li><p>开一个数组ne[]，ne[v] 存节点v的回跳边的终点，如：ne[7]&#x3D;3，表示节点7的回跳边的终点是3</p>
</li>
<li><p>回跳边指向<strong>父节点的回跳边所指节点的儿子</strong>，对于ne[7]&#x3D;3来说，7的父节点是6，6的子节点是3，所以7指向3，此时四个点$(v,u,ne[u],ch[][])$构成四边形</p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213091335787.png" alt="image-20240213091335787" style="zoom:80%;">
</li>
<li><p>并且回跳边所指节点一定是当前节点的<strong>最长后缀</strong>，cnt[7]&#x3D;1，代表模式串是she，cnt[3]&#x3D;1，代表模式串是he，此时he是she的最长后缀，下图中绿色边代表回跳边。</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213090937272.png" alt="image-20240213090937272" style="zoom:80%;">



<h4><span id="22-转移边">2.2. 转移边</span></h4><ul>
<li>转移边指向的是<strong>当前节点的回跳边所指节点的儿子</strong>，转移边和树边共同存储在数组$ch[][]$中<ul>
<li>$ch[u][i]$存节点u的树边的终点，如$ch[6][e]&#x3D;7$，节点6走e边到达节点7</li>
<li>$ch[u][i]$存节点u的转移边的终点，如$ch[7][r]$&#x3D;4，节点7的回跳边是3，节点3的儿子是节点4，注意上图中没有画出转移边，只有树边和回跳边</li>
</ul>
</li>
<li>此时三个点$(u,ne[u],ch[][])$构成三角形</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213092022148.png" alt="image-20240213092022148"></p>
<ul>
<li>转移边所指节点一定是当前节点的<strong>最短路</strong>，比如$ch[7][r]&#x3D;4$，那么从节点7到达节点4的最短路就是这条直通的r，而不是回溯到根节点再重新匹配到节点4</li>
</ul>
<h4><span id="23-用bfs构造ac自动机">2.3. 用BFS构造AC自动机</span></h4><ol>
<li>初始化，把根节点的儿子们入队（枚举26次，因为只有26个字母）</li>
<li>只要队不空，队头节点u出队，枚举u的26个儿子<ol>
<li>若儿子存在，则爹帮儿子建回跳边，并把儿子入队</li>
<li>若儿子不存在，则爹自建转移边</li>
</ol>
</li>
</ol>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213090937272.png" alt="image-20240213090937272" style="zoom:80%;">

<ul>
<li>上图对应的完整建边过程如下，这里只模拟节点1和节点2的建边过程：</li>
<li>1）对节点1：<ol>
<li>节点1出队，但是节点1下没有儿子，所以不用给他的儿子建回跳边，但是图中节点1的回跳边指向节点0，这是因为ne[]数组是全局变量默认初始化为0，或者可以这样想，根节点代表的是空串，此时节点1的最长后缀也就是空串</li>
<li>现在建转移边，因为节点1的父节点的儿子就是本身，所以建立26条转移边，有$ch[1][e]&#x3D;1$，既节点1的转移边指向自己，对于遍历到父节点的下一条树边h时，当前节点的转移边指向父节点的儿子，所以有$ch[1][h]&#x3D;2$，同理有$ch[1][s]&#x3D;5$，那么对于父节点0的其他边(即不存在的边)有$ch[1][···]&#x3D;0$，指向咱们的根节点</li>
</ol>
</li>
<li>2）对节点2：<ol>
<li>节点2出队，因为节点2下的有儿子节点3，所以先为节点3建立回跳边为节点3的父节点的回跳边指向的儿子，其实就是节点1，所以有$ne[3]&#x3D;1$，并且将节点3入队</li>
<li>因为只有这一个儿子，随后建立25条转移边，节点2的父节点0在e之后(因为e已经用于做最长后缀去建回跳边了)的树边有h和s，对h和s建立回跳边的过程同上，所以有$ch[2][h]&#x3D;2$、$ch[2][s]&#x3D;5$、$ch[2][···]&#x3D;0$</li>
</ol>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213094042809.png" alt="image-20240213094042809" style="zoom:80%;">

<ul>
<li>时间复杂度O(26n)，一共需要入队出队n个字符，n是模式串所有的总长度，每个节点都要枚举26次，要么帮儿子建回跳边，要么自己建转移边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 存储回跳边的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 1:将根节点的儿子入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">		<span class="keyword">if</span>(ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="comment">// 2:当队列非空,取队头,建回跳边和转移边</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> v=ch[u][i]; <span class="comment">// 取出儿子节点</span></span><br><span class="line">			<span class="comment">// 如果有儿子节点,构建v的回跳边为父节点的回跳边所指向的儿子</span></span><br><span class="line">			<span class="keyword">if</span>(v) ne[v]=ch[ne[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="comment">// 如果没有儿子节点,构建u的转移边为回跳边所指向节点的儿子</span></span><br><span class="line">			<span class="keyword">else</span> ch[u][i]=ch[ne[u]][i]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="3-查找单词出现次数">3. 查找单词出现次数</span></h3><ul>
<li><p>匹配的方式和$KMP$类似，是一个双指针匹配，首先扫描主串，依次取出字符s[k]</p>
</li>
<li><p>1）i 指针走主串对应的节点，沿着<strong>树边</strong>或<strong>转移边</strong>走，保证不回退</p>
</li>
<li><p>2）j 指针沿着<strong>回跳边</strong>搜索模式串，每次从当前节点走到根节点，把当前节点中的所有<strong>后缀模式串</strong>一网打尽，保证不漏解。</p>
</li>
<li><p>3）扫描完主串，返回答案</p>
</li>
<li><p>算法一边走串，一边把当前串的所有后缀串搜出来，实在是强，对于此过程的模拟，建议听原视频（因为太复杂了不想写）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F08【模板】AC自动机_哔哩哔哩_bilibili</a>，从$24:48$ 开始</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213101043808.png" alt="image-20240213101043808"></p>
<ul>
<li>时间复杂度$O(n+m)$，m是主串长度，n是所有模式串的总长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找单词出现次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;s[k];k++) &#123;</span><br><span class="line">		i=ch[i][s[k]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// i指针指向s[k]这个字符对应的节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&amp;&amp;~cnt[j];j=ne[j]) <span class="comment">// j指针从当前指针开始,沿沿着回跳边跑</span></span><br><span class="line">			ans+=cnt[j],cnt[j]=<span class="number">-1</span>; <span class="comment">// 如果有标记,则累加答案,无论有无标记,都把标记清空,注意这里的写法不是固定的,如果题目要求出现几次就累计几次,那么cnt[j]是不用清空的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="4-kmp与ac自动机对比">4. KMP与AC自动机对比</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213102219322.png" alt="image-20240213102219322" style="zoom: 80%;">



<h3><span id="5-例洛谷p3808-ac自动机简单">5. 【例】洛谷P3808 AC自动机(简单)</span></h3><ul>
<li>给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过，当两个模式串编号不同时即视为不同的模式串。</li>
<li>注意：$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213103041931.png" alt="image-20240213103041931"></p>
<ul>
<li>注意：$s_1$，$s_2$，$s_4$ 都在串$abcd$里出现过</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213103223172.png" alt="image-20240213103223172" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 存储回跳边的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 模式串个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN=<span class="number">1e6</span><span class="number">+10</span>; <span class="comment">// 模式串最长长度</span></span><br><span class="line"><span class="type">char</span> str[MAX_LEN]; <span class="comment">// 存储模式串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树的insert函数,传入字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123; <span class="comment">// 遍历主串</span></span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到下标0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 如果没有孩子节点,则创建一个</span></span><br><span class="line">		p=ch[p][j]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1,标记从根节点出发到该节点是一个模式串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 1:将根节点的儿子入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">		<span class="keyword">if</span>(ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="comment">// 2:当队列非空,取队头,建回跳边和转移边</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> v=ch[u][i]; <span class="comment">// 取出儿子节点</span></span><br><span class="line">			<span class="comment">// 如果有儿子节点,构建v的回跳边为父节点的回跳边所指向的儿子</span></span><br><span class="line">			<span class="keyword">if</span>(v) ne[v]=ch[ne[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="comment">// 如果没有儿子节点,构建u的转移边为回跳边所指向节点的儿子</span></span><br><span class="line">			<span class="keyword">else</span> ch[u][i]=ch[ne[u]][i]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找单词出现次数,传入字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;s[k];k++) &#123;</span><br><span class="line">		i=ch[i][s[k]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// i指针指向s[k]这个字符对应的节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&amp;&amp;~cnt[j];j=ne[j]) <span class="comment">// j指针从当前指针开始,沿沿着回跳边跑</span></span><br><span class="line">			ans+=cnt[j],cnt[j]=<span class="number">-1</span>; <span class="comment">// 如果有标记,则累加答案,无论有无标记,都把标记清空,视情况嗷</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n; <span class="comment">// 模式串个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;str;	</span><br><span class="line">		<span class="built_in">insert</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>();</span><br><span class="line">	cin&gt;&gt;str; <span class="comment">// 输入主串</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">query</span>(str)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" rel="tag">算法竞赛</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-sea-side.svg" alt="漂至"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>