<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC自动机</title>
    <url>/2024/10/05/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="ac自动机">AC自动机</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a><ul>
<li><a href="#1-%E6%9E%84%E5%BB%BAtrie%E6%A0%91">1. 构建Trie树</a></li>
<li><a href="#2-%E6%9E%84%E9%80%A0ac%E8%87%AA%E5%8A%A8%E6%9C%BA">2. 构造AC自动机</a><ul>
<li><a href="#21-%E5%9B%9E%E8%B7%B3%E8%BE%B9">2.1. 回跳边</a></li>
<li><a href="#22-%E8%BD%AC%E7%A7%BB%E8%BE%B9">2.2. 转移边</a></li>
<li><a href="#23-%E7%94%A8bfs%E6%9E%84%E9%80%A0ac%E8%87%AA%E5%8A%A8%E6%9C%BA">2.3. 用BFS构造AC自动机</a></li>
</ul>
</li>
<li><a href="#3-%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0">3. 查找单词出现次数</a></li>
<li><a href="#4-kmp%E4%B8%8Eac%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AF%B9%E6%AF%94">4. KMP与AC自动机对比</a></li>
<li><a href="#5-%E4%BE%8B%E6%B4%9B%E8%B0%B7p3808-ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%80%E5%8D%95">5. 【例】洛谷P3808 AC自动机(简单)</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<blockquote>
<p>跟学视频：<a href="https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F08【模板】AC自动机_</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>$AC$自动机是多模式匹配算法，给定$n$个模式串和一个主串，查找有多少个模式串在主串中出现过。</li>
</ul>
<blockquote>
<p>复习一下字典树吧：<a href="https://blog.csdn.net/qq_63586399/article/details/136725155?spm=1001.2014.3001.5502">【C++算法模板】字典树，超详细注释带例题讲解-CSDN博客</a></p>
</blockquote>
<h3><span id="1-构建trie树">1. 构建Trie树</span></h3><ul>
<li>我们先用n个模式串构造一颗Trie。</li>
<li>Trie中的一个节点表示一个从根到当前节点的字符串。</li>
<li>根节点表示空串，节点⑤表示“s”，节点6表示“sh”，节点7表示“she”。</li>
<li>如果节点是个模式串，则打个标记。例如，cnt[7]&#x3D;1。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213085433083.png" alt="image-20240213085433083"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树的insert函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123; <span class="comment">// 遍历主串</span></span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到下标0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 如果没有孩子节点,则创建一个</span></span><br><span class="line">		p=ch[p][j]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1,标记从根节点出发到该节点是一个模式串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="2-构造ac自动机">2. 构造AC自动机</span></h3><ul>
<li>构造AC自动机的过程就是在Trie树上构建两类边：<strong>回跳边</strong>和<strong>转移边</strong></li>
</ul>
<h4><span id="21-回跳边">2.1. 回跳边</span></h4><ul>
<li><p>开一个数组ne[]，ne[v] 存节点v的回跳边的终点，如：ne[7]&#x3D;3，表示节点7的回跳边的终点是3</p>
</li>
<li><p>回跳边指向<strong>父节点的回跳边所指节点的儿子</strong>，对于ne[7]&#x3D;3来说，7的父节点是6，6的子节点是3，所以7指向3，此时四个点$(v,u,ne[u],ch[][])$构成四边形</p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213091335787.png" alt="image-20240213091335787" style="zoom:80%;">
</li>
<li><p>并且回跳边所指节点一定是当前节点的<strong>最长后缀</strong>，cnt[7]&#x3D;1，代表模式串是she，cnt[3]&#x3D;1，代表模式串是he，此时he是she的最长后缀，下图中绿色边代表回跳边。</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213090937272.png" alt="image-20240213090937272" style="zoom:80%;">



<h4><span id="22-转移边">2.2. 转移边</span></h4><ul>
<li>转移边指向的是<strong>当前节点的回跳边所指节点的儿子</strong>，转移边和树边共同存储在数组$ch[][]$中<ul>
<li>$ch[u][i]$存节点u的树边的终点，如$ch[6][e]&#x3D;7$，节点6走e边到达节点7</li>
<li>$ch[u][i]$存节点u的转移边的终点，如$ch[7][r]$&#x3D;4，节点7的回跳边是3，节点3的儿子是节点4，注意上图中没有画出转移边，只有树边和回跳边</li>
</ul>
</li>
<li>此时三个点$(u,ne[u],ch[][])$构成三角形</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213092022148.png" alt="image-20240213092022148"></p>
<ul>
<li>转移边所指节点一定是当前节点的<strong>最短路</strong>，比如$ch[7][r]&#x3D;4$，那么从节点7到达节点4的最短路就是这条直通的r，而不是回溯到根节点再重新匹配到节点4</li>
</ul>
<h4><span id="23-用bfs构造ac自动机">2.3. 用BFS构造AC自动机</span></h4><ol>
<li>初始化，把根节点的儿子们入队（枚举26次，因为只有26个字母）</li>
<li>只要队不空，队头节点u出队，枚举u的26个儿子<ol>
<li>若儿子存在，则爹帮儿子建回跳边，并把儿子入队</li>
<li>若儿子不存在，则爹自建转移边</li>
</ol>
</li>
</ol>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213090937272.png" alt="image-20240213090937272" style="zoom:80%;">

<ul>
<li>上图对应的完整建边过程如下，这里只模拟节点1和节点2的建边过程：</li>
<li>1）对节点1：<ol>
<li>节点1出队，但是节点1下没有儿子，所以不用给他的儿子建回跳边，但是图中节点1的回跳边指向节点0，这是因为ne[]数组是全局变量默认初始化为0，或者可以这样想，根节点代表的是空串，此时节点1的最长后缀也就是空串</li>
<li>现在建转移边，因为节点1的父节点的儿子就是本身，所以建立26条转移边，有$ch[1][e]&#x3D;1$，既节点1的转移边指向自己，对于遍历到父节点的下一条树边h时，当前节点的转移边指向父节点的儿子，所以有$ch[1][h]&#x3D;2$，同理有$ch[1][s]&#x3D;5$，那么对于父节点0的其他边(即不存在的边)有$ch[1][···]&#x3D;0$，指向咱们的根节点</li>
</ol>
</li>
<li>2）对节点2：<ol>
<li>节点2出队，因为节点2下的有儿子节点3，所以先为节点3建立回跳边为节点3的父节点的回跳边指向的儿子，其实就是节点1，所以有$ne[3]&#x3D;1$，并且将节点3入队</li>
<li>因为只有这一个儿子，随后建立25条转移边，节点2的父节点0在e之后(因为e已经用于做最长后缀去建回跳边了)的树边有h和s，对h和s建立回跳边的过程同上，所以有$ch[2][h]&#x3D;2$、$ch[2][s]&#x3D;5$、$ch[2][···]&#x3D;0$</li>
</ol>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213094042809.png" alt="image-20240213094042809" style="zoom:80%;">

<ul>
<li>时间复杂度O(26n)，一共需要入队出队n个字符，n是模式串所有的总长度，每个节点都要枚举26次，要么帮儿子建回跳边，要么自己建转移边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 存储回跳边的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 1:将根节点的儿子入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">		<span class="keyword">if</span>(ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="comment">// 2:当队列非空,取队头,建回跳边和转移边</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> v=ch[u][i]; <span class="comment">// 取出儿子节点</span></span><br><span class="line">			<span class="comment">// 如果有儿子节点,构建v的回跳边为父节点的回跳边所指向的儿子</span></span><br><span class="line">			<span class="keyword">if</span>(v) ne[v]=ch[ne[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="comment">// 如果没有儿子节点,构建u的转移边为回跳边所指向节点的儿子</span></span><br><span class="line">			<span class="keyword">else</span> ch[u][i]=ch[ne[u]][i]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="3-查找单词出现次数">3. 查找单词出现次数</span></h3><ul>
<li><p>匹配的方式和$KMP$类似，是一个双指针匹配，首先扫描主串，依次取出字符s[k]</p>
</li>
<li><p>1）i 指针走主串对应的节点，沿着<strong>树边</strong>或<strong>转移边</strong>走，保证不回退</p>
</li>
<li><p>2）j 指针沿着<strong>回跳边</strong>搜索模式串，每次从当前节点走到根节点，把当前节点中的所有<strong>后缀模式串</strong>一网打尽，保证不漏解。</p>
</li>
<li><p>3）扫描完主串，返回答案</p>
</li>
<li><p>算法一边走串，一边把当前串的所有后缀串搜出来，实在是强，对于此过程的模拟，建议听原视频（因为太复杂了不想写）</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1tF41157Dy/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F08【模板】AC自动机_哔哩哔哩_bilibili</a>，从$24:48$ 开始</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213101043808.png" alt="image-20240213101043808"></p>
<ul>
<li>时间复杂度$O(n+m)$，m是主串长度，n是所有模式串的总长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找单词出现次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;s[k];k++) &#123;</span><br><span class="line">		i=ch[i][s[k]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// i指针指向s[k]这个字符对应的节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&amp;&amp;~cnt[j];j=ne[j]) <span class="comment">// j指针从当前指针开始,沿沿着回跳边跑</span></span><br><span class="line">			ans+=cnt[j],cnt[j]=<span class="number">-1</span>; <span class="comment">// 如果有标记,则累加答案,无论有无标记,都把标记清空,注意这里的写法不是固定的,如果题目要求出现几次就累计几次,那么cnt[j]是不用清空的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="4-kmp与ac自动机对比">4. KMP与AC自动机对比</span></h3><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213102219322.png" alt="image-20240213102219322" style="zoom: 80%;">



<h3><span id="5-例洛谷p3808-ac自动机简单">5. 【例】洛谷P3808 AC自动机(简单)</span></h3><ul>
<li>给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过，当两个模式串编号不同时即视为不同的模式串。</li>
<li>注意：$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213103041931.png" alt="image-20240213103041931"></p>
<ul>
<li>注意：$s_1$，$s_2$，$s_4$ 都在串$abcd$里出现过</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240213103223172.png" alt="image-20240213103223172" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Trie树的题目一定限制了字符的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ch[i][j]=2:i是层数(根节点从0开始),j表示字母,下标0表示&#x27;a&#x27;,2是当前记录到哪个点的编号</span></span><br><span class="line"><span class="comment">// cnt[i]=1,以当前点结尾的串是一个模式串</span></span><br><span class="line"><span class="comment">// idx:下标是0的点,既是根节点,也是空节点</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 存储回跳边的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 模式串个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN=<span class="number">1e6</span><span class="number">+10</span>; <span class="comment">// 模式串最长长度</span></span><br><span class="line"><span class="type">char</span> str[MAX_LEN]; <span class="comment">// 存储模式串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树的insert函数,传入字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123; <span class="comment">// 遍历主串</span></span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到下标0~25</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 如果没有孩子节点,则创建一个</span></span><br><span class="line">		p=ch[p][j]; <span class="comment">// 走到p的子节点,继续往下遍历和创建</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词个数+1,标记从根节点出发到该节点是一个模式串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建AC自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 1:将根节点的儿子入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) </span><br><span class="line">		<span class="keyword">if</span>(ch[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="comment">// 2:当队列非空,取队头,建回跳边和转移边</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> v=ch[u][i]; <span class="comment">// 取出儿子节点</span></span><br><span class="line">			<span class="comment">// 如果有儿子节点,构建v的回跳边为父节点的回跳边所指向的儿子</span></span><br><span class="line">			<span class="keyword">if</span>(v) ne[v]=ch[ne[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">			<span class="comment">// 如果没有儿子节点,构建u的转移边为回跳边所指向节点的儿子</span></span><br><span class="line">			<span class="keyword">else</span> ch[u][i]=ch[ne[u]][i]; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找单词出现次数,传入字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;s[k];k++) &#123;</span><br><span class="line">		i=ch[i][s[k]-<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// i指针指向s[k]这个字符对应的节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&amp;&amp;~cnt[j];j=ne[j]) <span class="comment">// j指针从当前指针开始,沿沿着回跳边跑</span></span><br><span class="line">			ans+=cnt[j],cnt[j]=<span class="number">-1</span>; <span class="comment">// 如果有标记,则累加答案,无论有无标记,都把标记清空,视情况嗷</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n; <span class="comment">// 模式串个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;str;	</span><br><span class="line">		<span class="built_in">insert</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>();</span><br><span class="line">	cin&gt;&gt;str; <span class="comment">// 输入主串</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">query</span>(str)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/10/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2024/10/07/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="kmp算法">KMP算法</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84">1. 求解next数组</a></li>
<li><a href="#2-%E6%B1%82%E8%A7%A3%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">2. 求解匹配位置的核心函数</a></li>
<li><a href="#3-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">3. 完整代码</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>在做模式串与文本串的匹配问题时，匹配失败时，如果每次都只向后递进一位，时间复杂度为 $O(n+m)$，很容易被卡成 $O(m×n)$ ，所以为了降低字符串匹配算法的时间复杂度，对模式串中的每一位，设置<strong>唯一</strong>的<strong>特定变化位置</strong>，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间</li>
<li><strong>如果主串已匹配相等的前缀序列中有某个后缀恰等于模式串的前缀，那么可以直接将模式串向后滑动到与这些相等字符对其的位置</strong>，用 $ne$ 数组记录到它为止的<strong>模式串前缀的真前缀和真后缀最大相同的位置</strong></li>
<li>当 $i&#x3D;1$ 或 $i&#x3D;2$ 时，$ne[i]$ 的返回值是 $1$，即 $ne[1]&#x3D;ne[2]&#x3D;1$ (当下标从 $1$ 开始)，因为当 $n&#x3D;1$ 时（只有一个元素，此时无前后缀），当 $n&#x3D;2$ 时（两个元素，一个是前缀一个是后缀，仍然回溯到第一个位置）</li>
</ul>
<h2><span id="1-求解next数组">1. 求解next数组</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求next数组的过程[s1与自己匹配,通过前后缀来更新ne数组]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s1[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">        j=ne[j]; <span class="comment">// 如果不匹配的话,j就一直后退</span></span><br><span class="line">    <span class="keyword">if</span>(s1[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">        j++; <span class="comment">// 如果当前匹配成功的,j向前递推一位</span></span><br><span class="line">    ne[i]=j; <span class="comment">// 记录并且更新当前j的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当看不懂或者忘了的时候建议自己调试模拟跟踪一遍</p>
</li>
<li><p>因为 $ne$ 数组是全局初始化，$while()$ 语句中的 $j$ 保证了 $ne[1]&#x3D;ne[2]$ </p>
</li>
<li><p>注意next数组的值是根据模式串的前缀和后缀的最大相同位置来的，所以匹配自己。</p>
</li>
</ul>
<h2><span id="2-求解匹配位置的核心函数">2. 求解匹配位置的核心函数</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求匹配的过程[i遍历文本串]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len2;i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果不匹配的话,j回退</span></span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s2[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">        j=ne[j];</span><br><span class="line">    <span class="comment">// 如果相等的话,j向前递推一位</span></span><br><span class="line">    <span class="keyword">if</span>(s2[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">// 刚好长度相等的话说明匹配上了,把下标打印出来</span></span><br><span class="line">    <span class="keyword">if</span>(j==len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文本串的位置减去长度即为下标,加1得到位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-len1<span class="number">+1</span>);</span><br><span class="line">        <span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">        <span class="comment">// 需要让j回退到一定位置,再让i加1继续进行比较</span></span><br><span class="line">        <span class="comment">// 回退到ne[j]可以保证j最大,即已经成功匹配的部分最长</span></span><br><span class="line">        j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心实现和求解 $next$ 数组的函数差不多，主要是是模式串和文本串之间的匹配，当 $j&#x3D;&#x3D;len1$ 的时候说明大小相等即匹配上了，这个时候把相应的下标位置输出出来，同时 $j$ 还是要回溯，因为怕遇到位置重叠的情况。</li>
</ul>
<h2><span id="3-完整代码">3. 完整代码</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP - 洛谷</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> len1,len2; <span class="comment">// n是模板串长度,m是文本串</span></span><br><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// next[i] 就是使子串 s2[0···i] 有最长相等前后缀的前缀的最后一位的下标</span></span><br><span class="line"><span class="type">char</span> s1[N],s2[N]; <span class="comment">// s1[]存储模式串,s2[]存储文本串</span></span><br><span class="line"><span class="comment">// 计算p[]在s[]中出现的位置</span></span><br><span class="line"><span class="comment">// ne代表next数组,因为next在C++中是关键字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;s1<span class="number">+1</span>&gt;&gt;s2<span class="number">+1</span>; <span class="comment">// 先输入模式串,再输入文本串[从下标1开始]</span></span><br><span class="line">	len1=<span class="built_in">strlen</span>(s1<span class="number">+1</span>);</span><br><span class="line">	len2=<span class="built_in">strlen</span>(s2<span class="number">+1</span>);</span><br><span class="line">	cout&lt;&lt;len1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;len2&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 求next数组的过程[s1与自己匹配,通过前后缀来更新ne数组]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s1[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j]; <span class="comment">// 如果不匹配的话,j就一直后退</span></span><br><span class="line">		<span class="keyword">if</span>(s1[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">			j++; <span class="comment">// 如果当前匹配成功的,j向前递推一位</span></span><br><span class="line">		ne[i]=j; <span class="comment">// 记录并且更新当前j的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求匹配的过程[i遍历文本串]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=len2;i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果不匹配的话,j回退</span></span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s2[i]!=s1[j<span class="number">+1</span>])</span><br><span class="line">			j=ne[j];</span><br><span class="line">		<span class="comment">// 如果相等的话,j向前递推一位</span></span><br><span class="line">		<span class="keyword">if</span>(s2[i]==s1[j<span class="number">+1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">// 刚好长度相等的话说明匹配上了,把下标打印出来</span></span><br><span class="line">		<span class="keyword">if</span>(j==len1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 文本串的位置减去长度即为下标</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-len1);</span><br><span class="line">			<span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">			<span class="comment">// 需要让j回退到一定位置,再让i加1继续进行比较</span></span><br><span class="line">			<span class="comment">// 回退到ne[j]可以保证 j 最大,即已经成功匹配的部分最长</span></span><br><span class="line">			j=ne[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 还需要把next数组输出出来</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> num:ne) </span><br><span class="line">		cout&lt;&lt;num&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>lower_bound、upper_bound函数</title>
    <url>/2024/10/03/lower-bound%E3%80%81upper-bound%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="lower_bound和upper_bound">lower_bound和upper_bound</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8">2. 函数使用</a></li>
<li><a href="#3-%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81">3. 案例代码</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-概述">1. 概述</span></h2><ul>
<li>$lower_bound()$ 和$upper_bound()$ 都是基于<strong>二分查找</strong>在一个<strong>排好序</strong>的数组或容器（如 $vector,\ list,\ set$ ）中进行快速查找的函数，位于 $<algorithm>$ 标准库中，由于采用二分查找，所以函数的时间复杂度是 $O(log_2^n)$</algorithm></li>
<li><strong>划重点！基于二分查找！数组或容器必须有序！</strong></li>
</ul>
<h2><span id="2-函数使用">2. 函数使用</span></h2><ul>
<li><p>$lower_bound(begin,end,num)$：适用于<strong>从小到大排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>大于等于</strong> $num$ 的数字</p>
<ul>
<li>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $lower_bound(arr,arr+n,3)-arr$ 表示在数组 $arr$ 中查找第一个大于等于 $3$ 的元素在数组中的下标</li>
<li>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</li>
</ul>
</li>
<li><p>$upper_bound(begin,end,num)$：适用于<strong>从小到大排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>大于</strong> $num$ 的数字</p>
<ul>
<li><p>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $upper_bound(arr,arr+n,3)-arr$ 表示在数组 $arr$ 中查找第一个大于 $3$ 的元素在数组中的下标</p>
</li>
<li><p>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</p>
</li>
</ul>
</li>
<li><p>$lower_bound(begin,end,num,greater<type>())$：适用于<strong>从大到小排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>小于等于</strong> $num$ 的数字</type></p>
<ul>
<li>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $lower_bound(arr,arr+n,3,greater<int>())-arr$ 表示在数组 $arr$ 中查找第一个小于等于 $3$ 的元素在数组中的下标</int></li>
<li>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</li>
</ul>
</li>
<li><p>$upper_bound(begin,end,num,greater<type>())$：适用于<strong>从大到小排序</strong>的有序序列，从数组&#x2F;容器的 $begin$ 位置起，到 $end-1$ 位置结束，查找第一个<strong>小于</strong> $num$ 的数字</type></p>
<ul>
<li><p>若找到则返回该数字的地址，通过减去起始地址 $begin$ 的技巧可以求得其在数组&#x2F;容器中的下标，如 $upper_bound(arr,arr+n,3,greater<int>())-arr$ 表示在数组 $arr$ 中查找第一个小于 $3$ 的元素在数组中的下标</int></p>
</li>
<li><p>若找不到，则返回 $end$，即数组&#x2F;容器最后一个元素的下一个元素</p>
</li>
</ul>
</li>
</ul>
<h2><span id="3-案例代码">3. 案例代码</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 升序</span></span><br><span class="line">	<span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	sort(arr,arr+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;序列为(从小到大排序):&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:arr) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 1.lower_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;lower_bound(arr,arr+<span class="number">5</span>,<span class="number">5</span>)-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个大于等于5的是5,下标是3</span></span><br><span class="line">	<span class="comment">// 2.upper_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;upper_bound(arr,arr+<span class="number">5</span>,<span class="number">6</span>)-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个大于6的是8,下标是4</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 降序</span></span><br><span class="line">	sort(arr,arr+<span class="number">5</span>,greater&lt;<span class="type">int</span>&gt;()); <span class="comment">// greater&lt;int&gt;()表示降序规则</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;序列为(从大到小排序):&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:arr) <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 3.lower_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;lower_bound(arr,arr+<span class="number">5</span>,<span class="number">3</span>,greater&lt;<span class="type">int</span>&gt;())-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个小于等于3的是3,下标是2</span></span><br><span class="line">	<span class="comment">// 4.upper_bound</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;upper_bound(arr,arr+<span class="number">5</span>,<span class="number">3</span>,greater&lt;<span class="type">int</span>&gt;())-arr&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 第一个小于等于3的是2,下标是3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>函数速查</tag>
      </tags>
  </entry>
  <entry>
    <title>strcmp、compare函数</title>
    <url>/2024/10/03/strcmp%E3%80%81compare%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="函数速查-strcmp-compare">函数速查-strcmp、compare</span></h1><!-- toc -->

<ul>
<li><a href="#1-strcmp">1. strcmp</a></li>
<li><a href="#2-compare">2. compare</a></li>
<li><a href="#3-%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2">3. 直接比较字符串</a></li>
<li><a href="#4-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83">4. 字符数组&#x2F;字符串按数值比较</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-strcmp">1. strcmp</span></h2><ul>
<li>用于字符数组之间的大小比较</li>
<li>比较原则：两个字符数组逐位比较$ASCII$码，首位$ASCII$码的更大的字符数组更大；当一个字符数组是另一个字符数组的前缀时，长度更长的字符数组更大</li>
<li>$strcmp(str1,str2)$，若前者比后者大，返回$1$，若相等，返回$0$，若后者比前者大，返回$-1$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str_1[<span class="number">20</span>],str_2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 1)逐位比较ASCII码,首位ASCII码更大的字符串更大</span></span><br><span class="line">	<span class="comment">// 前者比后者大,返回1 </span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;CDEF&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;BCDE&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 两者相等,返回0</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 前者比后者小,返回-1</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;bbcde&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 2)其中一个字符串是另一个字符串的前缀,长度更长的字符串更大</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str_1,<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str_2,<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">strcmp</span>(str_1,str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-compare">2. compare</span></h2><ul>
<li>用于字符串之间的大小比较</li>
<li>比较原则：两个字符串逐位比较$ASCII$码，首位$ASCII$码的更大的字符串更大；当一个字符串是另一个字符串的前缀时，长度更长的字符串更大</li>
<li>$strcmp(str1,str2)$，若前者比后者大，返回$1$，若相等，返回$0$，若后者比前者大，返回$-1$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str_1,str_2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 前者比后者大,返回1</span></span><br><span class="line">	str_1=<span class="string">&quot;CDEF&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;BCDE&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 两者相等,返回0</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 前者比后者小,返回-1</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;bbcde&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 2)其中一个字符串是另一个字符串的前缀,长度更长的字符串更大</span></span><br><span class="line">	str_1=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_1.compare(str_2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3)比较特定位置开始的字符串</span></span><br><span class="line">	<span class="type">int</span> res_1=str_1.compare(<span class="number">1</span>,<span class="number">3</span>,str_2); <span class="comment">// str_1从下标1开始的3个字符与str_2比较大小</span></span><br><span class="line">	<span class="type">int</span> res_2=str_1.compare(<span class="number">1</span>,<span class="number">3</span>,str_2,<span class="number">1</span>,<span class="number">4</span>); <span class="comment">// str_1从下标1开始的3个字符与str_2从下标0开始的2个字符比较大小</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res_1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res_2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-直接比较字符串">3. 直接比较字符串</span></h2><ul>
<li>在$C++$中直接使用 $&gt;, &lt;, &#x3D;&#x3D;, &gt;&#x3D;, &lt;&#x3D; $这样的关系运算符也能比较字符串的大小，并且同样基于字符串中字符的字典顺序逐位字符比较，直到遇到不相同的字符或者一个字符串结束为止</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_compare</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前者比后者大&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a==b) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;二者一样大&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;前者比后者小&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str_1,str_2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	str_1=<span class="string">&quot;CDEF&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;BCDE&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="comment">// 两者相等,返回0</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="comment">// 前者比后者小,返回-1</span></span><br><span class="line">	str_1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;bbcde&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="comment">// 2)其中一个字符串是另一个字符串的前缀,长度更长的字符串更大</span></span><br><span class="line">	str_1=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	str_2=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	str_compare(str_1,str_2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-字符数组x2f字符串按数值比较">4. 字符数组&#x2F;字符串按数值比较</span></h2><ul>
<li><p>比如现在有两个数字， $123456$ 和 $23456$ ，并且是以字符形式存储到字符数组&#x2F;字符串中，现在要比较这两个字符数组&#x2F;字符串的大小关系如果直接使用前文的比较方法(按$ASCII$码逐位比较就会出问题)，因为$1$的$ASCII$码小于$2$，但很明显$123456&gt;23456$</p>
</li>
<li><p>如果在字符数组&#x2F;字符串中按下标对其的话又略嫌麻烦，显然是想让$123456$和$23456$都从下标$0$开始存储，这个时候我们可以(在没有前导$0$的情况下)返回长度更长的那个数字，当长度相等的时候直接用$strcmp$或者$compare$比较两个字符串即可</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[<span class="number">20</span>],str2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> str11,str22;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">chars_compare</span><span class="params">(<span class="type">char</span> str1[],<span class="type">char</span> str2[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> len1=<span class="built_in">strlen</span>(str1);</span><br><span class="line">	<span class="type">int</span> len2=<span class="built_in">strlen</span>(str2);</span><br><span class="line">	<span class="keyword">if</span>(len1!=len2) <span class="keyword">return</span> len1&gt;len2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(str1,str2)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">str_compare</span><span class="params">(<span class="built_in">string</span> str11,<span class="built_in">string</span> str22)</span> &#123;</span><br><span class="line">	<span class="type">int</span> len1=str11.length();</span><br><span class="line">	<span class="type">int</span> len2=str22.length();</span><br><span class="line">	<span class="keyword">if</span>(len1!=len2) <span class="keyword">return</span> len1&gt;len2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> str11.compare(str22)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 字符数组</span></span><br><span class="line">	<span class="built_in">strcpy</span>(str1,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str2,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;chars_compare(str1,str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(str1,<span class="string">&quot;34&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str2,<span class="string">&quot;23&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;chars_compare(str1,str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 字符串</span></span><br><span class="line">	str11=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">	str22=<span class="string">&quot;1234&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_compare(str11,str22)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	str11=<span class="string">&quot;34&quot;</span>;</span><br><span class="line">	str22=<span class="string">&quot;23&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str_compare(str11,str22)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>函数速查</tag>
      </tags>
  </entry>
  <entry>
    <title>substr函数</title>
    <url>/2024/10/03/substr%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="函数速查-substr">函数速查-substr</span></h1><ul>
<li>$substr$ 函数用于截取字符串，$substr(pos,\ n)$ 指从指定字符串的 $pos$ 索引起向后截取 $n$ 个字符，具体使用方法见代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">string</span> s=<span class="string">&quot;01234567&quot;</span>; <span class="comment">// 索引从0开始</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s1=s.substr(); <span class="comment">// 1)不传参等价于复制字符串</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 01234567</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s2=s.substr(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 2)传递2个参数,截取从字符串s下标0开始往后的2个字符</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 01</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s3=s.substr(<span class="number">4</span>); <span class="comment">// 3)传递1个参数,截取s索引为4到字符串尾部</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4567</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s4=s.substr(<span class="number">8</span>); <span class="comment">// 4)若pos超过了string的大小,不抛出异常但没有输出</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 不输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s5=s.substr(<span class="number">2</span>,<span class="number">10</span>); <span class="comment">// 5)若pos+n超过了string的大小,则自动调整n的值,最多只截取到s的末尾</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s5&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 234567</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s6=s.substr(<span class="number">-1</span>); <span class="comment">// 6)pos传入负值,抛出out_of_range异常(RE运行时错误)</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s6&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 报错,RE</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s7=s.substr(<span class="number">3</span>,<span class="number">-2</span>); <span class="comment">// 7)n传入负值,则默认截取到字符串末尾</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;s7&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 34567</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>函数速查</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2024/10/07/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="乘法逆元">乘法逆元</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9D%BF%E5%AD%90">1. 板子</a></li>
<li><a href="#2-%E6%80%A7%E8%B4%A8">2. 性质</a></li>
<li><a href="#3-%E7%BA%BF%E6%80%A7%E6%B1%82%E9%80%86%E5%85%83%E6%9D%BF%E5%AD%90">3. 线性求逆元板子</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>同余式：如果 $a,b$ 模 $m$ 的余数相同，则称 $a,b$ 模 $m$ 同余，记为 $a\equiv b$，例如：$8 \equiv 2\ (mod\ 3)$</p>
</li>
<li><p>乘法逆元：若 $a,b$ 互质，且满足同余方程 $ax\equiv 1\ (mod \ b)$，则称 $x$ 为 $a\ mod \ b$ 的乘法逆元，记作 $a^{-1}$，例如：$8x \equiv 1\ (mod\ 5)$，解得 $x&#x3D;2,7,12…$</p>
</li>
<li><p>费马小定理：若 $p$ 为质数，且 $a,p$ 互质，则 $a^{p-1}\equiv1\ (mod\ p)$，例如：$4^{3-1}\equiv 1(mod\ 3)$</p>
</li>
<li><p>费马小定理求乘法逆元：$a^{p-1}\equiv1\ (mod\ p)$，得 $a×a^{p-2}\equiv 1\ (mod\ p)$，根据乘法逆元的定义，所以 $a^{p-2}$ 就是 $a$ 模 $p$ 的乘法逆元</p>
</li>
</ul>
<h2><span id="1-板子">1. 板子</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 幂取余,a^b%p</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>; <span class="comment">// 累乘因子</span></span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*a%p; <span class="comment">// 提权</span></span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;p;</span><br><span class="line">    <span class="comment">// 快速幂计算a^(p-2),就是a%p的乘法逆元</span></span><br><span class="line">    <span class="comment">// 如果a,p互质,才有a%p乘法逆元</span></span><br><span class="line">    <span class="keyword">if</span>(a%p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,qmi(a,p<span class="number">-2</span>,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-性质">2. 性质</span></h2><ul>
<li><p>$14&#x2F;4\ (mod\ 5)&#x3D;7&#x2F;2 \ (mod\ 5)&#x3D;7×3\ (mod\ 5)$，这是因为 $2×3\ mod\ 5&#x3D;1$，也可以理解为 $3$ 和 $2$ 在模 $5$ 下互为倒数</p>
</li>
<li><p>求乘法逆元的方法：$2^{-1} \ mod\ 7$，模  $7$ 下 $2$ 的乘法逆元是，求谁乘以 $2$ 再模 $7$ 等于 $1$，很容易口算得到 $4×2\ (mod\ 7)&#x3D;1$</p>
<ul>
<li>通过费马小定理计算，$a^{p-2}$ 即 $2^{7-2}&#x3D;32$</li>
<li>模 $n$ 下互为乘法逆元，一般只考虑比 $n$ 小的，所以 $32$ 对 $7$ 取模得到 $4$，那么模 $7$ 下 $2$ 的乘法逆元是 $4$</li>
</ul>
</li>
<li><p>$a$ 在模 $n$ 内的乘法逆元 $a^{-1}\ (1&lt;&#x3D;a^{-1}&lt;n)$ 是唯一的，比如模 $5$ 下 $2$ 和 $3$ 互为乘法逆元，除此外再无别的逆元</p>
</li>
<li><p>$1$  不管模谁都是余 $1$</p>
</li>
<li><p>$a$ 的乘法逆元的乘法逆元是 $a$，$z&#x3D;a^{-1},\ z^{-1}&#x3D;(a^{-1})^{-1}&#x3D;a$</p>
</li>
<li><p><strong>什么时候用乘法逆元？当题目中推导出来的公式带有除法，并且要让结果对某个数作模运算时</strong>，应用乘法逆元把除法变为乘法，一直除再作模运算是会出错的，可以这样想，加减乘都是从低位起开始运算，只有除法是从高位开始运算，而模运算又是取低几位，所以应该把除法转换为乘法</p>
</li>
</ul>
<h2><span id="3-线性求逆元板子">3. 线性求逆元板子</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">3e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="comment">// 给定n,p,计算1~n中所有整数在模p意义下的乘法逆元</span></span><br><span class="line"><span class="comment">// a模p的乘法逆元定义为 a*a_inv等价于1(mod p),去找a_inv是多少</span></span><br><span class="line"><span class="comment">// 线性求逆元</span></span><br><span class="line"><span class="type">int</span> inv[maxn]; <span class="comment">// 存储每个数字的逆元</span></span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,p;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p; <span class="comment">// n是范围,p是模数</span></span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">// 1的逆元是1, (1*1)mod p=1</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;inv[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		inv[i]=-(p/i)*inv[p%i]; <span class="comment">// x_inv=-k*r_inv (怎么推导的···看b站视频吧)</span></span><br><span class="line">		inv[i]=(inv[i]%p+p)%p; <span class="comment">// 防止负数产生</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;inv[i]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>乘法逆元</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/2024/10/02/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="二分答案">二分答案</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E8%A7%A3%E4%BA%8C%E5%88%86%E9%A2%98%E6%AD%A5%E9%AA%A4">1. 解二分题步骤</a></li>
<li><a href="#2-%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86">2. 整数二分</a><ul>
<li><a href="#21-%E6%B4%9B%E8%B0%B7-p2440%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5">2.1. 洛谷 P2440.木材加工</a></li>
<li><a href="#22-%E6%B4%9B%E8%B0%B7-p1873eko%E7%A0%8D%E6%A0%91">2.2. 洛谷 P1873.EKO&#x2F;砍树</a></li>
<li><a href="#23-%E6%B4%9B%E8%B0%B7-p1678%E7%83%A6%E6%81%BC%E7%9A%84%E9%AB%98%E8%80%83%E5%BF%97%E6%84%BF">2.3. 洛谷 P1678.烦恼的高考志愿</a></li>
<li><a href="#24-%E8%93%9D%E6%A1%A5%E6%9D%AF-23%E7%9C%81b-%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E">2.4. 蓝桥杯 23省b 冶炼金属</a></li>
</ul>
</li>
<li><a href="#3-%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86">3. 浮点二分</a><ul>
<li><a href="#31-acwing-790-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9">3.1. AcWing 790. 数的三次方根</a></li>
</ul>
</li>
<li><a href="#4-%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3">4. 加深理解</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>将答案区间进行二分搜索， 每次取区间中间值出来用于尝试是否满足题目性质，不断缩小调整区间，直到确定最终答案为止</li>
<li>有单调性的题目一定可以二分，但是用二分做的题目不一定拥有单调性。</li>
<li>注意：二分一定是有解的，不可能无解，无解永远是题目的无解而不是二分的无解。</li>
</ul>
<h2><span id="1-解二分题步骤">1. 解二分题步骤</span></h2><ul>
<li>题目出现求最值，首先想到二分&#x2F;贪心&#x2F;动态规划等算法</li>
<li>题目具有单调性，则可以考虑用二分求解</li>
<li>若求满足某个性质的数第一次出现，或求最小值 → 答案在左边 → 满足性质时压缩右边界 → 二分出来的答案一定在 $l$ 上</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案在左边</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 压缩右边界</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 答案在左边界上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>若求满足某个性质的数最后一次出现，或求最大值 → 答案在右边 → 满足性质时压缩左边界 → 二分出来的答案一定在 $r$ 上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案在右边</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 压缩左边界</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;r&lt;&lt;endl; <span class="comment">// 答案在右边界上</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-整数二分">2. 整数二分</span></h2><h3><span id="21-洛谷-p2440木材加工">2.1. 洛谷 P2440.木材加工</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P2440">P2440 木材加工 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 原木/要的根数</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 每根木头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果切出来的数量满足k根说明切够了</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cnt+=a[i]/x;</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="type">int</span> mmax;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		mmax=max(mmax,a[i]); <span class="comment">// 找最大木头数,作为r的初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>; <span class="comment">// 此时切出来最多,每根都能切成a[i]份</span></span><br><span class="line">	<span class="type">int</span> r=mmax; <span class="comment">// 此时切出来最少,只能切一根</span></span><br><span class="line">	<span class="comment">// 找最大值,答案在右边,压缩左边界,答案在r上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 答案一定在r上且r一定比l小1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-洛谷-p1873ekox2f砍树">2.2. 洛谷 P1873.EKO&#x2F;砍树</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1873">P1873 EKO &#x2F; 砍树 - 洛谷 </a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n:树的数量,m:所需总长度</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 存储每棵树的高度</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	ll cnt=<span class="number">0</span>; <span class="comment">// 切出来的长度爆int,题目也说超过M</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-x&gt;<span class="number">0</span>)</span><br><span class="line">			cnt+=a[i]-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;=m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> mmax; <span class="comment">// 存储最大高度作为r的初始值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		mmax=max(mmax,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>; <span class="comment">// 此时每棵树能切出来的长度都是a[i],切得最多</span></span><br><span class="line">	<span class="type">int</span> r=mmax; <span class="comment">// 此时每棵树能切出来的高度都是0,切得最少</span></span><br><span class="line">	<span class="comment">// l能取0吗?如果停在l=0,那么r一定等于-1,此时有问题</span></span><br><span class="line">	<span class="comment">// 找锯片的最大高度,压缩左边界,答案在r上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-洛谷-p1678烦恼的高考志愿">2.3. 洛谷 P1678.烦恼的高考志愿</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1678">P1678 烦恼的高考志愿 - 洛谷 </a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 开ll不然过不了</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll a[N]; <span class="comment">// 存储学校的分数线</span></span><br><span class="line">ll b[N]; <span class="comment">// 存储每个同学的估分</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// n个学校,m个同学</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">	ll cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 遍历所有同学</span></span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="comment">// 卫语言风格</span></span><br><span class="line">		<span class="comment">// 比最小值还小,跳过</span></span><br><span class="line">		<span class="keyword">if</span>(b[i]&lt;=a[<span class="number">1</span>]) &#123;</span><br><span class="line">			cnt+=<span class="built_in">abs</span>(b[i]-a[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b[i]&gt;=a[n]) &#123;</span><br><span class="line">			cnt+=<span class="built_in">abs</span>(b[i]-a[n]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll l=<span class="number">1</span>,r=n; <span class="comment">// 边界是[1,n]</span></span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">			ll mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="comment">// 注意找第一个是答案在左边的问题,所以要压缩右边界</span></span><br><span class="line">			<span class="comment">// 找第一个大于等于b[i]的第一个学校的分数线,答案在左边,即a[l]</span></span><br><span class="line">			<span class="comment">// 那么最后一个小于b[i]的元素的下标就应该是a[l-1]</span></span><br><span class="line">			<span class="keyword">if</span>(a[mid]&gt;=b[i])</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 取二者之中的最小值</span></span><br><span class="line">		cnt+=min(<span class="built_in">abs</span>(a[l]-b[i]),<span class="built_in">abs</span>(a[l<span class="number">-1</span>]-b[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="24-蓝桥杯-23省b-冶炼金属">2.4. 蓝桥杯 23省b 冶炼金属</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P9240">P9240 [蓝桥杯 2023 省 B] 冶炼金属 </a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 存储每次投入的金属数量</span></span><br><span class="line"><span class="type">int</span> b[N]; <span class="comment">// 存储每次冶炼出的特殊金属数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_1</span><span class="params">(<span class="type">int</span> mid)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]/mid&gt;b[i])	</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_2</span><span class="params">(<span class="type">int</span> mid)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]/mid&lt;b[i])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> mmax=INT_MIN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]);	</span><br><span class="line">		mmax=max(mmax,a[i]); <span class="comment">// 最大的普通金属数量</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;最大值是&quot;&lt;&lt;mmax&lt;&lt;endl;</span></span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>; <span class="comment">// 转换率最小为1,有多少转换多少</span></span><br><span class="line">	<span class="type">int</span> r=mmax; <span class="comment">// 最小只能转换出一个</span></span><br><span class="line">	<span class="comment">// 找最小值,压缩右边界,答案在l上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=(ll)l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check_1(mid)) &#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	l=<span class="number">1</span>,r=mmax;</span><br><span class="line">	<span class="comment">// 找最大值,压缩左边界,答案在r上</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=(ll)l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check_2(mid)) &#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-浮点二分">3. 浮点二分</span></h2><h3><span id="31-acwing-790-数的三次方根">3.1. AcWing 790. 数的三次方根</span></h3><blockquote>
<p>题目链接：<a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根 - AcWing题库</a></p>
</blockquote>
<ul>
<li>对于开二次方根，因为开出来一定是正数，所以可以设置$l&#x3D;0$，$r&#x3D;x$，但是三次方根可能有负数，不能单纯的取 $l&#x3D;-x$，$r&#x3D;x$，这样的话输入的$x$是正数，范围是$[-x,x]$，输入的数是负数，范围是$[x,-x]$就会出大问题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> x;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="comment">// 因为是开三次方根,所以要考虑负数的情况</span></span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">	<span class="type">double</span> l=<span class="number">-100000</span>,r=<span class="number">100000</span>;</span><br><span class="line">	<span class="comment">// 保留6位小数就1e-8(基于经验),同理保留4位就1e-6</span></span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>) &#123;</span><br><span class="line">		<span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid*mid*mid&gt;=x)</span><br><span class="line">			r=mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;fixed&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-加深理解">4. 加深理解</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;下标:&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;数值:&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">10</span>; <span class="comment">// 下标边界</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 1)找第一个大于等于3的元素的下标,看是3还是4呢?</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&gt;=<span class="number">3</span>) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1)找第一个大于等于3的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 找最小值,答案是l,r一定是l-1</span></span><br><span class="line">	<span class="comment">// 2)找第一个大于3的元素的下标,是5吧而不是6吧</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&gt;<span class="number">3</span>) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;2)找第一个大于3的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 3)找第一个大于等于2且小于等于4的元素的下标,是5而不是4吧</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>&lt;=a[mid] &amp;&amp; a[mid]&lt;=<span class="number">4</span>) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;3)找第一个大于等于2且小于等于4的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 4)找最后一个小于等于4的元素</span></span><br><span class="line">	<span class="comment">// 压缩l,答案一定在r上,此时l必为r+1</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;=<span class="number">4</span>) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;4)找最后一个小于等于4的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 5)找最后一个小于6的元素,下标为7,答案在r</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;<span class="number">7</span>) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;5)找最后一个小于6的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 6)找最后一个大于2且小于等于8的元素,值是8</span></span><br><span class="line">	l=<span class="number">1</span>,r=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&gt;<span class="number">2</span> &amp;&amp; a[mid]&lt;=<span class="number">8</span>) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;6)找最后一个大于2且小于等于8的元素的下标:&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot; 答案是:&quot;</span>&lt;&lt;a[r]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/2024/10/04/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="二分图">二分图</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9F%93%E8%89%B2%E6%B3%95">1. 染色法</a></li>
<li><a href="#2-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95">2. 匈牙利算法</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>二分图当且仅当图中不含奇数环，可以把所有点划分成两边，使得所有的边都是在集合之间的，集合内没有边。</li>
</ul>
<img src="E:/Typora/%E5%9B%BE%E7%89%87/image-20240201103004073.png" alt="image-20240201103004073" style="zoom:80%;">

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240201103116146.png" alt="image-20240201103116146" style="zoom:80%;">



<p>​		如果图中存在奇数环，那么会出现下面这种自相矛盾的情况。</p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240201103038838.png" alt="image-20240201103038838">



<h2><span id="1-染色法">1. 染色法</span></h2><blockquote>
<p>时间复杂度O(n+m)，用于判断一个图是否为二分图</p>
</blockquote>
<p>只要图中不存在奇数环，染色过程就不会出现矛盾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 染色法:</span></span><br><span class="line"><span class="comment">// for v=1~n: 如果没有染色,dfs(v)</span></span><br><span class="line"><span class="comment">// 宽搜和深搜都能实现,但是深搜代码短</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span><span class="number">+10</span>)*<span class="number">2</span>; <span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	color[u]=c; <span class="comment">// 把当前点染成c色</span></span><br><span class="line">	<span class="comment">// 遍历与u相连的所有边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="comment">// 取出相连的边的点</span></span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="comment">// 如果没有染色</span></span><br><span class="line">		<span class="keyword">if</span>(!color[j]) &#123;</span><br><span class="line">			<span class="comment">// 3-c:如果c为1,则3-c为2,表示染成2色;如果c为2,则3-c为1,表示染成1色</span></span><br><span class="line">			<span class="comment">// 如果无法像这样染色,则返回false</span></span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果颜色发生冲突,则直接返回false</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">add</span>(a,b);</span><br><span class="line">		<span class="built_in">add</span>(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">true</span>; <span class="comment">// 未发生冲突</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果没有染色</span></span><br><span class="line">		<span class="keyword">if</span>(!color[i]) &#123;</span><br><span class="line">			<span class="comment">// 如果深搜发生冲突(染色冲突)</span></span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>)) &#123;</span><br><span class="line">				flag=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4个点4条边</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">Yes</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-匈牙利算法">2. 匈牙利算法</span></h2><blockquote>
<p>时间复杂度O(mn)，实际执行时间远小于O(mn)：求二分图的最大匹配数</p>
</blockquote>
<ul>
<li><p>注意需要满足是二分图这个前提才能使用匈牙利算法。</p>
</li>
<li><p>下面这个图个人感觉有问题，应该是先 (1,5)，后找到 (2,8)，再找到 (3,5) 这时发现5已经被1占有，所以1退而求其次找到7，变为 (1,7)，对于4，只有 (4,8)，但2也仅与 8 相连，所以最大匹配数为3，匹配为：(1,7)、(2,8)、(3,5)</p>
</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240201103242589.png" alt="image-20240201103242589" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有两条边共用一个点,表示匹配</span></span><br><span class="line"><span class="comment">// 求图中的最大匹配数 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1,n2,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 去查找这个与这个点相连的所有边的点集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">			st[j]=<span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 如果这个点还没有和任何点匹配,并且也没有其他点与自身相连,则返回true</span></span><br><span class="line">			<span class="keyword">if</span>(match[j]==<span class="number">0</span> || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">				match[j]=x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">add</span>(a,b); <span class="comment">// 有向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>; <span class="comment">// 存放最终答案</span></span><br><span class="line">	<span class="comment">// 遍历二分图中n1这个点集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st); <span class="comment">// 用于寻找增广路径时重置st</span></span><br><span class="line">		<span class="comment">// 如果能找到匹配点,则res++</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(i))</span><br><span class="line">			res++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左边2点,右边2点,共4条边</span></span><br><span class="line"><span class="comment">1 1(表示左边点1和右边点1有边)</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">2 2 4</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/2024/10/03/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="前缀和">前缀和</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">1. 一维前缀和</a></li>
<li><a href="#2-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">2. 二维前缀和</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>因为前缀和这个板子的推导比较简单，因此本博客重点在于知识点归纳而不在于证明</li>
</ul>
<h2><span id="1-一维前缀和">1. 一维前缀和</span></h2><ul>
<li>一维数组的前缀和计算公式：$s[i]&#x3D;\sum_{i&#x3D;1}^ia[i]&#x3D;s[i-1]+a[i]$，时间复杂度 $O(n)$</li>
<li>原数组 $[l,r]$ 区间和计算公式：$s[r]-s[l-1]$ ，时间复杂度 $O(1)$</li>
</ul>
<blockquote>
<p>【例题】AcWing 795，链接：<a href="https://www.acwing.com/problem/content/797/">795. 前缀和 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入规模超过1e5时推荐使用scanf而不是cin和cout</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h2><span id="2-二维前缀和">2. 二维前缀和</span></h2><ul>
<li>二维数组的前缀和计算公式：$s[i][j]&#x3D;\sum_{i&#x3D;1}^i\sum_{j&#x3D;1}^ja[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$，时间复杂度 $O(n^2)$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031156232.png" alt="image-20240316232827015"></p>
<ul>
<li>原数组 $(x_1,y_1)$ 到 $(x_2,y_2)$ 区间和计算公式：$s[x_2][y_2]-s[x_1-1][y_2]-s[x_2][y_1-1]+s[x_1-1][x_2-1]$ ，时间复杂度 $O(1)$</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031156219.png" alt="image-20240316232908005"></p>
<blockquote>
<p>【例题】AcWing 796，链接：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/4324/">796. 子矩阵的和 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容斥原理:</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> s[N][N]; <span class="comment">// 二维前缀和矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">			<span class="comment">// 预处理二维前缀和数组</span></span><br><span class="line">			s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">		<span class="comment">// 算区间和</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>前缀和</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列</title>
    <url>/2024/10/03/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="单调队列">单调队列</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">1. 单调队列</a><ul>
<li><a href="#11-%E7%BB%B4%E6%8A%A4%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC">1.1. 维护滑动窗口的最大值&#x2F;最小值</a></li>
<li><a href="#12-%E7%BB%B4%E6%8A%A4%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">1.2. 维护连续子序列的最大和</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1H5411j7o6/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">C15【模板】单调队列 滑动窗口最值_bilibili</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>用于求滑动窗口内的最小值和最大值</li>
</ul>
<h2><span id="1-单调队列">1. 单调队列</span></h2><ul>
<li>队尾进队出队，队头出队（维护子序列的单调性）的数据结构</li>
<li>队尾出队的条件：队列不空且新元素更优，队中旧元素队尾出队</li>
<li>每个元素必然从队尾进队一次</li>
<li>队头出队的条件：队头元素滑出了窗口</li>
<li>注意：队列中存储元素的下标，方便判断队头出队</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031258078.png" alt="image-20240327125322278"></p>
<h3><span id="11-维护滑动窗口的最大值x2f最小值">1.1. 维护滑动窗口的最大值&#x2F;最小值</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="comment">// 当队尾t&lt;队头h时,说明单调队列中没有元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 当前队头q[h]不在窗口[i-k+1,i]内,队头出队</span></span><br><span class="line">    <span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-k+<span class="number">1</span>) h++;</span><br><span class="line">    <span class="comment">// 当前值&gt;=队尾值,队尾出队(如果当前值比队头还大,那么会一直出队到队头出队)</span></span><br><span class="line">    <span class="keyword">while</span>(h&lt;=t &amp;&amp; a[i]&gt;=a[q[t]]) t--;</span><br><span class="line">    <span class="comment">// 当前值从队尾入队,注意入队的是下标,一直存储的都是下标</span></span><br><span class="line">    q[++t]=i;</span><br><span class="line">    <span class="comment">// 如果i&gt;=k表明起码占满一个窗口,此时队头中的是最大值</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 &#x2F;【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N]; <span class="comment">// q是队列,建议数组模拟,不开O2优化的情况下数组都比STL库更快</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 维护窗口最小值O(n)</span></span><br><span class="line">	<span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="comment">// 当队尾t&lt;队头h时,说明单调队列中没有元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123; <span class="comment">// 枚举队列中所有元素</span></span><br><span class="line">		<span class="comment">// 新元素比当前队尾还小,说明新元素更优,那么把后面的全部移出去,最小的变进来</span></span><br><span class="line">		<span class="keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&gt;=a[i]) t--;</span><br><span class="line">		q[++t]=i; <span class="comment">// 注意,q存的都是下标嗷,表示把i从队尾入队</span></span><br><span class="line">		<span class="comment">// 当新元素不是最优时,也会直接执行q[++t]=i加到当前窗口的末尾</span></span><br><span class="line">		<span class="keyword">if</span>(q[h]&lt;i-k+<span class="number">1</span>) h++; <span class="comment">// i-k+1是当前窗口的左边界,如果队头下标小于i-k+1,说明窗口右移</span></span><br><span class="line">		<span class="comment">// 此时相当于队头出队</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 能输出第一个窗口的大小时</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 维护最大值的单调队列,q[h]代表队头元素的下标</span></span><br><span class="line">	h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果比队尾更优,则出队</span></span><br><span class="line">		<span class="keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&lt;=a[i]) t--;</span><br><span class="line">		<span class="comment">// 入队</span></span><br><span class="line">		q[++t]=i;</span><br><span class="line">		<span class="comment">// 滑动窗口右移</span></span><br><span class="line">		<span class="keyword">if</span>(q[h]&lt;i-k+<span class="number">1</span>) h++;</span><br><span class="line">		<span class="comment">// 输出当前窗口最大值</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) <span class="built_in">cout</span>&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基于STL</p>
</li>
<li><p>单调队列是相较于队列，队头也可以出队的数据结构，则可以用 $STL$ 库中的 $deque$ 实现【双端队列，可以入队也可以出队】</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 输出最小值,a[i]比队尾元素更优,则弹出对位并加入队列</span></span><br><span class="line">    <span class="comment">// 如果dq不为空且这个新元素更优,则去尾</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.empty() &amp;&amp; a[dq.back()]&gt;a[i]) dq.pop_back(); <span class="comment">// 去尾</span></span><br><span class="line">    dq.push_back(i); <span class="comment">// 1)去尾后将最优元素加入到队列中;2)dq为空,自然将下标入队;3)</span></span><br><span class="line">    <span class="comment">// 如果达到窗口大小</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) &#123;</span><br><span class="line">        <span class="comment">// 如果dq不为空并且队头元素下标小于等于i-k(即滑出窗口了)</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-k) dq.pop_back(); <span class="comment">// 删头</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[dq.front()]); <span class="comment">// 输出队头的元素,此时对应最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 &#x2F;【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<ul>
<li>要 $pop_back()$ 或者 $pop_front()$ 之前可以用 $dq.size()$ 检测一下是否有元素，否则可能导致 $RE$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: RE也可能是数组没开够哦</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 双端队列表示单调队列</span></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 元素个数以及窗口大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找最小值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 输出最小值,a[i]比队尾元素更优,则弹出对位并加入队列</span></span><br><span class="line">		<span class="comment">// 如果dq不为空且这个新元素更优,则去尾</span></span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; a[dq.back()]&gt;a[i] &amp;&amp; dq.size()) dq.pop_back(); <span class="comment">// 去尾</span></span><br><span class="line">		dq.push_back(i); <span class="comment">// 1)去尾后将最优元素加入到队列中;2)dq为空,自然将下标入队;3)</span></span><br><span class="line">		<span class="comment">// 如果达到窗口大小</span></span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) &#123;</span><br><span class="line">			<span class="comment">// 如果dq不为空并且队头元素下标小于等于i-k(即滑出窗口了)</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-k &amp;&amp; dq.size()) dq.pop_front(); <span class="comment">// 删头</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[dq.front()]); <span class="comment">// 输出队头的元素,此时对应最大值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	dq.clear();</span><br><span class="line">	<span class="comment">// 找最大值,如果a[i]比队尾大就入队</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; a[dq.back()]&lt;a[i] &amp;&amp; dq.size()) dq.pop_back();</span><br><span class="line">		dq.push_back(i);</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;=i-k &amp;&amp; dq.size()) dq.pop_front();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[dq.front()]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-维护连续子序列的最大和">1.2. 维护连续子序列的最大和</span></h3><blockquote>
<p>题目链接：</p>
</blockquote>
<ul>
<li><p>基于数组</p>
</li>
<li><p>给定一个长度为n的整数序列，请找出长度不超过 $m$ 的连续子序列的最大和。例如，数组 ${2,\ -3,\ 5,\ 2,\ -4,\ -1,\ 8}$ ，$m$ 取 $3$ ，那么长度不超过 $3$ 的连续子序列的最大和为 $8$</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031258085.png" alt="image-20240327145503331"></p>
<ul>
<li>对于常规做法（左边），每次枚举一个窗口长度，再在这个窗口中枚举得到最大的连续子段和，时间复杂度是 $O(n^3)$，对于右图，表示的是前缀和数组 $s$</li>
<li>对于连续子段和（区间和），我们很容易想到预处理一个前缀和数组，这样就可以把计算连续字段和的时间从 $O(n)$ 优化到 $O(1)$，$i$ 到 $j$ 的间和计算公式是 $s[i]-s[j-1]$，我们只要找到左端点 $s[l-1]$ 的最小值，那么就可以求出 $s[i]-min(s[j]),\ j∈[i-m,i-1]$ 得到前 $i$ 项的最大连续子段和，因为要枚举求得最小值，所以时间复杂度是 $O(n^2)$</li>
<li>但是，如果我们再用单调队列维护这个最小值，就不需要再枚举求连续区间和的最小值，时间复杂度会继续下降到 $O(n)$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">// 单调队列</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和序列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n,k;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k; <span class="comment">// 求的是长度不超过k的最大区间和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> h=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ans=s[<span class="number">1</span>]; <span class="comment">// 初始化区间和的答案</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 队头不在窗口[i-k,i-1]内,队头出队</span></span><br><span class="line">		<span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-k) h++; <span class="comment">// 这里因为只用看前i-k个元素,窗口右边界小了1,因此不用加1</span></span><br><span class="line">		<span class="comment">// 使用队头最小值,同样的因为队尾小了1,所以要把最小值在这里处理</span></span><br><span class="line">		ans=max(ans,s[i]-s[q[h]]);</span><br><span class="line">		<span class="comment">// 当前值&lt;=队尾值,队尾出队,把更小的s[i]放进队列中以维护s[i]的最小值</span></span><br><span class="line">		<span class="keyword">while</span>(h&lt;=t &amp;&amp; s[i]&lt;=s[q[t]]) t--;</span><br><span class="line">		<span class="comment">// 从队尾正常入队</span></span><br><span class="line">		q[++t]=i; <span class="comment">// 放进去的仍然是下标哈</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">7 3</span></span><br><span class="line"><span class="comment">2 -3 5 2 -4 -1 8</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>另一种写法，本人暂时还没验证是否正确，在维护滑动窗口最大值和最小值的基础上只改动了最后一步，即维护 $ans$ 的代码，因为 $s[i]-s[q[h]]$ 中 $s[q[h]]$ 已经前 $i$ 项窗口大小为 $[1,k]$ 的滑动窗口中前缀和的最小值，所以相减即可得到最大区间和</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=s[<span class="number">1</span>];</span><br><span class="line">h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;=t &amp;&amp; s[i]&lt;=s[q[t]]) t--;</span><br><span class="line">    q[++t]=i;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-k) h++;</span><br><span class="line">    ans=max(ans,s[i]-s[q[h]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果窗口大小是从 $[st,en]$（用户手动输入），那么模板可改为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 枚举每个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 对于区间长度在[st,en]之间,当i&gt;=st才计算</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=st) &#123; </span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t &amp;&amp; s[i-st]&lt;=s[q[t]]) t--;</span><br><span class="line">        q[++t]=i-st; <span class="comment">// 偏移量是i-st</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=t &amp;&amp; q[h]&lt;i-en) h++;</span><br><span class="line">   	ans=max(ans,s[i]-s[q[h]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基于STL</p>
</li>
<li><p>关键点，$dq.fonrt()&lt;i-k$ 此时代表窗口大于 $k$ 了，因为窗口大小是 $≤k$ 所以没有设限 $if(i&gt;&#x3D;k)$</p>
</li>
<li><p>对于 $dq.empty()$ 即是最初的状态，即没有任何元素，此时只会添加 $s[1]$ 进去，其他情况会进入 $s[i]-s[dq.front()]$ 表示 $[0,i-1]$ 中的最小值</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=INT_MIN; <span class="comment">// 找最大值</span></span><br><span class="line">dq.push_back(<span class="number">0</span>); </span><br><span class="line"><span class="comment">// 枚举到第i个元素,则从前[0,i-1]中找最小值s[j](前缀和),用s[i]-s[j]即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    <span class="comment">// 因为窗口大小是小于等于k,所以一旦dq.front&lt;i-k代表窗口大小大于k了</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;i-k) dq.pop_front(); <span class="comment">// 删头</span></span><br><span class="line">    <span class="keyword">if</span>(dq.empty()) ans=max(ans,s[i]); <span class="comment">// 对应最初状态,这里只会添加s[1],其他情况下队列起码有一个元素</span></span><br><span class="line">    <span class="keyword">else</span> ans=max(ans,s[i]-s[dq.front()]); <span class="comment">// 此时dq中的是0~s[i-1]中的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.back()&gt;=s[i]) dq.pop_back();</span><br><span class="line">    dq.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 单调队列</span></span><br><span class="line"><span class="type">int</span> n,k; <span class="comment">// 长度不超过k的子序列最大和</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=INT_MIN; <span class="comment">// 找最大值</span></span><br><span class="line">	dq.push_back(<span class="number">0</span>); </span><br><span class="line">	<span class="comment">// 枚举到第i个元素,则从前[0,i-1]中找最小值s[j](前缀和),用s[i]-s[j]即可</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 因为窗口大小是小于等于k,所以一旦dq.front&lt;i-k代表窗口大小大于k了</span></span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front()&lt;i-k) dq.pop_front(); <span class="comment">// 删头</span></span><br><span class="line">		<span class="keyword">if</span>(dq.empty()) ans=max(ans,s[i]); <span class="comment">// 对应最初状态,这里只会添加s[1],其他情况下队列起码有一个元素</span></span><br><span class="line">		<span class="keyword">else</span> ans=max(ans,s[i]-s[dq.front()]); <span class="comment">// 此时dq中的是0~s[i-1]中的最小值</span></span><br><span class="line">		<span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.back()&gt;=s[i]) dq.pop_back();</span><br><span class="line">		dq.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析及常用技巧</title>
    <url>/2024/10/03/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="复杂度分析及常用技巧">复杂度分析及常用技巧</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">1. 时间复杂度</a></li>
<li><a href="#2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2. 空间复杂度</a></li>
<li><a href="#3-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7">3. 常用技巧</a></li>
<li><a href="#4-debug%E6%8A%80%E5%B7%A7">4. Debug技巧</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-时间复杂度">1. 时间复杂度</span></h2><ul>
<li>C++语言1秒钟可以执行的操作次数是 10^7^~10^8^</li>
<li>时间复杂度的常数怎么理解？可以理解为代码的指令行数，如果循环内部指令行数&gt;&#x3D;10条一般认为常数比较大</li>
<li>根据题目给定的范围，反推应该使用什么样时间复杂度的算法：</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031243416.png" alt="image-20240111214332856" style="zoom:80%;">



<h2><span id="2-空间复杂度">2. 空间复杂度</span></h2><ul>
<li>C++中最大空间限制为2147483647，即5e8（对int型），如果数据范围超过5e8就不要用数组</li>
<li>对64MB的存储空间，开一个n×n的int型二维数组，其n最大为8172</li>
</ul>
<h2><span id="3-常用技巧">3. 常用技巧</span></h2><ol>
<li><p>a&#x2F;b向上取整，可以用ceil(a&#x2F;b)，但是这个函数的返回值是double类型的，所以需要强转，即int(ceil(a&#x2F;b))，这样写非常繁琐，不如用 $a+b-1&#x2F;b$ 表示向上取整</p>
</li>
<li><p>类似的技巧还有 a%b 如何把余数限制为正数？只需要 (a%b+b)%b 就可以了，保证模数不变的同时使结果都变为正数</p>
</li>
<li><p>优化输入输出速度，但速度依然不及scanf和printf</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); <span class="comment">// 优化输入输出(取消关联)</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); <span class="comment">// 加快输入</span></span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>); <span class="comment">// 加快输出</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>cin后面不能马上跟getline，因为cin读不了换行符，而换行符是getline的结束符，所以要忽略换行符，用语句，或者getchar()读走这个换行符</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>万能头文件(蓝桥杯也可用，前提是开C++11)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>图论无穷大：0x3f3f3f3f</li>
</ol>
<ul>
<li>在图论中，将距离数组初始化为0x3f3f3f3f是为了表示无穷大。这是因为0x3f3f3f3f的十进制值是1061109567，它是一个很大的数，但又不会溢出。这个值被用来表示无穷大，因为两个0x3f3f3f3f的和只比int类型的最大值小一点，这样在两个无穷相加时能够保证不会溢出，对于long long类型，则用0x3f3f3f3f3f3f3f3f。需要注意的是，用memset函数进行初始化时，只需要memset(dis, 0x3f, sizeof dis)即可，因为memset函数是按照字节来赋值的，所以这条语句默认赋值0x3f3f3f3f</li>
</ul>
<ol start="7">
<li>行数不固定的输入</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b)==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)</span><br></pre></td></tr></table></figure>



<h2><span id="4-debug技巧">4. Debug技巧</span></h2><ol>
<li>Segmentation Fault：段错误，多为数组越界导致的，且不输出任何额外的信息，此时可以借助exit(0)函数：在程序的任何位置直接退出，来排除是哪一步的问题</li>
<li>CE：编译错误，</li>
<li>RE：运行错误，数组越界或爆栈</li>
<li>TLE：时间超限</li>
<li>MLE：内存超限</li>
<li>PE：格式错误</li>
<li>OLE：输出超限，通常为没有删除调试语句</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>前置知识</tag>
      </tags>
  </entry>
  <entry>
    <title>图论最短路</title>
    <url>/2024/10/04/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="图论最短路">图论最短路</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF">1. 单源最短路</a><ul>
<li><a href="#11-%E6%89%80%E6%9C%89%E8%BE%B9%E6%9D%83%E9%83%BD%E6%98%AF%E6%AD%A3%E6%95%B0">1.1. 所有边权都是正数</a><ul>
<li><a href="#111-%E6%9C%B4%E7%B4%A0-dijkstra-%E7%AE%97%E6%B3%95">1.1.1. 朴素 $Dijkstra$ 算法</a></li>
<li><a href="#112-%E5%A0%86%E4%BC%98%E5%8C%96-dijkstra">1.1.2. 堆优化 $Dijkstra$</a></li>
</ul>
</li>
<li><a href="#12-%E5%AD%98%E5%9C%A8%E8%B4%9F%E6%9D%83%E8%BE%B9">1.2. 存在负权边</a><ul>
<li><a href="#121-bellman-ford">1.2.1. Bellman-Ford</a></li>
<li><a href="#122-spfa">1.2.2. SPFA</a></li>
<li><a href="#123-spfa%E5%88%A4%E8%B4%9F%E7%8E%AF">1.2.3. SPFA判负环</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%A4%9A%E6%BA%90%E6%B1%87%E6%9C%80%E7%9F%AD%E8%B7%AF">2. 多源汇最短路</a><ul>
<li><a href="#21-floyd%E7%AE%97%E6%B3%95">2.1. Floyd算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-单源最短路">1. 单源最短路</span></h2><blockquote>
<p>从一个点到其他所有点的最短距离</p>
</blockquote>
<ul>
<li>对于单源最短路径问题的时间复杂度和空间复杂度如下，对于空间复杂度需强调：对于稀疏图（边较少），倾向于使用<strong>邻接表</strong>和<strong>链式前向星</strong>，如果使用邻接矩阵容易爆内存；对于稠密图（边多），倾向于使用邻接矩阵，因为邻接表每个元素都是一个结点，占用的内存可能比邻接矩阵中的一格大，使用邻接矩阵反而内存占用更少。</li>
<li>注意，无向图是一种特殊的有向图，所以我们背板子的时候不用特别区分有向图和无向图。</li>
<li>对于<strong>稠密图</strong>（边的数量接近于顶点数量的平方），使用邻接矩阵的时间复杂度通常更低，因为你可以在 $O(1)$ 的时间内访问任何边。然而，邻接矩阵的空间复杂度是 $O(V^2)$ ，这可能会导致内存超限。</li>
<li>对于<strong>稀疏图</strong>（边的数量远小于顶点数量的平方），使用邻接表的时间复杂度通常更低，因为你只需要遍历与每个顶点相连的边。邻接表的空间复杂度是 $O(E)$ ，这通常比邻接矩阵更节省空间。</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20231018161346568.png" alt="image-20231018161346568" style="zoom:67%;">



<h3><span id="11-所有边权都是正数">1.1. 所有边权都是正数</span></h3><h4><span id="111-朴素-dijkstra-算法">1.1.1. 朴素 $Dijkstra$ 算法</span></h4><blockquote>
<p>时间复杂度 $O(n²)$：$n$ 表示点的数量，和边数无关，适合稠密图，空间复杂度 $O(n^2)$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素dijkstra</span></span><br><span class="line"><span class="comment">// 1:初始化距离,dist[1]=0,dist[v]=+inf,s是当前已经确定最短距离的点</span></span><br><span class="line"><span class="comment">// 2:for v in [1,n]:①不在s中的距离最近的点;②t→s;③用t更新其他点的距离</span></span><br><span class="line"><span class="comment">// 3:循环n次后,已经求出每个点到第一个点的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稠密图→邻接矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span><span class="number">+5</span>; </span><br><span class="line"><span class="comment">// 点最大是500*500=2.5*10^5&gt;题目给的m最大值</span></span><br><span class="line"><span class="comment">// 注意:存在重边和自环</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 每个点到第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 每个点的访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先把距离初始化为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 第一个点到自身的距离为0</span></span><br><span class="line">	<span class="comment">// 对于每一个结点,我们每遍历一次就把一个点加入到已经找到最短路径的队列中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="number">-1</span>; <span class="comment">// 初始化t为-1,t用于记录当前未被访问的结点中距离源节点最近的结点</span></span><br><span class="line">		<span class="comment">// 遍历所有结点,找到每个结点距离自己最近且尚未加入&quot;已经找到最短路径&quot;点集的结点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="comment">// !st[j]:结点j未被访问,t为-1,或者t到源节点的距离小于j到源节点的距离</span></span><br><span class="line">			<span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">				t=j;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果当前结点的最近结点就是n,那么直接跳出(优化意义不明显)</span></span><br><span class="line">		<span class="keyword">if</span>(t==n)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		st[t]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 以t为跳板,更新所有结点到源节点的最短距离</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不存在最短路返回-1,存在则返回最大距离值</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 初始化邻接矩阵为互不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=<span class="built_in">min</span>(g[a][b],c); <span class="comment">// 去除重边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="112-堆优化-dijkstra">1.1.2. 堆优化 $Dijkstra$</span></h4><blockquote>
<p>时间复杂度 $O(mlogn)$：$n$ 表示点的数量、$m$ 表示边的数量，适合稀疏图，空间复杂度 $O(m+n)$</p>
</blockquote>
<ul>
<li>该代码可以解决带有重边和自环的有向图、无向图。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// h:每个结点的第一条边</span></span><br><span class="line"><span class="comment">// e:每条边的下一个结点</span></span><br><span class="line"><span class="comment">// ne:每条边的下一条边</span></span><br><span class="line"><span class="comment">// w:每条边的权重</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 邻接表存储最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第idx条边指向节点b,第idx边边权为c,第idx条的下一条边是a的起始边(头插法思想),起始边更新为当前边编号,编号自增</span></span><br><span class="line">	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化互不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 编号为1的点到自己距离为0</span></span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; <span class="comment">// 小根堆</span></span><br><span class="line">	heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;); <span class="comment">// 距离为0,点编号为1(第一关键字存储距离,小根堆默认从小到大排序;第二关键字存储编号)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 队列不为空</span></span><br><span class="line">	<span class="keyword">while</span>(heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// 取出头结点</span></span><br><span class="line">		<span class="keyword">auto</span> t=heap.<span class="built_in">top</span>();</span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// v:取出头结点的编号</span></span><br><span class="line">		<span class="comment">// distance:到源节点的距离</span></span><br><span class="line">		<span class="type">int</span> v=t.second;</span><br><span class="line">		<span class="comment">// 如果已访问过,则跳过</span></span><br><span class="line">		<span class="keyword">if</span>(st[v])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		st[v]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 遍历该结点的所有边,-1是尾边(因为用的是头插法)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[v];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果距离更短,则更新</span></span><br><span class="line">			<span class="keyword">if</span>(dist[j]&gt;dist[v]+w[i]) &#123;</span><br><span class="line">				dist[j]=dist[v]+w[i];</span><br><span class="line">				<span class="comment">// 节点j的距离和编号加入队列</span></span><br><span class="line">				heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果不可达,返回-1</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n]; <span class="comment">// 否则范围到节点n的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="comment">// add(b,a,c); // 无向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-存在负权边">1.2. 存在负权边</span></h3><ul>
<li><p>$SPFA$ 一般比贝尔曼福特快，如果想求不超过 $k$ 条边的最短路，只能用贝尔曼福特算法来做。需要注意一点，如果存在负权回路，那么最短路是不一定存在的，贝尔曼福特算法可以求出是否存在负权回路，<strong>如果存在负权回路，贝尔曼福特可能求不出最短路径</strong></p>
</li>
<li><p>需要注意的是：$SPFA$ 的使用条件是，<strong>一定不存在负环，SPFA本质上是对Bellman-Ford的优化，也可以用于找负环</strong></p>
</li>
<li><p>$80%$ 的正权图也能用 $SPFA$ 来做，且时间效率会比 $dijkstra$ 更快，但是如果 $SPFA$ 被卡了，$SPFA$ 的平均时间复杂度是$O(m)$，最坏的情况是$O(nm)$，数据给的差是可能达到最坏情况的，如果被卡了，就换成堆优化的 $dijkstra$</p>
</li>
</ul>
<h4><span id="121-bellman-ford">1.2.1. Bellman-Ford</span></h4><blockquote>
<p>时间复杂度 $O(nm)$，题目链接：<a href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bellman-Ford算法,注意该算法存边随便存,只要能遍历所有边即可</span></span><br><span class="line"><span class="comment">// for循环n次,每一次循环所有边a,b,w,更新最短距离(三角不等式)</span></span><br><span class="line"><span class="comment">// 迭代k次后,dist数组代表的含义:从1号点经过,不超过k条边走到每个点的最短距离</span></span><br><span class="line"><span class="comment">// 如果第n次迭代后dist数组有更新的话,说明一定存在负环,SPFA也可以找负环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SPFA一般在任何情况都优于Bellman-fort</span></span><br><span class="line"><span class="comment">// 但是如果有边数限制,如AcWing853,最多经过不超过k条边的最短路径,必须用Bellman-fort</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k; <span class="comment">// 点/边/最短路边限制</span></span><br><span class="line"><span class="type">int</span> dist[N],backup[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;	</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 结点1到自身距离为0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 走k步路</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="comment">// 把dist写进backup</span></span><br><span class="line">		<span class="comment">// 每次复制上一次的状态,因为要求在k步路内的最短距离,所以不能直接更新</span></span><br><span class="line">		<span class="built_in">memcpy</span>(backup,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			<span class="type">int</span> a=edges[j].a,b=edges[j].b,w=edges[j].w;</span><br><span class="line">			dist[b]=<span class="built_in">min</span>(dist[b],backup[a]+w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为什么这里不是0x3f3f3f3f呢?</span></span><br><span class="line">	<span class="comment">// 因为如果两个点对于点1都是不可达,但相互可达,则可能在更新时变成不是0x3f3f3f3f的数</span></span><br><span class="line">	<span class="comment">// 所以这里用一个类似于极大值的数来替代</span></span><br><span class="line">	<span class="comment">// 如果没有最短路径,返回0x3f3f3f3f,不返回-1是因为有可能最短距离就是-1</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,w;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">		edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">bellman_ford</span>();</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="122-spfa">1.2.2. SPFA</span></h4><blockquote>
<p>时间复杂度 一般 $O(m)$，最坏 $O(nm)$，以下模板无视重边和自环，题目链接：<a href="https://www.acwing.com/problem/content/853/">851. spfa求最短路 - AcWing题库</a></p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPFA:长得特别像dijkstra,对于负权图,如果出题人卡SPFA的话就没办法了</span></span><br><span class="line"><span class="comment">// 只要队列不为空</span></span><br><span class="line"><span class="comment">// 弹出队头t,更新t的所有出边</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化dist为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 第一个点的距离为0</span></span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// 弹出队头</span></span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">// 更新状态</span></span><br><span class="line">		st[t]=<span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// 遍历每条边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果距离更短则更新</span></span><br><span class="line">			<span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">				dist[j]=dist[t]+w[i];</span><br><span class="line">				<span class="comment">// 如果没访问过则加入队列</span></span><br><span class="line">				<span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(j);</span><br><span class="line">					st[j]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不可达不要返回-1,因为有可能最短路径就是-1</span></span><br><span class="line">	<span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="123-spfa判负环">1.2.3. SPFA判负环</span></h4><blockquote>
<p>题目链接：<a href="https://www.acwing.com/problem/content/854/">852. spfa判断负环 - AcWing题库</a></p>
</blockquote>
<ul>
<li>维护一个 $cnt$ 数组，从 $[1,x]$，$cnt$ 数组记录的是在用 $SPFA$ 找$1$号点 到 $n$号点最短路径时，这个最短路中边的个数，如果 $dist[j]&gt;dist[v]+w[i]$ 说明我从 $v$ 这个点到 $j$ 的距离更短，那么从 $i$ → $j$ 就更新为 $i$ → $v$ → $j$，所以边数要 $+1$ ，即有 $cnt[j]&#x3D;cnt[v]+1$ ，如果在某一次中 $cnt[x]&gt;&#x3D;n$ 了，说明一共经历了 $n$ 条边，有$n$ 条边就有 $n+1$ 个点，但是题目中只有 $n$ 个点，说明有一个点出现了两次，即出现了环，又因为 $dist$ 是在不断减小的，所以这一定是一个负环</li>
<li>还需要注意一点，一开始我们不能直接把 $1$ 号点放进队列来找，因为题目要找的是整个图中是否存在负环，而从 $1$ 号点出发不一定能到这个负环，所以做法是把所有点都放进队列中，那么一定能找到这个负环</li>
<li>注意 $SPFA$ 判负环时间复杂度其实还蛮高的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// 判断有无负环,cnt[i]:表示遍历到第i个节点时已遍历过的节点总数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">// 注意这里不能把1放进去,因为1可能到不了这个负环</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	q.push(1);</span></span><br><span class="line">    <span class="comment">// 把每个点都放进去判断</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		st[i]=<span class="literal">true</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		st[t]=<span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">				dist[j]=dist[t]+w[i];</span><br><span class="line">				cnt[j]=cnt[t]<span class="number">+1</span>; <span class="comment">// 遍历到节点j时遇到的节点总数+1</span></span><br><span class="line">				<span class="keyword">if</span>(cnt[j]&gt;=n) </span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 有负环</span></span><br><span class="line">				<span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(j);</span><br><span class="line">					st[j]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;	</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-多源汇最短路">2. 多源汇最短路</span></h2><blockquote>
<p>求多个起点到其他点的距离</p>
</blockquote>
<h3><span id="21-floyd算法">2.1. Floyd算法</span></h3><blockquote>
<p>时间复杂度O(n³)，dp的外表，暴力的心，题目链接：<a href="https://www.acwing.com/problem/content/856/">854. Floyd求最短路 - AcWing题库</a>，以下模板能处理重边、自环、负权边，但不能处理负权回路，因为存在负权回路时距离会不断往下越来越小，无法收敛</p>
</blockquote>
<ul>
<li>注意之所以用 $d[a][b]&gt;INF&#x2F;2$ 来判断是否是不可达是因为题目中存在负权边更新后的距离很有可能比 $INF$ 小一些，要在其他负权边存在的最短路问题中也注意一下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弗洛伊德:多源最短路,直接暴力暴暴暴就完事了</span></span><br><span class="line"><span class="comment">// 第一层循环,k从1~n,枚举i→j的中间节点</span></span><br><span class="line"><span class="comment">// 第二层循环,i从1~n</span></span><br><span class="line"><span class="comment">// 第三层循环,j从1~n</span></span><br><span class="line"><span class="comment">// d[i,j]=min(d[i][j],d[i][k]+d[k][j])</span></span><br><span class="line"><span class="comment">// 原理:d[k,i,j]=d[k-1,i,k]+d[k-1,k,j],基于dp</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,Q; <span class="comment">// Q是循环次数</span></span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">				d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q; </span><br><span class="line">	<span class="comment">// 重边和自环的处理方法:</span></span><br><span class="line">	<span class="comment">// 重边:保留最小的边</span></span><br><span class="line">	<span class="comment">// 自环:删除</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)</span><br><span class="line">				d[i][j]=<span class="number">0</span>; <span class="comment">// 自己到自己的距离为0,赋初值,后比较,去自环</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				d[i][j]=INF; <span class="comment">// 初始化邻接矩阵为互不可达</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		d[a][b]=<span class="built_in">min</span>(d[a][b],c); <span class="comment">// 去重边,保留最小边(邻接矩阵的做法)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">floyd</span>();</span><br><span class="line">	<span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(d[a][b]&gt;INF/<span class="number">2</span>) <span class="comment">// 可能会被更新得不是INF</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;d[a][b]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串哈希</title>
    <url>/2024/10/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="字符串哈希">字符串哈希</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li>
<li><a href="#2-%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC">2. 求字符串哈希值</a></li>
<li><a href="#3-%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC">3. 求字符串字串的哈希值</a></li>
<li><a href="#4-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%90%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C">4. 判断两个子串是否相同</a></li>
<li><a href="#5-%E4%BE%8B%E9%A2%98%E6%B4%9B%E8%B0%B7-p3370">5. 【例题】洛谷 P3370</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.788&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F02 字符串哈希 bilibili</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>字符串哈希即把不同的字符串映射成不同的整数</li>
</ul>
<ol>
<li><p>把字符串映射成一个 $p$ 进制数字，对于一个长度为 $n$ 的字符串 $s$</p>
<ul>
<li>定义其 $Hash$ 函数为：$ h(s)&#x3D;\sum_{i&#x3D;1}^n s[i]×p^{i-1}(mod M)$</li>
<li>如：字符串 $abc$ ，哈希函数值为 $ap^2+bp^1+c&#x3D;97×131^2+98×131^1+99$</li>
</ul>
</li>
<li><p>如果两个字符串不一样但 $Hash$ 函数值一样，这样的现象被称作哈希碰撞</p>
</li>
<li><p>解决哈希碰撞的方法（极大程度减少哈希碰撞次数，但还是有可能碰撞）</p>
<ul>
<li>巧妙设置 $p$ 和 $M$ 的值，保证 $p$ 和 $M$ 互质</li>
<li>$p$ 通常为：$131$ 或 $13331$</li>
<li>$M$ 通常取大整数 $2^{64}$，把哈希函数值 $h$ 定义为 $ULL$，对于无符号数，超过则自动溢出，等价于取模了</li>
</ul>
</li>
</ol>
<h2><span id="1-数据结构">1. 数据结构</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 最大字符串的个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1.5e3</span><span class="number">+10</span>; <span class="comment">// 题目中字符串的最大长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>; <span class="comment">// 131,13331不容易哈希碰撞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p[i]:表示p的i次方</span></span><br><span class="line"><span class="comment">// h[i]:表示s[1~i]的哈希值,如h[2]表示字符串s前两个字符组成字符串的哈希值</span></span><br><span class="line">ULL p[N],h[N];</span><br><span class="line"><span class="type">char</span> s[M]; <span class="comment">// 存储字符串</span></span><br><span class="line"><span class="type">int</span> n;</span><br></pre></td></tr></table></figure>



<h2><span id="2-求字符串哈希值">2. 求字符串哈希值</span></h2><ul>
<li>求一个字符串的哈希值相当于求前缀和</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240312215219122.png" alt="image-20240312215219122"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理hash函数的前缀和,时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// p^0=1,空串哈希值为0</span></span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>,h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		p[i]=p[i<span class="number">-1</span>]*P;	</span><br><span class="line">		h[i]=h[i<span class="number">-1</span>]*P+s[i]; <span class="comment">// 前缀和计算公式</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-求字符串字串的哈希值">3. 求字符串字串的哈希值</span></h2><ul>
<li>求字符串字串的哈希值相当于求区间和</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240312220823283.png" alt="image-20240312220823283"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算s[l~r](子串)的hash值,时间复杂度O(1)</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>]; <span class="comment">// 区间和计算字串的hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-判断两个子串是否相同">4. 判断两个子串是否相同</span></h2><ul>
<li>直接计算这两个子串的哈希值即可，若相等说明子串相同，反之亦然</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断两个子串是否相同</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">substr</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l2,<span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-例题洛谷-p3370">5. 【例题】洛谷 P3370</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希 - 洛谷</a></p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240312221054653.png" alt="image-20240312221054653"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 字符串数量上界</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1.5e3</span><span class="number">+10</span>; <span class="comment">// 单个字符串最大长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>; <span class="comment">// 131,13331不容易哈希碰撞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h[i]:表示s[1~i]的哈希值,如h[2]表示字符串s前两个字符组成字符串的哈希值</span></span><br><span class="line">ULL h[N]; </span><br><span class="line"><span class="type">char</span> str[M]; <span class="comment">// 存储字符串</span></span><br><span class="line">set&lt;ULL&gt; s; <span class="comment">// 存储每个字符串的哈希值,集合自动去重</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串s的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">Hash</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">	h[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">// 空串哈希值为0</span></span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">strlen</span>(str<span class="number">+1</span>); <span class="comment">// 计算长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++) &#123;</span><br><span class="line">		h[i]=h[i<span class="number">-1</span>]*P+str[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h[len]; <span class="comment">// 返回此串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%str&quot;</span>,str<span class="number">+1</span>); <span class="comment">// 从下标1开始存</span></span><br><span class="line">		s.<span class="built_in">insert</span>(<span class="built_in">Hash</span>(str)); <span class="comment">// 存储答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2024/10/05/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="字典树">字典树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1. 数据结构</a></li>
<li><a href="#2-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">2. 插入操作</a></li>
<li><a href="#3-%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C">3. 查询操作</a></li>
<li><a href="#4-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">4. 完整代码</a><ul>
<li><a href="#41-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">4.1. 字符数组</a></li>
<li><a href="#42-%E5%AD%97%E7%AC%A6%E4%B8%B2">4.2. 字符串</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1yA4y1Z74t/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">F06 字典树(Trie)</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>是快速插入和查询字符串的多叉树结构，根节点编号为0，其余节点标识路径，还可以标记单词插入的次数，边表示字符。</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240303203511065.png" alt="image-20240303203511065" style="zoom:80%;">



<h2><span id="1-数据结构">1. 数据结构</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="comment">// 每次输入的字符串,N是每个单词的最大长度</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>]; <span class="comment">// ch[p][j]:从节点p沿着j这条边走到的子节点,边为26个小写字母映射值为0~25</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[p]:以节点p结尾的单词的插入次数</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 遍历因子</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-插入操作">2. 插入操作</span></h2><ul>
<li>insert函数，插入单个单词并建立字典树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s:单词(字符串)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 根节点编号为0</span></span><br><span class="line">	<span class="comment">// 枚举字符串每个字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到0~25</span></span><br><span class="line">		<span class="comment">// 如果这个字符不是儿子节点,创建儿子,p指针再走到儿子</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 节点编号+1</span></span><br><span class="line">		<span class="comment">// 如果这个字符是儿子节点,p指针走到儿子节点</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词插入的次数+1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240303235131060.png" alt="image-20240303235131060"></p>
<h2><span id="3-查询操作">3. 查询操作</span></h2><ul>
<li>query函数，得到一个单词被插入的次数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某个单词出现的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始查</span></span><br><span class="line">	<span class="comment">// 扫描字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 转换为映射值</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果找不到返回0</span></span><br><span class="line">		<span class="comment">// 有字母s[i],则走下来</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果能走到词尾,则返回插入次数</span></span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-完整代码">4. 完整代码</span></h2><h3><span id="41-字符数组">4.1. 字符数组</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 节点表示数字,边表示字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">char</span> s[N]; <span class="comment">// 每次输入的字符串,N是每个单词的最大长度</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>]; <span class="comment">// ch[p][j]:从节点p沿着j这条边走到的子节点,边为26个小写字母映射值为0~25</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[p]:以节点p结尾的单词的插入次数</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 遍历因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s:单词(字符串)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始插</span></span><br><span class="line">	<span class="comment">// 枚举字符串每个字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// a~z映射到0~25</span></span><br><span class="line">		<span class="comment">// 如果这个字符不是儿子节点,创建儿子,p指针再走到儿子</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 节点编号+1</span></span><br><span class="line">		<span class="comment">// 如果这个字符是儿子节点,p指针走到儿子节点</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词插入的次数+1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询某个单词出现的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始查</span></span><br><span class="line">	<span class="comment">// 扫描字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 转换为映射值</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果找不到返回0</span></span><br><span class="line">		<span class="comment">// 有字母s[i],则走下来</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果能走到词尾,则返回插入次数</span></span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,&amp;op,s);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(s);</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="42-字符串">4.2. 字符串</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 节点表示数字,边表示字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件总长度不超过32K,所以总字符不超过:32K=32*1024</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">32</span>*<span class="number">1024</span><span class="number">+10</span>; </span><br><span class="line"><span class="type">char</span> s[N]; <span class="comment">// 每次输入的字符串,N是每个单词的最大长度</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>]; <span class="comment">// ch[p][j]:从节点p沿着j这条边走到的子节点,边为26个小写字母映射值为0~25</span></span><br><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[p]:以节点p结尾的单词的插入次数</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 遍历因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s:单词(字符串)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始插</span></span><br><span class="line">	<span class="comment">// 枚举字符串每个字符</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;A&#x27;</span>; <span class="comment">// a~z映射到0~25</span></span><br><span class="line">		<span class="comment">// 如果这个字符不是儿子节点,创建儿子,p指针再走到儿子</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx; <span class="comment">// 节点编号+1</span></span><br><span class="line">		<span class="comment">// 如果这个字符是儿子节点,p指针走到儿子节点</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++; <span class="comment">// 以节点p结尾的单词插入的次数+1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询某个单词出现的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>; <span class="comment">// 从根节点开始查</span></span><br><span class="line">	<span class="comment">// 扫描字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">// 转换为映射值</span></span><br><span class="line">		<span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果找不到返回0</span></span><br><span class="line">		<span class="comment">// 有字母s[i],则走下来</span></span><br><span class="line">		p=ch[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果能走到词尾,则返回插入次数</span></span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	while(scanf(&quot;%s&quot;,s)) &#123;</span></span><br><span class="line"><span class="comment">//		insert(s);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;s) &#123;</span><br><span class="line">		<span class="built_in">insert</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;idx<span class="number">+1</span>; <span class="comment">// 加上根节点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/10/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="并查集">并查集</span></h1><p>[toc]</p>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>并查集是用于处理不相交集合的合并与查询的树形数据结构</li>
</ul>
<h2><span id="1-数据结构">1. 数据结构</span></h2><ul>
<li>准备一个数组用于存储所有点的连通分量（父节点）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br></pre></td></tr></table></figure>



<h2><span id="2-核心函数">2. 核心函数</span></h2><h3><span id="21-find函数">2.1. find函数</span></h3><ul>
<li>用于查询某个元素的父节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找元素所在集合的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根节点</span></span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">//	return find(fa[x]); // 递归查找父节点的父节点</span></span><br><span class="line">	<span class="comment">// 带路径压缩的查找(有效降低递归的时间复杂度)</span></span><br><span class="line">	<span class="comment">// 在返回的路上,顺带修改各节点的父节点为根</span></span><br><span class="line">	<span class="comment">// 这句代码的意思是:fa[x]=find(fa[x]),return fa[x]</span></span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031254549.png" alt="image-20240410144829099"></p>
<ul>
<li>带路径压缩的查找和普通查找的区别仅仅在于在递归的过程中把每个子节点的父节点更新为根</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031253600.png" alt="image-20240410144851687"></p>
<h3><span id="22-join函数">2.2. join函数</span></h3><ul>
<li>用于连接两个并查集</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// b的根作为a的根</span></span><br><span class="line">    fa[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">// b的父节点作为a原本的父节点的父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-模板">3. 模板</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷</a></p>
</blockquote>
<ul>
<li>1）初始化时将每个节点的父节点初始化为自己</li>
<li>2）如果 $a$ 和 $b$ 的根相同，则表明二者处于同一并查集中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+4</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn]; <span class="comment">// 记录每个节点的父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) </span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">// 路径压缩</span></span><br><span class="line">		<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	fa[<span class="built_in">find</span>(l)]=<span class="built_in">find</span>(r); <span class="comment">// x的父节点的父节点变为y的父节点(合并)</span></span><br><span class="line">    <span class="comment">// 即把l的集合的根节点的父亲设置为r集合的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> op,l,r; <span class="comment">// op是操作,l和r是合并或判断关系的两个并查集</span></span><br><span class="line">	<span class="comment">// 1. 初始化每个结点的父节点都是自己</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		fa[i]=i;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">join</span>(l,r);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(l)==<span class="built_in">find</span>(r)) <span class="comment">// 在同一并查集中</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;Y\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;N\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-维护信息的并查集">4. 维护信息的并查集</span></h2><h3><span id="41-维护各集合中元素总数">4.1. 维护各集合中元素总数</span></h3><ul>
<li>只需要在合并时进行计算即可，将子集合中的元素个数加等到父集合的元素个数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt[N]; <span class="comment">// cnt[i]:以i为根节点的集合的元素个数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护集合总数的合并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> x=find(a);</span><br><span class="line">	<span class="type">int</span> y=find(b);</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	fa[x]=y; <span class="comment">// a所在集合根节点作为b所在集合根节点的儿子节点</span></span><br><span class="line">	<span class="comment">// 如果遇到重复的语句,那么此时x==y成立,所以不再重复计数</span></span><br><span class="line">	cnt[y]+=cnt[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="42-维护总集合个数">4.2. 维护总集合个数</span></h3><ul>
<li>有多少个集合即是看有多少个节点的 $x&#x3D;&#x3D;fa[x]$ 即有多少个根节点，无需维护，$O(n)$ 遍历一遍即可</li>
</ul>
<h2><span id="5-完备并查集">5. 完备并查集</span></h2><ul>
<li>非常好用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完备并查集</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">	<span class="comment">// fa:每个结点的父结点</span></span><br><span class="line">	<span class="comment">// p:每个集合的结点数量</span></span><br><span class="line">	<span class="comment">// e:每个集合边的数量</span></span><br><span class="line">	<span class="comment">// f:记录集合中是否存在自环</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; fa,p,e,f; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化一个并查集</span></span><br><span class="line">	DSU(<span class="type">int</span> n) &#123;</span><br><span class="line">		<span class="comment">// 大小为n+1,下标从0~n,我们可以从1开始使用</span></span><br><span class="line">		</span><br><span class="line">		fa.resize(n+<span class="number">1</span>); <span class="comment">// 大小调整为n+1 </span></span><br><span class="line">		<span class="comment">// fa从起始位置到结束位置,从0开始递增赋值,即父结点为自己</span></span><br><span class="line">		<span class="comment">// 即fa[0]=0,fa[1]=1,...,fa[n]=n</span></span><br><span class="line">		iota(fa.begin(),fa.end(),<span class="number">0</span>); </span><br><span class="line">		p.resize(n+<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// 每个结点单独成为一个集合,大小为1</span></span><br><span class="line">		e.resize(n+<span class="number">1</span>); <span class="comment">// 初始时每个集合没有边</span></span><br><span class="line">		f.resize(n+<span class="number">1</span>); <span class="comment">// 初始时没有自环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找x所在集合的根节点</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="comment">// 找x的根节点,并作路径压缩</span></span><br><span class="line">		<span class="keyword">while</span>(x!=fa[x]) &#123;</span><br><span class="line">			x=fa[x]=fa[fa[x]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 假设x所在集合为A,假设y所在集合为B,合并A和B</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="comment">// 设x是y的祖先</span></span><br><span class="line">		<span class="keyword">if</span>(x==y) f[get(x)]=<span class="number">1</span>; <span class="comment">// 如果自己和自己合并,则存在自环</span></span><br><span class="line">		x=get(x),y=get(y);</span><br><span class="line">		e[x]++; <span class="comment">// 集合A边数+1</span></span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;y) swap(x,y); <span class="comment">// 指定将编号小的合并到编号大的上</span></span><br><span class="line">		fa[y]=x; <span class="comment">// 集合B父结点变为x</span></span><br><span class="line">		<span class="comment">// 若B有自环,则合并后A有自环,或运算是一起看,有1则1</span></span><br><span class="line">		<span class="comment">// A加上B中边的数量和结点数量</span></span><br><span class="line">		f[x]|=f[y],p[x]+=p[y],e[x]+=e[y];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断x和y是否在同一集合中</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> get(x)==get(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断x所在集合是否存在自环</span></span><br><span class="line">	<span class="type">bool</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> f[get(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出集合中点的数量</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">size</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> p[get(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出集合中边的数量</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">E</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e[get(x)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 用完备并查集解板子题</span></span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	DSU <span class="title function_">dsu</span><span class="params">(n)</span>; <span class="comment">// 创建并查集</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> op,a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			dsu.merge(a,b); <span class="comment">// 合并a,b所在集合</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="keyword">if</span>(dsu.same(a,b)) &#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;N&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2024/10/03/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="差分">差分</span></h1><p>[toc]</p>
<blockquote>
<p>复习一下前缀和吧：<a href="https://blog.csdn.net/qq_63586399/article/details/136780044?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22136780044%22,%22source%22:%22qq_63586399%22%7D">【C++算法模板】预处理算法：一维前缀和、二维前缀和总结，详解带例题-CSDN博客</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>差分的推导也比较简单，因此本博客重点在于知识点归纳而不在于证明</li>
</ul>
<h2><span id="1-一维差分">1. 一维差分</span></h2><ul>
<li>给定一个一维序列，定义它的差分序列 $b$ 为，计算差分序列的时间复杂度为 $O(n)$<ul>
<li>$b[1]&#x3D;a[1]\ (i&#x3D;1)$</li>
<li>$b[i]&#x3D;a[i]-a[i-1]\ (2&lt;&#x3D;i&lt;&#x3D;n)$</li>
</ul>
</li>
<li>为原序列 $[l,r]$ 区间分别加上 $c$ 等价于：$b[l]+&#x3D;c,\ b[r+1]-&#x3D;c$，对差分序列 $b$ 做一维前缀和得到操作后的原序列，时间复杂度 $O(1)$</li>
</ul>
<blockquote>
<p>【例题】AcWing 797，链接：<a href="https://www.acwing.com/problem/content/799/">797. 差分 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N]; <span class="comment">// a:原序列,b:差分序列</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 对b求前缀和</span></span><br><span class="line"><span class="type">int</span> l,r,c;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入规模超过1e5,推荐使用scanf</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);	</span><br><span class="line">		b[i]=a[i]-a[i<span class="number">-1</span>]; <span class="comment">// 前缀和和差分下标都从1开始,否则容易有边界问题</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">		b[l]+=c;</span><br><span class="line">		b[r+<span class="number">1</span>]-=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用新数组s计算差分序列b的前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+b[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用累加的思想,在差分序列本身上做前缀和,节省空间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-二维差分">2. 二维差分</span></h2><ul>
<li>在一维差分中我们对差分序列 $b$ 求前缀和可以得到原序列 $a$，由此可以看出差分是前缀和的逆运算</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031227790.png" alt="image-20240317085114587"></p>
<ul>
<li>则我们可由二维前缀和计算公式轻松推导出二维差分序列的计算公式，时间复杂度 $O(n^2)$<ul>
<li>二维前缀和的计算公式 $s[i][j]&#x3D;\sum_{i&#x3D;1}^i\sum_{j&#x3D;1}^ja[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$</li>
<li>将 $a[i]$ 单独移至等号一边，对 $s$ 合并同类项，得到 $a[i][j]&#x3D;s[i][j]-s[i-1][j]-s[i][j-1]+s[i-1][j-1]$</li>
<li>由于 $b$ 的前缀和是 $a$，所以将 $a$ 替换成 $b$，将 $s$ 替换成 $a$，得到二位差分计算公式</li>
<li>$b[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$，其物理含义是：在下标 $[i][j]$ 位置上的差分等于原序列 $[i][j]$ 上的元素减去上边 $[i-1][j]$ 和左边 $[i][j-1]$ 上的元素并加上左上角 $[i-1][j-1]$ 的元素</li>
</ul>
</li>
<li>对原序列 $a$ 区间 $(x_1,y_1)$ 到 $(x_2,y_2)$ 之间的元素加上 $c$，等价于其差分序列 $b$ 的点 $(x_1,y_1)$ 加 $c$，点 $(x_1,y_{2}+1)$ 减 $c$，点 $(x_2+1,y1)$ 减 $c$，点 $(x_2+1,y_2+1)$ 加 $c$，时间复杂度 $O(1)$，最后对差分序列 $b$ 求二维前缀和即可得到操作过后的原序列</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/202410031227796.png"></p>
<blockquote>
<p>【例题】AcWing 798，链接：<a href="https://www.acwing.com/problem/content/800/">798. 差分矩阵 - AcWing题库</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 逐行差分和逐行求和的思路</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,k; <span class="comment">// n:矩阵行数,m:矩阵列数,k:操作次数</span></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> b[N][N]; <span class="comment">// 差分矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N][N]; <span class="comment">// 对b求二维前缀和得到操作后的原序列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">			b[i][j]=a[i][j]-a[i<span class="number">-1</span>][j]-a[i][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">// 差分是前缀和的逆运算</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出差分数组看一看</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;输出差分数组:&gt;\n&quot;;</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++,puts(&quot;&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=m;j++) &#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;b[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">	<span class="keyword">while</span>(k--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">		b[x1][y1]+=c;</span><br><span class="line">		b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">		b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">		b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 求前缀和保存到s里面</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i][j];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 直接在b本身上进行前缀和得到操作后的a</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;b[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>预处理</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索</title>
    <url>/2024/10/04/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="广度优先搜索">广度优先搜索</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%9F%BA%E4%BA%8E%E9%82%BB%E6%8E%A5%E8%A1%A8">1. 基于邻接表</a></li>
<li><a href="#2-%E5%9F%BA%E4%BA%8E%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F">2. 基于链式前向星</a></li>
<li><a href="#3-%E5%9F%BA%E4%BA%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9B%BE">3. 基于二维数组（地图）</a><ul>
<li><a href="#31-%E5%8D%95%E6%BA%90bfs">3.1. 单源BFS</a><ul>
<li><a href="#311-%E8%B1%A1%E6%A3%8B%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86">3.1.1. 象棋马的遍历</a></li>
<li><a href="#312-%E8%BF%B7%E5%AE%AB%E6%9C%80%E7%9F%AD%E8%B7%AF">3.1.2. 迷宫最短路</a></li>
<li><a href="#313-%E6%8A%93%E4%BD%8F%E9%82%A3%E5%A4%B4%E7%89%9B">3.1.3. 抓住那头牛</a></li>
</ul>
</li>
<li><a href="#32-%E5%A4%9A%E6%BA%90bfs">3.2. 多源BFS</a><ul>
<li><a href="#321-%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5">3.2.1. 距离矩阵</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>广搜是基于队列实现的从根开始向下逐层扩展逐层访问的搜索遍历方法</li>
</ul>
<h2><span id="1-基于邻接表">1. 基于邻接表</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240510202644636.png" alt="image-20240510202644636"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// e[1]:结点1的相邻结点</span></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">// vis[1]:结点1的访问状态,true:访问过了,false:未访问</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">// 假设结点1是根节点</span></span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d 出队\n&quot;</span>,x);</span><br><span class="line">		<span class="comment">// 扩展其儿子结点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y:e[x]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>; <span class="comment">// 避免反复入队</span></span><br><span class="line">			vis[y]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d 入队\n&quot;</span>,y);</span><br><span class="line">			q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 每个结点扩展的边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">// n个结点,.条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b; <span class="comment">// 父在前</span></span><br><span class="line">		<span class="comment">// 无向图双向建边</span></span><br><span class="line">		e[a].push_back(b);</span><br><span class="line">		e[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2><span id="2-基于链式前向星">2. 基于链式前向星</span></h2><ul>
<li>注意，因为链式前向星是头插，所以入队和出队顺序和基于邻接表（尾插）不太一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大结点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span>+<span class="number">5</span>)*<span class="number">2</span>; <span class="comment">// 最大边数(无向图)</span></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:结点i的起始边编号</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:第i条边到达的结点</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:第i条边的下一条边的编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建边因子</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">// 每个结点的访问状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a];</span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 每个结点扩展的边数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 维护序列的队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d 出队\n&quot;</span>,x);</span><br><span class="line">		<span class="comment">// 遍历连接x的所有边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i]; <span class="comment">// 取出第i条边所达结点</span></span><br><span class="line">			<span class="keyword">if</span>(vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[j]=<span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d 入队\n&quot;</span>,j);</span><br><span class="line">			q.push(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">// n个结点,.条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b; <span class="comment">// 父在前</span></span><br><span class="line">		<span class="comment">// 无向图双向建边</span></span><br><span class="line">		add(a,b);</span><br><span class="line">		add(b,a);</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意,因为是头插,所以入队和出队顺序和基于邻接表不太一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 8</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2><span id="3-基于二维数组地图">3. 基于二维数组（地图）</span></h2><h3><span id="31-单源bfs">3.1. 单源BFS</span></h3><h4><span id="311-象棋马的遍历">3.1.1. 象棋马的遍历</span></h4><blockquote>
<p>题目描述：在象棋棋盘中，马从 $(0,0)$ 跳到 $(fx,fy)$【自行输入】，已知马只能向右跳，求到达终点所需最少步长并输出其路径</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 只能向右走,说明在列方向上的变化只能是正值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 初始化为-1,也把dist当作st数组用</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 存储最短路径</span></span><br><span class="line"><span class="type">int</span> fx,fy; <span class="comment">// 终点是(fx,fy),行是m,列是n</span></span><br><span class="line"><span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">// 放的是坐标</span></span><br><span class="line"></span><br><span class="line">PII pre[N][N]; <span class="comment">// 记录路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只调用一次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	dist[x][y]=<span class="number">0</span>;</span><br><span class="line">	q.push(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="comment">// 取出队头</span></span><br><span class="line">		PII t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="comment">// 一定不会往回走</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> xx=t.x+dx[i];</span><br><span class="line">			<span class="type">int</span> yy=t.y+dy[i];</span><br><span class="line">			<span class="comment">// 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(xx&lt;<span class="number">0</span> || yy&lt;<span class="number">0</span> || xx&gt;fx || yy&gt;fy) <span class="keyword">continue</span>;</span><br><span class="line">			q.push(<span class="built_in">make_pair</span>(xx,yy));</span><br><span class="line">			dist[xx][yy]=dist[t.x][t.y]+<span class="number">1</span>;</span><br><span class="line">			pre[xx][yy]=<span class="built_in">make_pair</span>(t.x,t.y); <span class="comment">// [xx,yy]的前驱是[t.x,t.y]</span></span><br><span class="line">			<span class="comment">// 找到终点了</span></span><br><span class="line">			<span class="keyword">if</span>(xx==fx &amp;&amp; yy==fy) &#123;</span><br><span class="line">				<span class="keyword">return</span> dist[xx][yy];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 找不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;fx&gt;&gt;fy;</span><br><span class="line">	<span class="type">int</span> sx=<span class="number">0</span>,sy=<span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs(sx,sy);</span><br><span class="line">	<span class="type">int</span> x=fx,y=fy; <span class="comment">// 回溯路径</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;PII&gt; v; <span class="comment">// 记录正向路径</span></span><br><span class="line">	<span class="keyword">while</span>(x!=sx || y!=sy) &#123; </span><br><span class="line">		v.push_back(<span class="built_in">make_pair</span>(x,y));</span><br><span class="line">		PII prev=pre[x][y];</span><br><span class="line">		x=prev.x;</span><br><span class="line">		y=prev.y;</span><br><span class="line">	&#125;</span><br><span class="line">	v.push_back(<span class="built_in">make_pair</span>(sx, sy)); <span class="comment">// 添加起点到路径中 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=v.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123; <span class="comment">// 输出路径要倒序输出</span></span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="312-迷宫最短路">3.1.2. 迷宫最短路</span></h4><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1NU4y1R7fd/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B12 BFS 迷宫 最短路_bilibili</a><br>题目描述：$n$ 行 $n$ 列的二维地图中，$1$ 表示墙壁，$0$ 表示可走的路，只能朝上下左右四个方向走，求最短路径长度并输出这条路径</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 偏移量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 地图,01存储,兼状态数组</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// dist[i][j]:(i,j)到起点(1,1)的距离</span></span><br><span class="line"><span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">// 维护序列的队列</span></span><br><span class="line">PII pre[N][N]; <span class="comment">// pre[i][j]:(i,j)的上一步的坐标(记录最短路)</span></span><br><span class="line"><span class="type">int</span> fx,fy; <span class="comment">// 终点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	dist[x][y]=<span class="number">0</span>;</span><br><span class="line">	q.push(&#123;x,y&#125;); <span class="comment">// 左上角初始加入队列</span></span><br><span class="line">	g[x][y]=<span class="number">1</span>; <span class="comment">// 渲染成墙壁,表示走过了</span></span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		PII t=q.front(); <span class="comment">// 取出队头</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> xx=t.x+dx[i];</span><br><span class="line">			<span class="type">int</span> yy=t.y+dy[i];</span><br><span class="line">			<span class="comment">// 约束条件</span></span><br><span class="line">			<span class="comment">// 1) 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(xx&lt;<span class="number">1</span> || xx&gt;n || yy&lt;<span class="number">1</span> || yy&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 2) 必须为可走&amp;&amp;必须没走过</span></span><br><span class="line">			<span class="keyword">if</span>(g[xx][yy]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 占据方案</span></span><br><span class="line">			g[xx][yy]=<span class="number">1</span>;</span><br><span class="line">			dist[xx][yy]=dist[t.x][t.y]+<span class="number">1</span>; <span class="comment">// 步长+1</span></span><br><span class="line">			pre[xx][yy]=&#123;t.x,t.y&#125;; <span class="comment">// 记录上一步</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;t.x&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;t.y&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;xx&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;yy&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">if</span>(xx==fx &amp;&amp; yy==fy) <span class="keyword">return</span> dist[xx][yy];</span><br><span class="line">			q.push(&#123;xx,yy&#125;);</span><br><span class="line">			<span class="comment">// 如果找到终点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 找不到最短路</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fx=n,fy=n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;bfs(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 从(1,1)广搜</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dist[n][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;PII&gt; path; <span class="comment">// 存储路径</span></span><br><span class="line">	<span class="comment">// 一直回溯到起点</span></span><br><span class="line">	<span class="keyword">while</span>(fx!=<span class="number">1</span> || fy!=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)的上一个位置是(%d,%d)\n&quot;</span>,fx,fy,pre[fx][fy].first,pre[fx][fy].second);</span><br><span class="line">		path.push_back(&#123;fx,fy&#125;);</span><br><span class="line">		PII prev=pre[fx][fy];</span><br><span class="line">		fx=prev.x;</span><br><span class="line">		fy=prev.y;</span><br><span class="line">	&#125;</span><br><span class="line">	path.push_back(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	reverse(path.begin(),path.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i!=path.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)-&gt;&quot;</span>,path[i].first,path[i].second);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,path[i].first,path[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0 1 0 0 0</span></span><br><span class="line"><span class="comment">0 1 0 1 0</span></span><br><span class="line"><span class="comment">0 0 0 0 0 </span></span><br><span class="line"><span class="comment">0 1 1 1 0</span></span><br><span class="line"><span class="comment">0 0 0 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4><span id="313-抓住那头牛">3.1.3. 抓住那头牛</span></h4><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1KM4y1e7v1/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B15 BFS 抓住那头牛_bilibili</a><br>题目描述：人和牛在同一直线上，初始位置分别为 $x$ 和 $y$，牛不动，人每次可以前进 $1$ 步、后退 $1$ 步或者直接走到 $2×x$ 的位置，计算追上牛的最小步数</p>
</blockquote>
<ul>
<li>对于起点先加入队列，随后每次取出队头分别处理前进一步、后退一步以及 $×2$ 后的步数，因为是逐层扩展，所以第一次遍历到的时候所用到的步数一定是最小的</li>
<li>同时我们约束其上下界，下界为 $0$ ，因为题目要求 $x,y&gt;&#x3D;0$ ，上界为题目给的数据范围 $1e5$，因为 $x×2,\ x-1,\ x-1$ 不如 $x-1,x×2$ 更优，所以可以约束其上界</li>
<li>本题还需要学习的一点在于用 $dist$ 数组进行剪枝，限制第一次来到这一步才对值进行更新，根据 $BFS$ 逐层扩展的原理，这样求出来的本身也是最小值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> x,y,dist[N]; <span class="comment">// dist[i]:走到i所需要的最少步数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">-1</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[x]=<span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">	q.push(x); </span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// 下面三种情况的约束条件:都是没走过(因为逐层扩展,所以第一次遇到一定最小)并且不越界</span></span><br><span class="line">		<span class="comment">// 下面的三个if是并列关系,相当于一个结点会扩展3次,前进一步/后退一步和×2</span></span><br><span class="line">		<span class="comment">// 其实dist数组的作用相当于剪枝了,因为每个结点只能被扩展一次</span></span><br><span class="line">		<span class="comment">// 易证明,x*2再-1-1,不如x-1,x*2更优,故有上界x&lt;=10^5</span></span><br><span class="line">		<span class="keyword">if</span>(x+<span class="number">1</span>&lt;N &amp;&amp; dist[x+<span class="number">1</span>]==<span class="number">-1</span>) &#123;</span><br><span class="line">			dist[x+<span class="number">1</span>]=dist[x]+<span class="number">1</span>; <span class="comment">// 前进一步</span></span><br><span class="line">			q.push(x+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 坐标范围本身(x,y)都&gt;0</span></span><br><span class="line">		<span class="keyword">if</span>(x<span class="number">-1</span>&gt;<span class="number">0</span> &amp;&amp; dist[x<span class="number">-1</span>]==<span class="number">-1</span>) &#123;</span><br><span class="line">			dist[x<span class="number">-1</span>]=dist[x]+<span class="number">1</span>; <span class="comment">// 后退一步</span></span><br><span class="line">			q.push(x<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2</span>*x&lt;N &amp;&amp; dist[<span class="number">2</span>*x]==<span class="number">-1</span>) &#123;</span><br><span class="line">			dist[<span class="number">2</span>*x]=dist[x]+<span class="number">1</span>; <span class="comment">// 走到2*x的位置</span></span><br><span class="line">			q.push(<span class="number">2</span>*x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果走到终点</span></span><br><span class="line">		<span class="keyword">if</span>(x==y) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dist[y]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">5 17</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3><span id="32-多源bfs">3.2. 多源BFS</span></h3><h4><span id="321-距离矩阵">3.2.1. 距离矩阵</span></h4><blockquote>
<p>推荐学习视频：<a href="https://www.bilibili.com/video/BV1GB4y1Q7bR/?spm_id_from=333.999.0.0&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B13 多源BFS 矩阵距离_bilibili</a><br>题目描述：即是说求图中每一个 $0$ 距离自己最近的 $1$ 的曼哈顿距离，从而构成一个新的矩阵 $B$</p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240512154726043.png" alt="image-20240512154726043"></p>
<ul>
<li>为了求每个 $0$ 距离自己最近的 $1$ 的曼哈顿距离，如果计算遍历到每个 $0$ 时分别去寻找距离自己最近的 $1$ 并打擂取得最小值，时间复杂度很会高</li>
<li>所以可以从每个 $1$ 做洪水覆盖，即多源 $BFS$，先来到这个点的距离一定是最短的，因为 $BFS$ 是逐层扩展</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 地图</span></span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 存储到源点的距离,兼职判重</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n行m列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">// 多源,把每个1都放入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">-1</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 均初始化为不可达</span></span><br><span class="line">	<span class="comment">// 遍历地图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="comment">// 多源BFS,区别就是把多个源点都加入队列</span></span><br><span class="line">			<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				dist[i][j]=<span class="number">0</span>; <span class="comment">// 到自己的距离为0</span></span><br><span class="line">				q.push(&#123;i,j&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> xx=t.x+dx[i];</span><br><span class="line">			<span class="type">int</span> yy=t.y+dy[i];</span><br><span class="line">			<span class="comment">// 1) 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(xx&lt;<span class="number">1</span> || xx&gt;n || yy&lt;<span class="number">1</span> || yy&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 2) 走过则跳过</span></span><br><span class="line">			<span class="keyword">if</span>(dist[xx][yy]!=<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dist[xx][yy]=dist[t.x][t.y]+<span class="number">1</span>; <span class="comment">// 洪泛计算距离</span></span><br><span class="line">			q.push(&#123;xx,yy&#125;);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入地图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;g[i][j];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++,<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;dist[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">0 0 0 1</span></span><br><span class="line"><span class="comment">0 0 1 1</span></span><br><span class="line"><span class="comment">0 1 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂</title>
    <url>/2024/10/07/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="快速幂">快速幂</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E5%BA%94%E7%94%A8%E4%B8%80-%E5%B9%82%E5%8F%96%E4%BD%99%E8%AE%A1%E7%AE%97-anmod-m">1. 应用一、幂取余：计算 $a^n(mod\ m)$</a></li>
<li><a href="#2-%E5%BA%94%E7%94%A8%E4%BA%8C-%E8%AE%A1%E7%AE%97%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">2. 应用二、计算斐波那契数列的第n项【矩阵快速幂】</a></li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E4%B8%89-%E5%B0%86%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E9%87%8D%E5%A4%8D-n-%E6%AC%A1%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82">3. 应用三、将线性变换重复 $n$ 次【矩阵快速幂】</a></li>
<li><a href="#4-%E5%BA%94%E7%94%A8%E5%9B%9B-%E6%9E%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E9%BE%9F%E9%80%9F%E4%B9%98">4. 应用四、极斐波那契【矩阵快速幂+龟速乘】</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726135336870.png" alt="image-20230726135336870" style="zoom:67%;">

<ul>
<li>关键在于把a的n次方中的n拆分成二进制的表示形式</li>
</ul>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726135625768.png" alt="image-20230726135625768" style="zoom: 80%;">

<ul>
<li><p>对于 $n$ 的二进制，我们从低到高不断遍历每一位，如果遍历到的那一位是 $1$ ，就 $r×a$</p>
</li>
<li><p>伪代码中的 $n(mod\ 2)$ 可以用 $n&amp;1$ 来表示，$n&#x3D;floor(n&#x2F;2)$ 也可以用无符号右移一位来表示，即 $n&gt;&gt;2$</p>
</li>
</ul>
<h2><span id="1-应用一-幂取余计算-anmod-m">1. 应用一、幂取余：计算 $a^n(mod\ m)$</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726140139764.png" alt="image-20230726140139764" style="zoom:67%;">

<ul>
<li>只需要在快速幂算法中合适的位置上加上 $mod\ m$，即可得到幂取模的代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算a的n次方模m</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ModExpFast</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	a=a%m;</span><br><span class="line">	res=<span class="number">1</span>; <span class="comment">// 乘法操作的初始值(累积变量)</span></span><br><span class="line">	<span class="keyword">while</span>(n!=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">			res=(res*a)%m;</span><br><span class="line">		&#125;</span><br><span class="line">		a=(a*a)%m;</span><br><span class="line">		n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res; <span class="comment">// 得到最终的余数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a,n,m;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot;^&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; mod &quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">ModExpFast</span>(a,n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>幂取模运算在密码学和数论中有着非常重要的应用，比如，幂取模运算是RSA公钥加密的核心运算之一。</li>
</ul>
<h2><span id="2-应用二-计算斐波那契数列的第n项矩阵快速幂">2. 应用二、计算斐波那契数列的第n项【矩阵快速幂】</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726142215151.png" alt="image-20230726142215151" style="zoom:67%;">

<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240207111727658.png" alt="image-20240207111727658" style="zoom:80%;">

<ul>
<li><p>以上是适用于矩阵快速幂的数据范围</p>
</li>
<li><p>只需要计算出 $[1\ 1; 1\ 0]$ 的 $n$次方和已知 $F0$ 与 $F1$，就可以计算出第 $n$ 项</p>
</li>
<li><p>以下是一个利用矩阵快速幂计算第 $n$ 项并维护前 $n$ 项和的矩阵快速幂模板</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 矩阵快速幂求斐波那契数列,[fn, fn+1] × [0 1; 1 1]= f[n+1, fn+2]</span></span><br><span class="line"><span class="comment">// 这道题还要求斐波那契数列前n项的和,所以除了fn以外还需要维护Sn</span></span><br><span class="line"><span class="comment">// [fn, fn+1, sn] × [0 1 0; 1 1 0; 0 1 1] = f[n+1, fn+2, sn+1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3</span>; <span class="comment">// 矩阵3×3</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 本题要求计算出前n项和mod m的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维×二维两重循环,c=a*b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[],<span class="type">int</span> a[],<span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">			temp[i]=(temp[i]+(ll)a[j]*b[j][i])%m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意:传进来的指针和本身的指针有区别(形参),如果这里sizeof c</span></span><br><span class="line">	<span class="comment">// 传回来的是指针的长度,而不是数组的长度,所以sizeof temp</span></span><br><span class="line">	<span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维×二维三重循环,c=a*b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N],<span class="type">int</span> a[][N],<span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;N;k++) &#123;</span><br><span class="line">				temp[i][j]=(temp[i][j]+(ll)a[i][k]*b[k][j])%m;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(c,temp,<span class="keyword">sizeof</span> temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> f1[N]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">// f1,f2,s1;存储答案,f1[2]就是Sn</span></span><br><span class="line">	<span class="comment">// 推导出来的幂矩阵</span></span><br><span class="line">	<span class="type">int</span> a[N][N]= &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 计算f1×a^n</span></span><br><span class="line">	<span class="comment">// 迭代计算,类似于滚动数组,没有利用额外的空间</span></span><br><span class="line">	n--; <span class="comment">// 调整斐波那契数列的起始位置</span></span><br><span class="line">	<span class="comment">// 快速幂思想</span></span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="built_in">mul</span>(f1,f1,a); <span class="comment">// res=res*a,调用一维矩阵×二维矩阵的mul方程</span></span><br><span class="line">		<span class="built_in">mul</span>(a,a,a); <span class="comment">// a=a*a,调用二维矩阵×二维矩阵的mul方程</span></span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f1[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-应用三-将线性变换重复-n-次矩阵快速幂">3. 应用三、将线性变换重复 $n$ 次【矩阵快速幂】</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230726142534642.png" alt="image-20230726142534642" style="zoom:67%;">



<h2><span id="4-应用四-极斐波那契矩阵快速幂龟速乘">4. 应用四、极斐波那契【矩阵快速幂+龟速乘】</span></h2><ul>
<li>对我来说有难度，暂时不上代码</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2024/10/04/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="拓扑排序">拓扑排序</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-kahn%E7%AE%97%E6%B3%95">1. Kahn算法</a><ul>
<li><a href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.1. 数据结构</a></li>
<li><a href="#12-%E5%BB%BA%E5%9B%BE">1.2. 建图</a></li>
<li><a href="#13-kanh%E7%AE%97%E6%B3%95">1.3. Kanh算法</a></li>
</ul>
</li>
<li><a href="#2-dfs%E6%9F%93%E8%89%B2">2. DFS染色</a><ul>
<li><a href="#21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.1. 数据结构</a></li>
<li><a href="#22-%E5%BB%BA%E5%9B%BE">2.2. 建图</a></li>
<li><a href="#23-dfs">2.3. DFS</a></li>
</ul>
</li>
<li><a href="#3-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94">3. 算法对比</a></li>
<li><a href="#4-%E4%BE%8B%E9%A2%98%E6%B4%9B%E8%B0%B7-b3644">4. 【例题】洛谷 B3644</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>推荐视频链接：<a href="https://www.bilibili.com/video/BV17g41197sa/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">D01 拓扑排序</a></p>
</blockquote>
<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>给定一张<strong>有向无环图</strong>，排出所有顶点的一个序列 $A$ 满足：对于图中的每条有向边 $(x,y)$，$x$ 在 $A$ 中都出现在 $y$ 之前，则称 $A$ 是该图的顶点的一个拓扑序</p>
</li>
<li><p>拓扑排序 可以判断有向图中是否有环，可以生成拓扑序列</p>
</li>
<li><p>对于下图，${2,3,5,1,7,4,6}$ 和 ${3,2,1,5,7,6,4}$ 都是合法的拓扑序</p>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240315173326430.png" alt="image-20240315173326430"></p>
<blockquote>
<p>复习一下链式前向星吧：<a href="https://blog.csdn.net/qq_63586399/article/details/136579751?spm=1001.2014.3001.5502">【C++算法模板】图的存储-邻接表，手撕链式前向星，超详细代码注释-CSDN博客</a></p>
</blockquote>
<h2><span id="1-kahn算法">1. Kahn算法</span></h2><ul>
<li>算法核心：用队列维护一个入度为 $0$ 的节点的集合</li>
</ul>
<ol>
<li>初始化（链式前向星建图建边），队列 $q$ 压入所有入度为 $0$ 的点</li>
<li>每次从 $q$ 中取出队头 $x$ 放入数组 $tp$ ，$tp$ 数组保存出队顺序，也就是拓扑序</li>
<li>然后将 $x$ 的所有出边删除，如删除边 $(x,y)$ ，$y$ 的入度则 $-1$，如果 $y$ 的入度变为 $0$，则将 $y$ 压入 $q$ 中，其中每个顶点的入度用数组 $d$ 维护</li>
<li>不断重复 $2,3$ 过程，直到队列 $q$ 为空</li>
<li>若 $tp$ 中的元素个数等于 $n$，则有拓扑序；否则，有环</li>
</ol>
<h3><span id="11-数据结构">1.1. 数据结构</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>; <span class="comment">// 题目中最大边数,拓扑排序是有向图建边,无需×2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的入度</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 维护入度为0的顶点的队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 记录q中顶点的出队顺序(拓扑序)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 存储每个顶点起始边的编号,默认-1表示无边相连</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:编号为i的边可达的顶点编号</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:编号为i的边的下一条边的编号是ne[i]</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号,建边因子</span></span><br></pre></td></tr></table></figure>



<h3><span id="12-建图">1.2. 建图</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 头插法思想</span></span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="13-kanh算法">1.3. Kanh算法</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑序存储于tp队列中,如果能形成拓扑序返回true</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">tuopu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果入度为0则加入队列</span></span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">0</span>) q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		tp.push(x); <span class="comment">// 出队顺序即拓扑序</span></span><br><span class="line">		<span class="comment">// 遍历x的所有出边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果去掉边(i,j)后j的入度变为0,则加入队列</span></span><br><span class="line">			<span class="keyword">if</span>(--d[j]==<span class="number">0</span>) q.push(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tp.size()==n; <span class="comment">// 如果能形成一个拓扑序,返回true,否则false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-dfs染色">2. DFS染色</span></h2><ul>
<li>算法核心：在于<strong>染色法</strong>，每次 $dfs$ 搜索会给点变色，如果有拓扑序，每个点的颜色都会从 $0→-1→1$ 经历三次变色</li>
</ul>
<ol>
<li>初始化：将所有点染色为 $0$</li>
<li>枚举每个点，进入点 $x$，将 $x$ 染色为 $-1$，随后枚举 $x$ 的所有儿子结点 $y$，如果 $y$ 的颜色仍为 $0$，说明该点未被遍历过，则递归到下一层；如果 $y$ 的颜色为 $-1$，说明遍历到祖先节点了，即出现了环，则直接 $return$</li>
<li>如果枚举完 $x$ 的所有儿子节点都没有发现环，则把 $x$ 染色为 $1$，并把 $x$ 压入 $tp$ 数组</li>
<li>注意，因为 $DFS$ 是栈实现的，回溯的时候才把点加入 $tp$ 数组，所以需要将 $tp$ 数组逆序才能得到拓扑序</li>
</ol>
<h3><span id="21-数据结构">2.1. 数据结构</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>; <span class="comment">// 题目中最大边数,拓扑排序是有向图建边,无需×2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">// 存储每个结点的颜色</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 存储拓扑序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 存储每个顶点起始边的编号,默认-1表示无边相连</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:编号为i的边可达的顶点编号</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:编号为i的边的下一条边的编号是ne[i]</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号,建边因子</span></span><br></pre></td></tr></table></figure>



<h3><span id="22-建图">2.2. 建图</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 头插法思想</span></span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-dfs">2.3. DFS</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	c[x]=<span class="number">-1</span>; <span class="comment">// 先染色为-1</span></span><br><span class="line">	<span class="comment">// 遍历所有儿子节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i]; <span class="comment">// 取出节点编号</span></span><br><span class="line">		<span class="keyword">if</span>(c[j]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遍历到祖先节点,有环,直接return</span></span><br><span class="line">		<span class="comment">// 如果没有遍历过</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!c[j])</span><br><span class="line">			<span class="comment">// 继续往下搜,自然结束return 0</span></span><br><span class="line">			<span class="keyword">if</span>(!dfs(j))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	c[x]=<span class="number">1</span>; <span class="comment">// 如果能够正常走掉dfs流程,则染色为1</span></span><br><span class="line">	tp.push(x); <span class="comment">// 进入拓扑序数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">toposort</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 用vector存储便于反转</span></span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c); <span class="comment">// 染色初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果c没有被走过</span></span><br><span class="line">		<span class="keyword">if</span>(!c[i])</span><br><span class="line">			<span class="comment">// 如果遇到环则说明无法形成拓扑序</span></span><br><span class="line">			<span class="keyword">if</span>(!dfs(i))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(tp.begin(),tp.end());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-算法对比">3. 算法对比</span></h2><ul>
<li>在实际使用拓扑排序时只需要掌握 $Kahn$ 即可，因为更好理解，$DFS$ 染色和二分图中的匈牙利算法的思想比较类似，这里只用了解即可<ul>
<li>$Kahn$：队列维护，顺着拓扑序收集点</li>
<li>$DFS$：系统栈维护，逆着拓扑序收集点</li>
</ul>
</li>
<li>二者时间复杂度都为 $O(E+V)$，其中 $E$ 为边数，$V$ 为点数</li>
</ul>
<h2><span id="4-例题洛谷-b3644">4. 【例题】洛谷 B3644</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/B3644">B3644 【模板】拓扑排序 &#x2F; 家谱树 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>; <span class="comment">// 题目中最大边数,拓扑排序是有向图建边,无需×2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的入度</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q; <span class="comment">// 维护入度为0的顶点的队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; tp; <span class="comment">// 记录q中顶点的出队顺序(拓扑序)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// 存储每个顶点起始边的编号,默认-1表示无边相连</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[i]:编号为i的边可达的顶点编号</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[i]:编号为i的边的下一条边的编号是ne[i]</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号,建边因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	e[idx]=b;</span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 头插法思想</span></span><br><span class="line">	h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑序存储于tp队列中,如果能形成拓扑序返回true</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tuopu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果入度为0则加入队列</span></span><br><span class="line">		<span class="keyword">if</span>(d[i]==<span class="number">0</span>) </span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 直接输出拓扑序</span></span><br><span class="line">		tp.push(x); <span class="comment">// 出队顺序即拓扑序</span></span><br><span class="line">		<span class="comment">// 遍历x的所有出边</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果去掉边(i,j)后j的入度变为0,则加入队列</span></span><br><span class="line">			<span class="keyword">if</span>(--d[j]==<span class="number">0</span>) q.push(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 链式前向星邻接表初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> j;</span><br><span class="line">		<span class="comment">// 当j==0时退出循环</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;j &amp;&amp; j) &#123;</span><br><span class="line">			add(i,j);</span><br><span class="line">			d[j]++; <span class="comment">// 节点j的入度++</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tuopu();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5边,接下来第i行表示节点i的后代,0表示输入完毕</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">4 5 1 0</span></span><br><span class="line"><span class="comment">1 0</span></span><br><span class="line"><span class="comment">5 3 0</span></span><br><span class="line"><span class="comment">3 0</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">2 4 5 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2024/10/02/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="排序">排序</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">1. 快速排序</a></li>
<li><a href="#2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">2. 归并排序</a></li>
<li><a href="#3-%E6%A1%B6%E6%8E%92%E5%BA%8F">3. 桶排序</a></li>
<li><a href="#4-%E5%A0%86%E6%8E%92%E5%BA%8F">4. 堆排序</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-快速排序">1. 快速排序</span></h2><blockquote>
<p>时间复杂度：$O(nlog^n)$，最坏 $O(n^2)$ ，不稳定</p>
</blockquote>
<ul>
<li>基于分治法实现：</li>
</ul>
<ol>
<li>确定分界点</li>
<li>调整区间</li>
<li>递归处理左右两段</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序模板</span></span><br><span class="line"><span class="comment">// l:左端点</span></span><br><span class="line"><span class="comment">// r:右端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 无符号右移一位等于除2</span></span><br><span class="line">	<span class="type">int</span> x=arr[l+r&gt;&gt;<span class="number">1</span>]; <span class="comment">// 找中间值</span></span><br><span class="line">	<span class="comment">// 遍历因子</span></span><br><span class="line">	<span class="type">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> j=r<span class="number">+1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">        <span class="comment">// 把下面两个while中的&quot;&lt;&quot;和&quot;&gt;&quot;换一下就是从大到小排序</span></span><br><span class="line">		<span class="keyword">while</span>(arr[++i]&lt;x);</span><br><span class="line">		<span class="keyword">while</span>(arr[--j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)</span><br><span class="line">			<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分治法</span></span><br><span class="line">	<span class="built_in">quick_sort</span>(arr,l,j); <span class="comment">// 排序左侧</span></span><br><span class="line">	<span class="built_in">quick_sort</span>(arr,j<span class="number">+1</span>,r); <span class="comment">// 排序右侧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-归并排序">2. 归并排序</span></h2><blockquote>
<p>时间复杂度妥妥的：$O(nlog^2)$，稳定</p>
</blockquote>
<ul>
<li>基于分治法实现：</li>
</ul>
<ol>
<li>确定分界点</li>
<li>递归把数据分成两段</li>
<li>合二为一</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序模板</span></span><br><span class="line"><span class="comment">// arr[]:待排序数组</span></span><br><span class="line"><span class="comment">// l:排序左区间</span></span><br><span class="line"><span class="comment">// r:排序右区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 传入数据有误</span></span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 递归将数据分成两段,回来时排序</span></span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,l,mid);</span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">// 回来时的操作</span></span><br><span class="line">	<span class="comment">// k:temp数组的遍历因子/</span></span><br><span class="line">	<span class="comment">// i:第一段的最左端</span></span><br><span class="line">	<span class="comment">// j:第二段的最左端</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 从小到大排序</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">			temp[k++]=arr[i++]; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[k++]=arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把未排好的直接添加到temp末尾,下面两种情况二选一</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++]=arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">		temp[k++]=arr[j++];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此时l和r是形参传递过来的l和r</span></span><br><span class="line">	<span class="comment">// j:temp的遍历因子,目的是赋值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) &#123;</span><br><span class="line">		arr[i]=temp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷</a></p>
</blockquote>
<ul>
<li>该题为利用归并排序求解逆序对的问题，携带了如何输出逆序对，但是没有解决以字典顺序输出逆序对的问题，可能要用其他算法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> arr[maxn];</span><br><span class="line"><span class="type">int</span> temp[maxn]; <span class="comment">// 辅助数组</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res; <span class="comment">// n=5e5,最大对数可能超过1e10*2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 先分</span></span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,l,mid);</span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="comment">// 合并</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])</span><br><span class="line">			temp[k++]=arr[i++];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 输出逆序对</span></span><br><span class="line"><span class="comment">//			for(int m=i;m&lt;=mid;m++) &#123;</span></span><br><span class="line"><span class="comment">//				cout&lt;&lt;&quot;&lt;&quot;&lt;&lt;arr[m]&lt;&lt;&quot;,&quot;&lt;&lt;arr[j]&lt;&lt;&quot;&gt;&quot;&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			temp[k++]=arr[j++];</span><br><span class="line">			<span class="comment">// 如果arr[i]比arr[j]大了,那么arr[i]右边的也比它大</span></span><br><span class="line">			res+=(mid-i<span class="number">+1</span>); <span class="comment">// 一共mid-i+1个</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		temp[k++]=arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">		temp[k++]=arr[j++];</span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) &#123;</span><br><span class="line">		arr[i]=temp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="comment">// test</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">merge_sort</span>(arr,<span class="number">1</span>,n);</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;arr[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-桶排序">3. 桶排序</span></h2><blockquote>
<p>时间复杂度：$O(n+k)$，$n$ 是输入数据量，$k$ 是桶的个数；空间复杂度：$O(k)$，额外分配的内存就是 $k$ 个桶的空间</p>
</blockquote>
<ol>
<li>装桶</li>
<li>倒桶</li>
</ol>
<ul>
<li>注意：桶排序容易超出最大值（字典思想），通常每个值都特别限定的范围时用桶排序，如每个值都限定在 $[0,50]$ 之间。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NUM=<span class="number">1e8</span>; <span class="comment">// 最大值不能超过1e8</span></span><br><span class="line"><span class="type">int</span> sum[MAX_NUM]; <span class="comment">// 值域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 字典装桶</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		sum[arr[i]]++; <span class="comment">// 把数组的值装进桶</span></span><br><span class="line">	<span class="comment">// 倒出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 当sum[i]&gt;=1时才进入while</span></span><br><span class="line">		<span class="keyword">while</span>(sum[i]--)</span><br><span class="line">			arr[j++]=i; <span class="comment">// 下标即是值,对arr重新赋值排序后的结果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>桶排序完整案例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+4</span>; <span class="comment">// 数字最大1e4个</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxv=<span class="number">1e4</span><span class="number">+4</span>; <span class="comment">// 每个数字的值最大1e4</span></span><br><span class="line"><span class="type">int</span> arr[maxv]; <span class="comment">// 桶</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">// 字典装桶</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		arr[temp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从大到小倒桶</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=maxv;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="comment">// 该字符打印arr[i]次,如果j=0则不进入</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr[i];j++) <span class="comment">// 注意这层循环的遍历次数由i来决定,所以这两层循环的时间复杂度都取决于i</span></span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-堆排序">4. 堆排序</span></h2><blockquote>
<p>时间复杂度：$O(nlog^n)$</p>
</blockquote>
<ul>
<li>堆（完全二叉树）：有大根堆和小根堆之分。</li>
</ul>
<ol>
<li>求堆最小值：$q[1]$</li>
<li>删除最小值：$q[1]&#x3D;q[size]$，$down(1)$</li>
<li>输出堆顶，删除堆顶，长度减一，$down(1)$</li>
</ol>
<ul>
<li>注：$down$ 是调整堆的操作，即与自己的孩子比较，将自己的值与其中最小且比自身更小的值交换。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序模板</span></span><br><span class="line"><span class="comment">// sz:当前堆大小</span></span><br><span class="line"><span class="comment">// t:当前堆</span></span><br><span class="line"><span class="type">int</span> sz; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t=u; </span><br><span class="line">	<span class="comment">// 如果左孩子在范围内且值更小</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">2</span>*u&lt;=sz &amp;&amp; arr4[t]&gt;arr4[<span class="number">2</span>*u])</span><br><span class="line">		t=<span class="number">2</span>*u;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">2</span>*u<span class="number">+1</span>&lt;=sz &amp;&amp; arr4[t]&gt;arr4[<span class="number">2</span>*u<span class="number">+1</span>])</span><br><span class="line">		t=<span class="number">2</span>*u<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">if</span>(t!=u) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr4[t],arr4[u]);</span><br><span class="line">		<span class="built_in">down</span>(t); <span class="comment">// 递归调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数部分：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试堆排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    cin&gt;&gt;arr4[i];</span><br><span class="line">&#125;</span><br><span class="line">sz=n; <span class="comment">// 初始堆大小</span></span><br><span class="line"><span class="comment">// 建立小根堆</span></span><br><span class="line"><span class="comment">// n/2是最后一个有孩子的节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i;i--)</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br><span class="line"><span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    cout&lt;&lt;arr4[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 输出堆顶</span></span><br><span class="line">    arr4[<span class="number">1</span>]=arr4[sz--]; <span class="comment">// 调整堆顶</span></span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>); <span class="comment">// 调整堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索开关问题</title>
    <url>/2024/10/05/%E6%90%9C%E7%B4%A2%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="搜索开关问题">搜索开关问题</span></h1><!-- toc -->

<ul>
<li><a href="#%E4%BE%8B1-%E7%BF%BB%E7%A1%AC%E5%B8%81">[例1]. 翻硬币</a></li>
<li><a href="#%E4%BE%8B2-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3">[例2]. 费解的开关</a></li>
<li><a href="#%E4%BE%8B3-%E9%A3%9E%E8%A1%8C%E5%91%98%E5%85%84%E5%BC%9F">[例3]. 飞行员兄弟</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>开关问题是RoysterCDD自己取的名字，表示一类用位运算解决的搜索变种问题</p>
</blockquote>
<h2><span id="例1-翻硬币">[例1]. 翻硬币</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211111035470.png" alt="image-20240211111035470" style="zoom:80%;">

<ul>
<li>本题的思路是直接用两个字符数组$start$和$finish$来存储初始状态和结束状态，因为题目说一定有解，所以对比两个数组，出现状态不同，则翻转该硬币和相邻硬币即可，假设每两个硬币间存在一个开关，按下该开关即可翻转相邻两枚硬币的状态</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 给你一个初始状态,一个目标状态,还有某种操作,最常用做法:BFS,同样的题目还有八数码</span></span><br><span class="line"><span class="comment">// 但是BFS时间复杂度比较高,局面很多的话应考虑其他做法,可以考虑和费解的开关相同的做法</span></span><br><span class="line"><span class="comment">// 假设每两个灯泡之间中间有一个开关,这个开关按下后可以翻转其两侧灯泡的亮灭状态</span></span><br><span class="line"><span class="comment">// 这样的话想从初始状态到最终状态(假设每个开关只摁一次)只有唯一的一组解</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> start[N],finish[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start[i]==<span class="string">&#x27;*&#x27;</span>) start[i]=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> start[i]=<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;start&gt;&gt;finish;</span><br><span class="line">	n=<span class="built_in">strlen</span>(start); <span class="comment">// 初始状态的长度,即硬币的总个数</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 如果状态不相同,则翻转该硬币和相邻硬币的状态</span></span><br><span class="line">		<span class="keyword">if</span>(start[i]!=finish[i]) &#123;</span><br><span class="line">			<span class="built_in">turn</span>(i),<span class="built_in">turn</span>(i<span class="number">+1</span>);</span><br><span class="line">			res++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="例2-费解的开关">[例2]. 费解的开关</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211100922703.png" alt="image-20240211100922703"></p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211104635922.png" alt="image-20240211104635922" style="zoom:67%;">

<ul>
<li>题目的思路：输入图的状态后，我们对第一行灯的操作，实际上就能够确定剩下四行我们应该对灯进行什么操作，所以枚举第一行的每种操作，从$00000$到$11111$，$1$表示翻转，$0$表示不翻转，$[0,31]$共$32$种情况，所以枚举$op&#x3D;[0,31]$，用位运算的方式判断每一位是否为$1$</li>
<li>当第一行的操作确定后，比如$g[0,2]&#x3D;&#x3D;0$，那我们就要去点亮第二行的$g[1,2]$，用上下左右的上方向去点亮第一行未被点亮的灯，对于剩余行的操作都是一样的，遍历完后如果我们发现最后一行有未被点亮的灯或者操作数多于6次，那么就无法达到，输出$-1$即可</li>
<li>对于每种第一行的操作，我们用$res&#x3D;min(res,step)$来更新最小的答案，本题的技巧还有位运算的技巧、二进制状态表示、准备一个备份数组$backup[N][N]$用于状态复原等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6</span>;</span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N]; <span class="comment">// 图和备份</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;; <span class="comment">// 五个方位(0,0表示本身这个点)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> a=x+dx[i], b=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=<span class="number">5</span> || b&lt;<span class="number">0</span> || b&gt;=<span class="number">5</span>) <span class="keyword">continue</span>; <span class="comment">// 越界处理</span></span><br><span class="line">		<span class="comment">// 因为0和1的ASCII码表示分别为48(110000和49(110001)</span></span><br><span class="line">		<span class="comment">// 所以只需要亦或一个1,亦或0不变,亦或1反转,亦或一个1反转最后一位</span></span><br><span class="line">		g[a][b]^=<span class="number">1</span>; <span class="comment">// 即可让48-&gt;49,49-&gt;48</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 每一行开关的操作完全被前一行灯的亮灭状态所确定</span></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) cin&gt;&gt;g[i]; <span class="comment">// 输入图</span></span><br><span class="line">		<span class="type">int</span> res=<span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们枚举第一行的操作</span></span><br><span class="line">		<span class="comment">// 0~31表示的是00000到11111(遍历每一种操作,1表示我们翻转,0表示不翻转)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">32</span>;op++) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 复制g给backup,操作g</span></span><br><span class="line">			<span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 判断第一行中op共5位中哪一位是1</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">				<span class="comment">// op&gt;&gt;i&amp;1:先右移i位,现在第i位变成最低位,再看是否为1</span></span><br><span class="line">				<span class="keyword">if</span>(op&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					step++; <span class="comment">// 经过一次操作</span></span><br><span class="line">					<span class="built_in">turn</span>(<span class="number">0</span>,i); <span class="comment">// 翻转为1的这一位的状态</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 所以第一行的状态影响了接下来所有行的状态</span></span><br><span class="line">			<span class="comment">// 遍历第一行到倒数第二行,如果为0的话就翻转</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">						step++; <span class="comment">// 如果为0那么需要翻转一次</span></span><br><span class="line">						<span class="built_in">turn</span>(i<span class="number">+1</span>,j); <span class="comment">// 下一行的第j个元素需要翻转</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">bool</span> dark=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">				<span class="comment">// 如果最后一行有没亮的,那就别无他法了</span></span><br><span class="line">				<span class="keyword">if</span>(g[<span class="number">4</span>][i]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">					dark=<span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!dark) res=<span class="built_in">min</span>(res,step);</span><br><span class="line">			<span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g); <span class="comment">// 恢复状态</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res&gt;<span class="number">6</span>) res=<span class="number">-1</span>; <span class="comment">// 题目要求不能超过6步</span></span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="例3-飞行员兄弟">[例3]. 飞行员兄弟</span></h2><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105824073.png" alt="image-20240211105824073" style="zoom:80%;">

<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105917746.png" alt="image-20240211105917746"></p>
<img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240211105930997.png" alt="image-20240211105930997" style="zoom:80%;">

<ul>
<li>本题的思路类似，一共$16$个开关，所以方案总数是$2^{16}&#x3D;65535$种，故枚举$[0,2&lt;&lt;16]$来表示对于这$16$的开关的操作，所以这个$int$型的二进制表示中某一位的值是$1$表示我们要改变这个开关的状态，$0$则表示不改变，枚举每种操作，最后看是否能够使所有把手都打开，如果可以的话把方案加入到$vector$数组中，最后打印即可</li>
<li>技巧：$get(x,y)$函数返回的值代表二维数组中对应位置在二进制表示中的第几个开关（下标）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 本题的难点在于每个灯泡可以被很多开关所控制</span></span><br><span class="line"><span class="comment">// 用暴力法来做,只有4*4=16个开关,所以每个开关嗯的方案数是2^16=65536</span></span><br><span class="line"><span class="comment">// 枚举所有方案→0~2^16-1,用二进制表示,某位为1是摁下,为0表示不摁</span></span><br><span class="line"><span class="comment">// 按照该方案对所有灯泡进行操作,判断灯泡是不是全亮,是的话则记录方案</span></span><br><span class="line"><span class="comment">// 现在要求:步数最小/字典序最小(从小到大排序就可以了)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> g[N][N],backup[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是(x,y)上的数是第几个开关,从上往下从左往右编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*<span class="number">4</span>+y; <span class="comment">// 从0~15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;+&quot;和&quot;-&quot;翻转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_one</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g[x][y]==<span class="string">&#x27;+&#x27;</span>) g[x][y]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> g[x][y]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">turn_all</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">turn_one</span>(x,i); <span class="comment">// 这一行上的数翻转状态</span></span><br><span class="line">		<span class="built_in">turn_one</span>(i,y); <span class="comment">// 这一列上的数翻转状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">turn_one</span>(x,y); <span class="comment">// 因为(x,y)在这一行和这一列交汇处,所以翻转两次相当于没有翻转,再单独翻转一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		cin&gt;&gt;g[i];</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;PII&gt; res; <span class="comment">// 存储所有的方案</span></span><br><span class="line">	<span class="comment">// 枚举每种操作情况,每个开关对应开和不开两种状态,方案数是2^16</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> op=<span class="number">0</span>;op&lt;<span class="number">1</span>&lt;&lt;<span class="number">16</span>;op++) &#123;</span><br><span class="line">		vector&lt;PII&gt; temp; <span class="comment">// 每次新开一个,相当于清空了</span></span><br><span class="line">		<span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g); <span class="comment">// 备份图</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">				<span class="comment">// 如果op在这一位上的值为1</span></span><br><span class="line">				<span class="keyword">if</span>(op&gt;&gt;<span class="built_in">get</span>(i,j)&amp;<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// 向temp中记录一下操作数</span></span><br><span class="line">					temp.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">					<span class="built_in">turn_all</span>(i,j); <span class="comment">// 进行一次反转操作</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">// 判断所有灯泡是否全亮</span></span><br><span class="line">		<span class="type">bool</span> has_closed=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">					has_closed=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(has_closed==<span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(res.<span class="built_in">empty</span>()||res.<span class="built_in">size</span>()&gt;temp.<span class="built_in">size</span>()) res=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g); <span class="comment">// 还原</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;res.<span class="built_in">size</span>()&lt;&lt;endl; <span class="comment">// 方案总数</span></span><br><span class="line">	<span class="comment">// 打印每一种方案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> op:res) cout&lt;&lt;op.x<span class="number">+1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;op.y<span class="number">+1</span>&lt;&lt;endl; <span class="comment">// 坐标+1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>搜索</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索总结</title>
    <url>/2024/10/05/%E6%90%9C%E7%B4%A2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="搜索总结">搜索总结</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs">1. 深度优先搜索DFS</a><ul>
<li><a href="#11-%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98">1.1. 全排列问题</a></li>
<li><a href="#12-n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">1.2. n皇后问题</a></li>
</ul>
</li>
<li><a href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs">2. 广度优先搜索BFS</a><ul>
<li><a href="#21-%E8%B5%B0%E8%BF%B7%E5%AE%AB">2.1. 走迷宫</a></li>
<li><a href="#22-%E5%85%AB%E6%95%B0%E7%A0%81">2.2. 八数码</a></li>
</ul>
</li>
<li><a href="#3-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8">3. 树和图的存储</a><ul>
<li><a href="#31-%E6%9C%89%E5%90%91%E5%9B%BE">3.1. 有向图</a><ul>
<li><a href="#311-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">3.1.1. 邻接矩阵</a></li>
<li><a href="#312-%E9%82%BB%E6%8E%A5%E8%A1%A8">3.1.2. 邻接表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">4. 树和图的遍历</a><ul>
<li><a href="#41-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">4.1. 深度优先遍历</a></li>
<li><a href="#42-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">4.2. 广度优先遍历</a></li>
<li><a href="#43-%E6%A8%A1%E6%9D%BF">4.3. 模板</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-深度优先搜索dfs">1. 深度优先搜索DFS</span></h2><blockquote>
<p>数据结构 stack，空间复杂度O(n)，不具有最短性，深搜问题没有模板</p>
</blockquote>
<ul>
<li>关键在于：剪枝和回溯</li>
</ul>
<h3><span id="11-全排列问题">1.1. 全排列问题</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[maxn]; <span class="comment">// 每一步填的数字</span></span><br><span class="line"><span class="type">bool</span> st[maxn]; <span class="comment">// 遍历状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 跳出条件</span></span><br><span class="line">	<span class="keyword">if</span>(u==n) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">			cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果还没有填满,从数字1开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			path[u]=i;</span><br><span class="line">			st[i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 进入下一层</span></span><br><span class="line">			<span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">			<span class="comment">// 回溯</span></span><br><span class="line">			st[i]=<span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="12-n皇后问题">1.2. n皇后问题</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 皇后个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">9</span>; <span class="comment">// 最大皇后个数</span></span><br><span class="line"><span class="type">int</span> x[maxn<span class="number">+1</span>]; <span class="comment">// 存放皇后位置,x[i]表示第i个皇后的在第几列</span></span><br><span class="line"><span class="type">int</span> res; <span class="comment">// n皇后的可行解个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第i个皇后放置在x[i]列是否会发生冲突</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">place</span><span class="params">(<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// j=1~i-1是已经放置了皇后的行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;j;i++) &#123;</span><br><span class="line">		<span class="comment">// x数组的物理性质决定两个皇后不会发生行冲突</span></span><br><span class="line">		<span class="comment">// x[j]==x[i]:发生列冲突</span></span><br><span class="line">		<span class="comment">// abs(i-j)==abs(x[i]-x[j]):发生对角线冲突,可画图推导</span></span><br><span class="line">		<span class="keyword">if</span>(x[j]==x[i] || <span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(x[i]-x[j]))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 冲突就返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印棋盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	res++; <span class="comment">// 答案+1</span></span><br><span class="line">	<span class="comment">// 遍历每个皇后</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 遍历每一列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="comment">// 如果皇后所在列就是j,打印&#x27;Q&#x27;</span></span><br><span class="line">			<span class="keyword">if</span>(x[i]==j)</span><br><span class="line">				cout&lt;&lt;<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout&lt;&lt;<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放置每个皇后的深度优先搜索函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 遍历第1列到n列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">		<span class="comment">// 先把皇后放到第j列</span></span><br><span class="line">		x[u]=j;</span><br><span class="line">		<span class="comment">// 如果第u个皇后放在这列不冲突</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">place</span>(u)) &#123;</span><br><span class="line">			<span class="comment">// 找到了一个可行解,直接打印</span></span><br><span class="line">			<span class="keyword">if</span>(u==n)</span><br><span class="line">				<span class="built_in">print</span>();</span><br><span class="line">			<span class="comment">// 向下递归</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">dfs</span>(u<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 从第一个皇后开始</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;可行解一共有 &quot;</span>&lt;&lt;res&lt;&lt;<span class="string">&quot; 个&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-广度优先搜索bfs">2. 广度优先搜索BFS</span></h2><blockquote>
<p>数据结构 queue，空间复杂度O(2^n)，最短路，宽搜问题有模板</p>
</blockquote>
<h3><span id="21-走迷宫">2.1. 走迷宫</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 地图范围</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图的情况</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 每个点到初始点的距离</span></span><br><span class="line">PII q[N*N]; <span class="comment">// BFS的队列</span></span><br><span class="line">PII Prev[N][N]; <span class="comment">// 记录遍历的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// hh:队头,当前要处理元素的下标</span></span><br><span class="line">	<span class="comment">// tt:队尾,最后一个入队元素的下标</span></span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化,表示害没有任何点经过</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">	d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 向量表示四个方向</span></span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt) &#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q[hh++]; <span class="comment">// 取出队头</span></span><br><span class="line">		<span class="comment">// 遍历四个方向</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			<span class="type">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">			<span class="comment">// 如果没有超出地图范围且g[x][y]=0且没有到过</span></span><br><span class="line">			<span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; g[x][y]==<span class="number">0</span> &amp;&amp; d[x][y]==<span class="number">-1</span>) &#123;</span><br><span class="line">				d[x][y]=d[t.first][t.second]<span class="number">+1</span>; <span class="comment">// 距离加1</span></span><br><span class="line">				Prev[x][y]=t; <span class="comment">// 记录上一步</span></span><br><span class="line">				q[++tt]=&#123;x,y&#125;; <span class="comment">// 把x,y放进队头</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输出路径</span></span><br><span class="line"><span class="comment">//	int x=n-1,y=m-1;</span></span><br><span class="line"><span class="comment">//	// [0,1] [1,0]都可以输出</span></span><br><span class="line"><span class="comment">//	while(x||y) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//		auto t=Prev[x][y];</span></span><br><span class="line"><span class="comment">//		x=t.first,y=t.second;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回距离</span></span><br><span class="line">	<span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 输入图</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">			cin&gt;&gt;g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-八数码">2.2. 八数码</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 八重码:类似于一个数字华容道嘛,求移动的最少步数(BFS)</span></span><br><span class="line"><span class="comment">// 难点在于状态表示比较复杂,每个状态是一个3*3的小矩阵</span></span><br><span class="line"><span class="comment">// 问题一:队列,如果把每个状态放进队列中 &quot;12345678x&quot;</span></span><br><span class="line"><span class="comment">// 问题二:如何计算每个状态的距离 &quot;queue&lt;string&gt;,unordered_map&lt;string,int&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">queue&lt;string&gt; q; <span class="comment">// 定义队列</span></span><br><span class="line"><span class="comment">// 让字符串映射到int类型的值</span></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; d; <span class="comment">// 通过哈希表来让字符串变化时和移动的距离数值关联</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(st); <span class="comment">// 将字符串入队</span></span><br><span class="line">	d[st]=<span class="number">0</span>; <span class="comment">// 将初始状态的字符串的哈希值设定为0</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;; <span class="comment">// 定义四个方向向量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5在一维数组中的下标是4</span></span><br><span class="line">	string end=<span class="string">&quot;12345678x&quot;</span>; <span class="comment">// 定义宽度优先搜素的终止状态</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) <span class="comment">// 循环终止状态</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q.<span class="built_in">front</span>(); <span class="comment">// 将队列中存着的字符串赋值给t</span></span><br><span class="line">		q.<span class="built_in">pop</span>(); <span class="comment">// 队头元素弹出</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(t==end) </span><br><span class="line">			<span class="keyword">return</span> d[t]; <span class="comment">// 如果当前字符串等于终止状态搜索结束返回该字符串对应的哈希值</span></span><br><span class="line">		<span class="comment">//此处的哈希函数值对应于字符串移动的次数    </span></span><br><span class="line">		<span class="type">int</span> distance = d[t]; <span class="comment">// 定义一个临时变量distance存储形成t字符串当前的移动次数</span></span><br><span class="line">		<span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// k表示&#x27;x&#x27;字符在字符串当前的下标</span></span><br><span class="line">		<span class="comment">// 把&#x27;x&#x27;所在的下标转换成二维数组的形式,比如&quot;12345678x&quot;,x就是8,8/3=2,8%3=2,所以是第三行第三列</span></span><br><span class="line">		<span class="type">int</span> x = k/<span class="number">3</span>,y = k%<span class="number">3</span>; <span class="comment">// 由于字符串当前是一维的将一维下标转化为二维坐标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">// 分别遍历四个方向</span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// 遍历&#x27;x&#x27;可以走的四个方向</span></span><br><span class="line">			<span class="type">int</span> a=x+dx[i],b=y+dy[i]; <span class="comment">//将下一个搜索位置的x,y坐标表示</span></span><br><span class="line">			<span class="comment">// 越界处理</span></span><br><span class="line">			<span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">3</span>&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;<span class="number">3</span>) <span class="comment">//当二维坐标满足位于3X3矩阵中时</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将搜索位置和&#x27;x&#x27;相交换,a*3+b变回一维数组索引</span></span><br><span class="line">				<span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]); <span class="comment">//将字符串中的搜索位置与字符&#x27;x&#x27;交换</span></span><br><span class="line">				<span class="comment">// d.count(t)是统计d这个哈希表容器中t出现的次数,如果一次都没出现过,就放进队列,同时在dist[t]上做加减</span></span><br><span class="line">				<span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)) <span class="comment">// 如果当前的字符串的哈希值为0</span></span><br><span class="line">				&#123;</span><br><span class="line">					d[t]=distance<span class="number">+1</span>; <span class="comment">// 将该字符串对应的哈希值在原字符串对应的哈希值基础上加1</span></span><br><span class="line">					q.<span class="built_in">push</span>(t); <span class="comment">// 将该字符串入队</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">swap</span>(t[a*<span class="number">3</span>+b],t[k]); <span class="comment">// 恢复现场,返回位置判断其他方向</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果无法移动到终止位置返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	string st;</span><br><span class="line">	<span class="comment">// 输入一个初始状态</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		st+=s; <span class="comment">//逐个输入字符串</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>(st)&lt;&lt;endl; <span class="comment">//输出宽度优先搜索的数值	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-树和图的存储">3. 树和图的存储</span></h2><blockquote>
<p>树是一种特殊的图，因此只讨论图</p>
</blockquote>
<h3><span id="31-有向图">3.1. 有向图</span></h3><h4><span id="311-邻接矩阵">3.1.1. 邻接矩阵</span></h4><ul>
<li>邻接矩阵不能存储重边，空间复杂度O(n²)，适合稠密图</li>
</ul>
<h4><span id="312-邻接表">3.1.2. 邻接表</span></h4><ul>
<li>每个结点开一个单链表，邻接表内部的顺序是无所谓的，邻接表插入新边后引入新的结点一般用头插法</li>
</ul>
<h2><span id="4-树和图的遍历">4. 树和图的遍历</span></h2><h3><span id="41-深度优先遍历">4.1. 深度优先遍历</span></h3><blockquote>
<p>时间复杂度O(n+m)，点数+边数</p>
</blockquote>
<ul>
<li>优点在于可以求出每一棵子树的大小。</li>
</ul>
<h3><span id="42-广度优先遍历">4.2. 广度优先遍历</span></h3><blockquote>
<p>时间复杂度O(n+m)，点数+边数</p>
</blockquote>
<ul>
<li>优点在于可以求出最短路径，但前提是每条路的权重相同</li>
</ul>
<h3><span id="43-模板">4.3. 模板</span></h3><blockquote>
<p>注意DFS是没有模板的，但基本可以分为终止条件、递归逻辑、剪枝、恢复现场几个步骤，在另一篇博客里给出了我自己对于DFS的模板，BFS有模板</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入输出规模在100w的时候必须用scanf</span></span><br><span class="line"><span class="comment">// 树和图的存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="comment">// h[i]:第i个结点的邻接表,头插,存储边</span></span><br><span class="line"><span class="comment">// e[j]:第j条边指向的结点</span></span><br><span class="line"><span class="comment">// ne[j]:第j条边的下一条边</span></span><br><span class="line"><span class="comment">// idx:边的编号</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 每个点的搜索状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N],d[N]; <span class="comment">// bfs队列和距离数组</span></span><br><span class="line"><span class="type">int</span> Prev[N]; <span class="comment">// 记录顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 第idx条边指向的结点是b</span></span><br><span class="line">	<span class="comment">// 第idx条边的下一条边是a的单链表(头结点)</span></span><br><span class="line">	<span class="comment">// 结点a的邻接表的第一条边变为idx,idx++</span></span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs找最短路径为例:注意每条路的权重必须都相同,如这里的1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">0</span>; <span class="comment">// 队头和队尾</span></span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">// 头结点是1</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); <span class="comment">// 距离初始化为-1</span></span><br><span class="line">	d[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 第1个结点到第1个结点的距离是0</span></span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt) &#123;</span><br><span class="line">		<span class="type">int</span> t=q[hh++]; <span class="comment">// 取出头结点,hh++</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">			<span class="type">int</span> j=e[i];</span><br><span class="line">			<span class="comment">// 如果j还未访问过</span></span><br><span class="line">			<span class="keyword">if</span>(d[j]==<span class="number">-1</span>) &#123;</span><br><span class="line">				d[j]=d[j]<span class="number">+1</span>;</span><br><span class="line">				q[++tt]=j; <span class="comment">// 在队尾增加一个空位,再把j的值赋给q[tt]</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	st[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 从u的第一条边开始往下遍历每一条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j=e[i];</span><br><span class="line">		<span class="comment">// 如果还未被访问过,就继续dfs[j]</span></span><br><span class="line">		<span class="keyword">if</span>(!st[j])</span><br><span class="line">			dfs[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化为-1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>日期问题</title>
    <url>/2024/10/02/%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="模拟日期">模拟日期</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F">1. 回文日期</a></li>
<li><a href="#2-%E9%A1%BA%E5%AD%90%E6%97%A5%E6%9C%9F">2. 顺子日期</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-回文日期">1. 回文日期</span></h2><ul>
<li>从这道题中主要学习的思路是：直接用int型数据模拟日期，从而进行枚举，再判断这个日期是否合法，是否满足题目的要求</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: 日期问题,跟shit一样,但是做一遍找到规律就没问题了</span></span><br><span class="line"><span class="comment">// 输入一个起始日期和一个终止日期,最后返回这个日期中有多少个日期是回文的</span></span><br><span class="line"><span class="comment">// 换个思路,我们枚举所有的回文数,因为前四位确定了后四位就一定确定了</span></span><br><span class="line"><span class="comment">// 前四位&gt;=1000,又因为是四位数,所以最大9999,范围则[1000,9999]</span></span><br><span class="line"><span class="comment">// 把字符串拼接起来过后再去判断日期是否合法</span></span><br><span class="line"><span class="comment">// 如何判断一个日期是否在两个日期之间?字典序嘛,不用想复杂了</span></span><br><span class="line"><span class="comment">// 最后如何判断日期是否合法呢?用一个数组month存储每一个月的状态</span></span><br><span class="line"><span class="comment">// 对于2月,还要考虑平年和闰年的情况</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> months[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;; <span class="comment">// 1~12月的天数,平年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期是否合法,完全可以当模板</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> date)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> year=date/<span class="number">10000</span>; <span class="comment">// 取前四位</span></span><br><span class="line">	<span class="type">int</span> month=date%<span class="number">10000</span>/<span class="number">100</span>; <span class="comment">// 后四位的前两位</span></span><br><span class="line">	<span class="type">int</span> day=date%<span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果月份不合法和天数=0</span></span><br><span class="line">	<span class="keyword">if</span>(!month || month&gt;=<span class="number">13</span> || !day) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 平年下天数不合法</span></span><br><span class="line">	<span class="keyword">if</span>(month!=<span class="number">2</span> &amp;&amp; day&gt;months[month]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 月份为2,单独判断是否为闰年以及合法与否</span></span><br><span class="line">	<span class="keyword">if</span>(month==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// 四年一闰,百年不闰,四百年又闰</span></span><br><span class="line">		<span class="type">bool</span> leap= year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span> || year%<span class="number">400</span>==<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(day&gt;months[month]+leap) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> date1,date2;</span><br><span class="line">	cin&gt;&gt;date1&gt;&gt;date2; <span class="comment">// 开始和结束日期</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 只枚举年份</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> date=i,x=i;</span><br><span class="line">		<span class="comment">// 拼接成回文数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">			date=date*<span class="number">10</span>+x%<span class="number">10</span>; <span class="comment">// 取后四位的最后一位拼上来</span></span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(date1&lt;=date &amp;&amp; date&lt;=date2 &amp;&amp; <span class="built_in">check</span>(date)) res++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-顺子日期">2. 顺子日期</span></h2><ul>
<li>本题要学的思路是用sprintf函数将指定格式的int型的year, month, day的值输入到字符数组中制造字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目描述: YYYYMMdd这个日期格式中若出现三个升序连续的数字,记为顺子年</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目只要求找2022年,这是一个平年</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> months[]=&#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,</span><br><span class="line">	<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,</span><br><span class="line">	<span class="number">31</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串表示日期,判断是否为顺子年</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i<span class="number">+2</span>&lt;str.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str[i<span class="number">+1</span>]==str[i]<span class="number">+1</span> &amp;&amp; str[i<span class="number">+2</span>]==str[i<span class="number">+1</span>]<span class="number">+1</span> &amp;&amp; str[i]!=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> year=<span class="number">2022</span>,month=<span class="number">1</span>,day=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 一年中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">365</span>;i++) &#123;</span><br><span class="line">		<span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">		<span class="comment">// 用sprintf函数按照指定格式制造字符串</span></span><br><span class="line">		<span class="built_in">sprintf</span>(str,<span class="string">&quot;%04d%02d%02d&quot;</span>,year,month,day); <span class="comment">// %04d不足4位自动补0</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(str)) &#123;</span><br><span class="line">			res++;</span><br><span class="line">			cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 进月</span></span><br><span class="line">		<span class="keyword">if</span>(++day&gt;months[month]) &#123;</span><br><span class="line">			day=<span class="number">1</span>;</span><br><span class="line">			month++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2024/10/04/%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="树">树</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">1. 树的遍历</a></li>
<li><a href="#2-%E6%8E%A8%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91">2. 推断二叉树</a><ul>
<li><a href="#21-%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84">2.1. 前序(后序)+中序→二叉树结构</a></li>
<li><a href="#22-%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84">2.2. 按层遍历+中序→二叉树结构</a></li>
<li><a href="#23-%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84">2.3. 扩展二叉树+前序(后序)→二叉树结构</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-树的遍历">1. 树的遍历</span></h2><ul>
<li>绕行踩点，按照深度优先搜索的顺序遍历整棵树，经过树的左侧时记录，得到的是先序遍历序列，经过树的下方时记录，得到的是中序遍历序列，经过数的右侧”🔺”时记录，得到的是后序遍历序列。</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240304151152074.png" alt="image-20240304151152074"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240304151653655.png" alt="image-20240304151653655"></p>
<ul>
<li>若输入 $(0,0)$ 表示叶子节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 用左右孩子节点表示法</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_Order</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(node[root].l!=<span class="number">0</span>) <span class="built_in">pre_Order</span>(node[root].l);</span><br><span class="line">	<span class="keyword">if</span>(node[root].r!=<span class="number">0</span>) <span class="built_in">pre_Order</span>(node[root].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_Order</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[root].l!=<span class="number">0</span>) <span class="built_in">in_Order</span>(node[root].l);</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span>(node[root].r!=<span class="number">0</span>) <span class="built_in">in_Order</span>(node[root].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_Order</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node[root].l!=<span class="number">0</span>) <span class="built_in">post_Order</span>(node[root].l);</span><br><span class="line">	<span class="keyword">if</span>(node[root].r!=<span class="number">0</span>) <span class="built_in">post_Order</span>(node[root].r);</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 输入编号1~n的左右孩子的编号</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		node[i]=&#123;l,r&#125;; <span class="comment">// 编号即为值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pre_Order</span>(<span class="number">1</span>); <span class="comment">// 前序遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">in_Order</span>(<span class="number">1</span>); <span class="comment">// 中序遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">post_Order</span>(<span class="number">1</span>); <span class="comment">// 后序遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2><span id="2-推断二叉树">2. 推断二叉树</span></h2><ul>
<li><p>已知一棵二叉树，可以确定它的四种遍历序列（前序、中序、后序、按层遍历），反过来，已知两种遍历序列，也能确定一棵二叉树。</p>
</li>
<li><p>根据先序序列第一个结点确定根结点</p>
</li>
<li><p>根据根结点在中序序列中的位置，分割出左子树和右子树</p>
</li>
<li><p>对左子树和右子树分别递归使用相同的方法继续分解</p>
</li>
</ul>
<h3><span id="21-前序后序中序二叉树结构">2.1. 前序(后序)+中序→二叉树结构</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 输入先序序列和中序序列推断出后序序列</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> val; </span><br><span class="line">	<span class="type">int</span> l,r; <span class="comment">// 左子树根节点编号,右子树根节点编号</span></span><br><span class="line">&#125;node[N];</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树因子</span></span><br><span class="line">string s_pre,s_in; <span class="comment">// 先序序列和中序序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据先序和中序建二叉树,返回树根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create</span><span class="params">(string sp,string si)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k; <span class="comment">// 分割点</span></span><br><span class="line">	<span class="type">int</span> root=++idx;</span><br><span class="line">	node[root].val=sp[<span class="number">0</span>]; <span class="comment">// 先序第一个节点作为树根</span></span><br><span class="line">	<span class="comment">// 找到树根在中序遍历中的位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(sp[<span class="number">0</span>]==si[i]) &#123;</span><br><span class="line">			k=i;</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确定左右子树序列的长度</span></span><br><span class="line">	<span class="type">int</span> len_l=k,len_r=si.<span class="built_in">length</span>()<span class="number">-1</span>-k;</span><br><span class="line">	<span class="comment">// 序列长度&gt;0,建立根节点的左子树,并递归对左子树按照先序和中序递归求解</span></span><br><span class="line">	<span class="comment">// 注意对sp和si都取相同的字符串长度</span></span><br><span class="line">	<span class="comment">// 先序遍历中,根节点总是在最前面,所以对sp跳过根节点</span></span><br><span class="line">	<span class="comment">// 中序遍历中,左子树总是在根节点之前,所以不需要跳过任何节点</span></span><br><span class="line">	<span class="keyword">if</span>(len_l&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		node[root].l=<span class="built_in">create</span>(sp.<span class="built_in">substr</span>(<span class="number">1</span>,len_l),si.<span class="built_in">substr</span>(<span class="number">0</span>,len_l));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(len_r&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		node[root].r=<span class="built_in">create</span>(sp.<span class="built_in">substr</span>(k<span class="number">+1</span>,len_r),si.<span class="built_in">substr</span>(k<span class="number">+1</span>,len_r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root; <span class="comment">// 返回头结点编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root!=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">postOrder</span>(node[root].l);</span><br><span class="line">		<span class="built_in">postOrder</span>(node[root].r);</span><br><span class="line">		cout&lt;&lt;node[root].val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想按层遍历,则用BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//		cout&lt;&lt;x&lt;&lt;&#x27; &#x27;; // 若输出编号</span></span><br><span class="line">		cout&lt;&lt;node[x].val&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(node[x].l!=<span class="number">0</span>) q.<span class="built_in">push</span>(node[x].l);</span><br><span class="line">		<span class="keyword">if</span>(node[x].r!=<span class="number">0</span>) q.<span class="built_in">push</span>(node[x].r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s_pre&gt;&gt;s_in;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">create</span>(s_pre,s_in);</span><br><span class="line">	<span class="built_in">postOrder</span>(root); <span class="comment">// 输出后续遍历结果</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">bfs</span>(root); <span class="comment">// 输出按层遍历的结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">样例输入:</span></span><br><span class="line"><span class="comment">abdec</span></span><br><span class="line"><span class="comment">dbeac</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3><span id="22-按层遍历中序二叉树结构">2.2. 按层遍历+中序→二叉树结构</span></h3><ul>
<li>按层遍历比较特殊，因为是按层，一般用广搜实现，下面这段代码的技巧在于，新开一种数据类型<strong>用于存储将中序遍历按照按层遍历中找到的根节点的信息</strong>，存储的信息包括这个待分解的中序遍历序列以及其根节点所在的位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解题思路: 将按层遍历的序列按照中序遍历序列分解那么排在前面的一定是根节点</span></span><br><span class="line"><span class="comment">// 但是按照常规算法来做时间复杂度会变成O(n²),介绍下面这种做法</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外开一个数据结构来存储按层遍历结果将中序遍历分成的每段中序遍历序列的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">	string s_in; <span class="comment">// 中序遍历序列</span></span><br><span class="line">	<span class="type">int</span> idx; <span class="comment">// 该中序遍历序列对应的子树的根节点编号</span></span><br><span class="line">	<span class="built_in">QNode</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">QNode</span>(string a,<span class="type">int</span> b):<span class="built_in">s_in</span>(a),<span class="built_in">idx</span>(b)&#123;&#125; <span class="comment">// 构造方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line">string s_in,s_lev; <span class="comment">// 中序遍历序列和层次遍历序列</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// 建树因子</span></span><br><span class="line"><span class="type">int</span> lev_i; <span class="comment">// s_lev的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;QNode&gt; q;</span><br><span class="line">	<span class="type">int</span> k; <span class="comment">// 分割点</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">QNode</span>(s_in,++cnt)); <span class="comment">// 根节点地址为1</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		QNode u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">// 寻找中序遍历序列中根节点(根据层遍历)元素的下标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;u.s_in.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">			<span class="comment">// lev_i从0开始</span></span><br><span class="line">			<span class="keyword">if</span>(u.s_in[i]==s_lev[lev_i]) &#123;</span><br><span class="line">				k=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">// 这里可以手动模拟一下,更清晰</span></span><br><span class="line">		node[u.idx].val=s_lev[lev_i++]; <span class="comment">// 下一次在层次遍历中看下一个字符</span></span><br><span class="line">		string sl=u.s_in.<span class="built_in">substr</span>(<span class="number">0</span>,k),sr=u.s_in.<span class="built_in">substr</span>(k<span class="number">+1</span>); <span class="comment">// 左子树的中序遍历序列,右子树的中序遍历序列</span></span><br><span class="line">		<span class="comment">// 存在左子树,建树</span></span><br><span class="line">		<span class="keyword">if</span>(sl.<span class="built_in">length</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> lroot=++cnt; <span class="comment">// 根节点分配编号</span></span><br><span class="line">			node[u.idx].l=lroot;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">QNode</span>(sl,lroot)); <span class="comment">// sl是中序遍历序列,lroot是该中序遍历序列的根节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sr.<span class="built_in">length</span>()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> rroot=++cnt;</span><br><span class="line">			node[u.idx].r=rroot;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">QNode</span>(sr,rroot));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	cout&lt;&lt;node[root].val;</span><br><span class="line">	<span class="built_in">preOrder</span>(node[root].l);</span><br><span class="line">	<span class="built_in">preOrder</span>(node[root].r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;s_in&gt;&gt;s_lev;</span><br><span class="line">	<span class="built_in">createTree</span>();</span><br><span class="line">	<span class="built_in">preOrder</span>(<span class="number">1</span>); <span class="comment">// 输出前序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">DBEAC</span></span><br><span class="line"><span class="comment">ABCDE</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">ABDEC</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h3><span id="23-扩展二叉树前序后序二叉树结构">2.3. 扩展二叉树+前序(后序)→二叉树结构</span></h3><ul>
<li>知道三种遍历中的其中两种可以推断出树的结构，但是用扩展二叉树标记法的时候只需要知道前序或者后序中的一种也能够推断出二叉树的结构</li>
<li>单独知道中序遍历无论如何都无法推断出二叉树的结构</li>
<li>下面代码的样例输入：$ABD..EF..G..C..$ 其中”.”表示的是补充的孩子节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 知道扩展二叉树的先序遍历结果即可反解出中序遍历和后序遍历</span></span><br><span class="line"><span class="comment">// 中序遍历和后序遍历的代码简单,关键在于如何建树</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">&#125;node[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树因子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(node[r].l);</span><br><span class="line">	cout&lt;&lt;node[r].val;</span><br><span class="line">	<span class="built_in">inOrder</span>(node[r].r);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">postOrder</span>(node[r].l);</span><br><span class="line">	<span class="built_in">postOrder</span>(node[r].r);</span><br><span class="line">	cout&lt;&lt;node[r].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入生成的二叉树的根值,返回生成的二叉树的编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTree</span><span class="params">(<span class="type">char</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val==<span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 说明到根节点了,左子树/右子树建树结束</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> root=++idx;</span><br><span class="line">		node[root].val=val;</span><br><span class="line">		node[root].l=<span class="built_in">createTree</span>(cin.<span class="built_in">get</span>()); <span class="comment">// 读取下一个字符是左子树</span></span><br><span class="line">		node[root].r=<span class="built_in">createTree</span>(cin.<span class="built_in">get</span>()); <span class="comment">// 读取下一个字符是右子树</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> root=<span class="built_in">createTree</span>(cin.<span class="built_in">get</span>()); <span class="comment">// 不断读取每一个字符</span></span><br><span class="line">	<span class="built_in">inOrder</span>(root);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">postOrder</span>(root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">ABD..EF..G..C..</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">DBFEGAC</span></span><br><span class="line"><span class="comment">DFGEBCA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2024/10/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="最小生成树">最小生成树</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E6%9C%B4%E7%B4%A0prim%E7%AE%97%E6%B3%95">1. 朴素Prim算法</a></li>
<li><a href="#2-kruskal%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96">2. Kruskal算法+并查集优化</a></li>
<li><a href="#3-kruskal%E5%BB%B6%E7%94%B3%E5%AF%B9%E8%BE%93%E5%87%BA%E6%8E%92%E5%BA%8F">3. Kruskal延申：对输出排序</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li>以下模板能使用的前提是：不存在负权环</li>
</ul>
<h2><span id="1-朴素prim算法">1. 朴素Prim算法</span></h2><blockquote>
<p>时间复杂度：$O(n^2)$，适合稠密图，边数接近点数的平方</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素Prim,和dijkstra非常相似</span></span><br><span class="line"><span class="comment">// 1.dist数组初始化为不可达</span></span><br><span class="line"><span class="comment">// 2.遍历每个点,找到集合外距离最近的点</span></span><br><span class="line"><span class="comment">// 3.用t更新其他点到集合的距离</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>; <span class="comment">// 无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储图</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储各结点到生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 访问状态</span></span><br><span class="line"><span class="type">int</span> pre[N]; <span class="comment">// 节点的前驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化为不可达</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="comment">// 最终结果</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">// 从1号点开始生成</span></span><br><span class="line">	<span class="comment">// 对于每个点都遍历一遍</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="comment">// t是距离点集最近的点</span></span><br><span class="line">		<span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// 从点1~n中去找t</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="comment">// 如果j未被访问并且t是第一次更新,并且从t到源点距离比从j到源点距离更近</span></span><br><span class="line">			<span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[t]&gt;dist[j]))</span><br><span class="line">				t=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是孤立点,直接退出,无法构成最小生成树</span></span><br><span class="line">		<span class="keyword">if</span>(i &amp;&amp; dist[t]==<span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> INF;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 先更新,再累加,防止把自环加进来</span></span><br><span class="line">		<span class="comment">// 状态更新</span></span><br><span class="line">		st[t]=<span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 求和距离</span></span><br><span class="line">		res+=dist[t];</span><br><span class="line">		<span class="comment">// 更新dist[j]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dist[j]=min(dist[j],g[t][j]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果要输出边</span></span><br><span class="line"><span class="comment">//		for(int j=1;j&lt;=n;j++) &#123;</span></span><br><span class="line"><span class="comment">//			if(dist[j]&gt;g[t][j]&amp;&amp;!st[j]) &#123;</span></span><br><span class="line"><span class="comment">//				dist[j]=g[t][j];</span></span><br><span class="line"><span class="comment">//				pre[j]=t; // 距离变短,前驱变为t</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;pre[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		g[a][b]=g[b][a]=min(g[a][b],c); <span class="comment">// 去重边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=prim();</span><br><span class="line">	<span class="keyword">if</span>(t==INF)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//	getPath();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-kruskal算法并查集优化">2. Kruskal算法+并查集优化</span></h2><blockquote>
<p>时间复杂度：$O(mlog^n)$，适合稀疏图，以下模板能解决重边、自环、负权边<br>题目链接：<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">10</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2</span>*(<span class="number">2e5</span>+<span class="number">5</span>); <span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点/终点/权值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Edge a,Edge b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// p[i]:顶点i的连通分量</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集查询连通分量,带路径压缩</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(p[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> p[x]=find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 加入图的边数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="comment">// 取出每条边中的信息</span></span><br><span class="line">		<span class="type">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].val;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果a和b已经相连则跳过</span></span><br><span class="line">		<span class="comment">// 1.如果是自环-&gt;(3,3)=5</span></span><br><span class="line">		<span class="comment">// 2.如果是重边-&gt;(1,2)=3,(2,1)=5,此时取小边(因为排过序了)</span></span><br><span class="line">		<span class="keyword">if</span>(find(a)==find(b)) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出这条边</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;a&lt;&lt;&quot;--&quot;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 选择这条边后的信息维护 </span></span><br><span class="line">		p[find(a)]=find(b); <span class="comment">// 连通两个并查集</span></span><br><span class="line">		ans+=w; <span class="comment">// 答案累加这条边的权值</span></span><br><span class="line">		cnt++; <span class="comment">// 边数+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 联通</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 并查集初始化:连通分量为自身</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		p[i]=i; 	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输入每条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="comment">//		scanf(&quot;%d%d%d&quot;,&amp;edges[i].a,&amp;edges[i].b,&amp;edges[i].val);</span></span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		edges[i]=&#123;a,b,c&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(edges+<span class="number">1</span>,edges+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">if</span>(kruskal()) <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-kruskal延申对输出排序">3. Kruskal延申：对输出排序</span></h2><blockquote>
<p>将数组改成 $vector$，为结构体提供无参构造器和全参构造器 $m$，例题：信奥一本通 $p1348$，以下模板能解决重边、自环、负权边。<br>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1348">  信息学奥赛一本通（C++版）</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e5</span><span class="number">+5</span>; <span class="comment">// 最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点/终点/边权</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	ll val;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> aa,<span class="type">int</span> bb,<span class="type">int</span> cc) &#123;</span><br><span class="line">		a=aa;</span><br><span class="line">		b=bb;</span><br><span class="line">		val=cc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">// 记录父节点</span></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges,tree; <span class="comment">// 存储所有边和生成树的边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边权越小越靠前</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_edges</span><span class="params">(Edge a,Edge b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对生成树的边二次排序,编号小的靠前</span></span><br><span class="line"><span class="comment">// 起始点相同,终点小的靠前;否则起始点小的靠前</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp_trees</span><span class="params">(Edge x,Edge y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.a==y.a) <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询根节点带路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 已加入图的边</span></span><br><span class="line">	<span class="keyword">for</span>(Edge e:edges) &#123;</span><br><span class="line">		<span class="comment">// 提取边的信息</span></span><br><span class="line">		<span class="type">int</span> a=e.a, b=e.b, w=e.val;</span><br><span class="line">		<span class="type">int</span> v1=<span class="built_in">find</span>(a);</span><br><span class="line">		<span class="type">int</span> v2=<span class="built_in">find</span>(b);</span><br><span class="line">		<span class="comment">// 若a,b已相连</span></span><br><span class="line">		<span class="keyword">if</span>(v1==v2) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 选中这条边</span></span><br><span class="line">		cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		ans+=w;</span><br><span class="line">		fa[v1]=v2; <span class="comment">// 联通并查集</span></span><br><span class="line">		cnt++;</span><br><span class="line">		tree.<span class="built_in">push_back</span>(e); <span class="comment">// 添加到生成树边集中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 优化输入输出</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="comment">// 初始化并查集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		fa[i]=i;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		<span class="comment">// 强行让小的编号在前,大的编号在后</span></span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(a,b,c));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),cmp_edges);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">kruskal</span>()) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 对生成树中的边再排序</span></span><br><span class="line">	<span class="built_in">sort</span>(tree.<span class="built_in">begin</span>(),tree.<span class="built_in">end</span>(),cmp_trees);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> e:tree) &#123;</span><br><span class="line">		cout&lt;&lt;e.a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;e.b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;e.val&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>桶</title>
    <url>/2024/10/03/%E6%A1%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="桶">桶</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%A1%B6%E7%BB%93%E6%9E%84">1. 桶结构</a></li>
<li><a href="#2-%E6%A1%B6%E6%8E%92%E5%BA%8F">2. 桶排序</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-桶结构">1. 桶结构</span></h2><blockquote>
<p>将桶单独拿出来讲，是为了讲后面的离散化</p>
</blockquote>
<ul>
<li>当数组中每个元素的大小范围给定时并且不超过空间限制时，用该数组的下标或下标+偏移量映射为该值的大小，数组的值表示该数字出现的次数的数据结构</li>
<li>优点：有效提高数据的访问效率和处理速度</li>
<li>缺点：必须知道每个元素的大小范围并且能够映射到$[0,N]$才可以使用</li>
</ul>
<blockquote>
<p>例题：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1186">1186：出现次数超过一半的数  信息学奥赛一本通（C++版）</a></p>
</blockquote>
<ul>
<li>桶做法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span><span class="number">+10</span>; <span class="comment">// (-50,50),(0,100),[1,99]</span></span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 桶</span></span><br><span class="line"><span class="comment">// 什么时候用桶→每个数据的范围给定</span></span><br><span class="line"><span class="comment">// 下标代表这个数字,或者这个数字的映射值,数组的值代表出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// temp:临时变量,nm n表示行,m表示列</span></span><br><span class="line"><span class="comment">// ans:answer, res:result, cnt:count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序:冒泡/交换/选择 O(n²), 快排/希尔排序/归并排序O(nlogn)/sort, 桶排序O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n; <span class="comment">// 5: 2 4 2 5 9</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		a[temp<span class="number">+50</span>]++; <span class="comment">// a[2]++,a[2]=1,a[4]=1,a[2]=2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历所有可能的大小,其实就遍历了所有的数字</span></span><br><span class="line">	<span class="comment">// 如果根本没出现过,a[i]=0</span></span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// a[i]代表出现的次数</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;n/<span class="number">2</span>) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			cout&lt;&lt;i<span class="number">-50</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>map做法</p>
</li>
<li><p>$map$是$C++$ STL库中自带的一种数据结构，可以理解为$Python$中的$dict$字典数据结构，map中有两个关键字，一个是键(索引)，一个是键值，它是一个二元组，和本题不谋而合，让第一个关键字存储这个值的大小，第二关键字存储出现的次数即可，而且不用考虑从$[-49,49]$映射到$[1,99]$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		m[temp]++; <span class="comment">// temp作为索引,键值+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 遍历map中的所有元素,迭代器的方法遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(it-&gt;second&gt;n/<span class="number">2</span>) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			cout&lt;&lt;it-&gt;first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-桶排序">2. 桶排序</span></h2><ul>
<li>当数据入桶后其实就相当于已经排好了序，我们可以从元素最小值遍历到最大值，又因为桶中的元素代表着这个元素出现的次数，那么出现了多少次我们就输出多少次这个元素，又因为是从小到大遍历的，所以倒桶的过程就是桶排序</li>
<li>桶排序的时间复杂度是$O(n)$，其中n是元素个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 假设每个元素的大小范围是[1,1000],我们准备一个大小足够的桶</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>; </span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="type">int</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		<span class="comment">// 入桶</span></span><br><span class="line">		a[temp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 倒桶的过程即为排序,不是真正的排好序</span></span><br><span class="line">	<span class="comment">// 从小到大遍历下标,即less规则排序</span></span><br><span class="line">	<span class="comment">// 从大到小遍历下标,即greater规则排序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i这个数字出现过</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&gt;<span class="number">0</span>;j--) &#123;</span><br><span class="line">				<span class="comment">// 输出a[i]次,因为a[i]代表i出现的次数</span></span><br><span class="line">				cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛</title>
    <url>/2024/10/07/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="欧拉筛">欧拉筛</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E4%BC%A0%E7%BB%9F%E6%89%BE%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E4%BC%98%E5%8C%96%E7%AD%9B%E9%80%89%E6%AC%A1%E6%95%B0">1. 传统找质数的方法（优化筛选次数）</a></li>
<li><a href="#2-%E6%AC%A7%E6%8B%89%E7%AD%9B">2. 欧拉筛</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-传统找质数的方法优化筛选次数">1. 传统找质数的方法（优化筛选次数）</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要找从 $[1,1e6]$ 中的所有质数，时间复杂度很高</li>
</ul>
<h2><span id="2-欧拉筛">2. 欧拉筛</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230720102317937.png" alt="image-20230720102317937"></p>
<ul>
<li>算法思想：遍历到 $2$ 的时候，筛掉范围内所有 $2$ 的倍数（因为除了 $1$ 和自身以外，一定能被 $2$ 整除），到 $3$ 的时候，筛掉所有 $3$ 的倍数···</li>
<li>注意：如果计算 $[l,r]$ 之间出现的质数的个数？可以用前缀和的思想；当 $n$ 过大时，$i×i$ 容易出现数组越界的错误，即可能 $RuntimeError$ ，此时要将线性筛中第二个 $for$ 中的 $j&#x3D;i×i$ 改为 $j&#x3D;i+i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 下标为i时,记录1~i出现的所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 是否已经访问过</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 用于存放素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx是存放素数的遍历因子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果vis[i]为false才需要遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]<span class="number">+1</span>; <span class="comment">// 计算前缀和</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 是素数,存起来</span></span><br><span class="line">            <span class="comment">// 如果出现RuntimeError,将j=i+i,这样就不会数组越界</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) <span class="comment">// 将素数i的倍数全部标记为合数,则无需遍历</span></span><br><span class="line">				vis[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如:输入1000即打印0~1000以内的素数</span></span><br><span class="line">	cin&gt;&gt;n;  </span><br><span class="line">	<span class="type">int</span> l,r; <span class="comment">// 左右区间</span></span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">get_primes</span>(n);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;1~&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;之间的素数分别是:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=idx;i++) &#123;</span><br><span class="line">		cout&lt;&lt;p[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=idx)</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;r&lt;&lt;<span class="string">&quot;所出现的素数个数为:&quot;</span>&lt;&lt;f[r]-f[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最简单的模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+5</span>; <span class="comment">// 注意这里没有开到2^9,只要比sqrt(2^9)大即可</span></span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> ans[N],len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++) &#123;</span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么特判x&gt;=N的情况?因为为了节省内存或者没必要,本题中只要保证MAXN比sqrt(理论最大值)大即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> !st[x];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;primes[i]&lt;=x/primes[i];i++)</span><br><span class="line">		<span class="keyword">if</span>(x%primes[i]==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
        <tag>欧拉筛</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索</title>
    <url>/2024/10/04/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="深度优先搜索">深度优先搜索</span></h1><!-- toc -->

<ul>
<li><a href="#1-dfs%E6%A8%A1%E6%9D%BF">1. DFS模板</a></li>
<li><a href="#2-%E8%A7%A6%E7%A2%B0%E8%8A%82%E7%82%B9%E6%97%B6%E6%9C%BA">2. 触碰节点时机</a><ul>
<li><a href="#21-%E5%A4%9A%E5%8F%89%E6%A0%91">2.1. 多叉树</a></li>
<li><a href="#22-%E4%BA%8C%E5%8F%89%E6%A0%91">2.2. 二叉树</a></li>
<li><a href="#23-%E4%B8%80%E6%9D%A1%E9%93%BE">2.3. 一条链</a></li>
<li><a href="#24-%E5%9B%BE">2.4. 图</a></li>
</ul>
</li>
<li><a href="#3-%E4%BE%8B%E9%A2%98">3. 例题</a><ul>
<li><a href="#31-%E6%B4%9B%E8%B0%B7-p1605-%E8%BF%B7%E5%AE%AB">3.1. 洛谷 P1605 迷宫</a></li>
<li><a href="#32-%E6%B4%9B%E8%B0%B7-p1644-%E8%B7%B3%E9%A9%AC%E9%97%AE%E9%A2%98">3.2. 洛谷 P1644 跳马问题</a></li>
<li><a href="#33-%E6%B4%9B%E8%B0%B7-p1219-%E5%85%AB%E7%9A%87%E5%90%8E">3.3. 洛谷 P1219 八皇后</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<blockquote>
<p>推荐视频：<a href="https://www.bilibili.com/video/BV1uS4y1i7j5/?spm_id_from=333.337.search-card.all.click&vd_source=b8e5916fcec63c0b6234c190e1ec6dd1">B03 深搜 (DFS) 算法_bilibili</a></p>
</blockquote>
<h2><span id="1-dfs模板">1. DFS模板</span></h2><ul>
<li>深搜是通过系统栈实现的</li>
<li>递归调用的过程，系统自动通过栈去维护函数的状态空间</li>
<li>系统栈记录函数返回地址、局部变量、参数传递等</li>
<li>向下走，是压栈的过程；向上走，是出栈的过程</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322200028226.png" alt="image-20240322200028226"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[N]; <span class="comment">// 存储每个节点可达节点的编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u:当前节点,fa:父节点,存储父节点是为了避免往回走</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 输出当前点的编号,dfs遍历顺序</span></span><br><span class="line">	<span class="comment">// 对于节点u的所有儿子节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>; <span class="comment">// 避免往回走,因为是有向边</span></span><br><span class="line">		dfs(v,u); <span class="comment">// 往下走</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 节点数和边数</span></span><br><span class="line"><span class="type">int</span> a,b; <span class="comment">// 起点和终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  8 7</span></span><br><span class="line"><span class="comment">  3 6</span></span><br><span class="line"><span class="comment">  8 6</span></span><br><span class="line"><span class="comment">  2 5</span></span><br><span class="line"><span class="comment">  5 6</span></span><br><span class="line"><span class="comment">  1 5</span></span><br><span class="line"><span class="comment">  5 7</span></span><br><span class="line"><span class="comment">  1 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="comment">// 双向边</span></span><br><span class="line">		e[a].push_back(b);</span><br><span class="line">		e[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>); <span class="comment">// 从根节点1开始走,默认0是至高节点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-触碰节点时机">2. 触碰节点时机</span></h2><h3><span id="21-多叉树">2.1. 多叉树</span></h3><ul>
<li>1：入，2：下，3：回，4：离</li>
<li>深搜的计算过程：<ol>
<li>自顶向下，由父节点信息计算子节点信息，入和下，如对节点5，入代表父节点1向子节点5传递，下代表父节点5向子节点2、6、7传递</li>
<li>自底向上，由子节点信息计算父节点信息，回和离，如对节点5，回代表子节点2、6、7向父节点5传递，离代表子节点5向父节点1传递</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322203537204.png" alt="image-20240322203537204"></p>
<ul>
<li>如何理解？入是第一次遍历到该节点，所以直接输出编号即可；下是在遍历儿子节点过程中，由该节点第一次向下访问其下的儿子节点，随后对儿子节点递归到下一层dfs(v,u)（此时u作为v的父节点向下传递），当函数自然结束时，应该回溯，所以有回，回是该节点第一次向上访问其父节点，输出编号；循环结束后在节点u上的函数应该自然结束了，所以离开节点u，此时系统栈会回溯到5的父节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入%d\n&quot;</span>, u);</span><br><span class="line">	<span class="comment">// 下和回有多次</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;下%d-&gt;%d\n&quot;</span>, u, v); <span class="comment">// 下</span></span><br><span class="line">		dfs2(v, u);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;回%d&lt;-%d\n&quot;</span>, u, v); <span class="comment">// 回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;离%d\n&quot;</span>, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="22-二叉树">2.2. 二叉树</span></h3><ul>
<li>1：先，2：中，3：后</li>
<li>在线段树就用到了类似的思想，其中先就对应的父节点将懒标记下传到儿子节点的pushdown函数，而遍历完两个儿子过后的“后”就类似于线段树中儿子节点上传更新父节点懒标记的pushup函数</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322205838629.png" alt="image-20240322205838629"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs3</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;先%d\n&quot;</span>,u);</span><br><span class="line">	dfs3(<span class="number">2</span>*u); <span class="comment">// 访问左孩子</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;中%d\n&quot;</span>,u);</span><br><span class="line">	dfs3(<span class="number">2</span>*u+<span class="number">1</span>); <span class="comment">// 访问右孩子</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;后%d\n&quot;</span>,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="23-一条链">2.3. 一条链</span></h3><ul>
<li>1：入，2：离</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322210326282.png" alt="image-20240322210326282"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ne[N]; <span class="comment">// 每个节点的下一个节点编号(类似链表)</span></span><br><span class="line"><span class="comment">// 一条链</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs4</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;入%d\n&quot;</span>,u);</span><br><span class="line">	dfs4(ne[u]); <span class="comment">// 下一个相连的节点编号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;离%d\n&quot;</span>,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="24-图">2.4. 图</span></h3><ul>
<li>对图深搜会形成DFS树，因为图可能带环，所以需要开状态数组存储每个节点的访问状态，当访问状态为true时这条边就没必要走了，所以环中的某些边在dfs的过程中会被去掉，最终形成DFS树</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322210753384.png" alt="image-20240322210753384"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240322210804032.png" alt="image-20240322210804032"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="comment">// 入</span></span><br><span class="line">	vis[u]=<span class="literal">true</span>; <span class="comment">// 当前节点被访问过</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u]) &#123;</span><br><span class="line">		<span class="comment">// 下</span></span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>; <span class="comment">// 如果遍历过了就跳过</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d→%d\n&quot;</span>,u,v);</span><br><span class="line">		dfs(v);</span><br><span class="line">		<span class="comment">// 回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		e[a].push_back(b);</span><br><span class="line">		e[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-例题">3. 例题</span></h2><h3><span id="31-洛谷-p1605-迷宫">3.1. 洛谷 P1605 迷宫</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1605">P1605 迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240323154212768.png" alt="image-20240323154212768"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 偏移量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,t; <span class="comment">// 地图行数列数,障碍数</span></span><br><span class="line"><span class="type">int</span> sx,sy,fx,fy,x,y; <span class="comment">// 起点和终点坐标以及障碍坐标</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 地图最大为5×5,O(2^25)实际会小很多</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前所在位置(x,y)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="comment">// 1)边界条件</span></span><br><span class="line">	<span class="keyword">if</span>(x==fx &amp;&amp; y==fy) &#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2)试探</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> xx=x+dx[i];</span><br><span class="line">		<span class="type">int</span> yy=y+dy[i];</span><br><span class="line">		<span class="comment">// 3)约束条件</span></span><br><span class="line">		<span class="keyword">if</span>(xx&lt;<span class="number">1</span> || yy&lt;<span class="number">1</span> || xx&gt;n || yy&gt;m) <span class="keyword">continue</span>; <span class="comment">// 越界处理</span></span><br><span class="line">		<span class="keyword">if</span>(g[xx][yy]==<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 有障碍或者访问过了</span></span><br><span class="line">		<span class="comment">// 能走,占据方案,递归到下一层</span></span><br><span class="line">		g[xx][yy]=<span class="number">1</span>;</span><br><span class="line">		dfs(xx,yy);</span><br><span class="line">		g[xx][yy]=<span class="number">0</span>; <span class="comment">// 4)回溯,找所有方案</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		g[x][y]=<span class="number">1</span>; <span class="comment">// 回溯时不会去掉标记</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 起点打标记</span></span><br><span class="line">	g[sx][sy]=<span class="number">1</span>; <span class="comment">// 提前打上的标记回溯时不会去掉,只有dfs中的会去掉</span></span><br><span class="line">	dfs(sx,sy);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-洛谷-p1644-跳马问题">3.2. 洛谷 P1644 跳马问题</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1644">P1644 跳马问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 马走日,原本8个方向,但是只能往右走,所以dy必须&gt;0</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">18</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 终点</span></span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="comment">// 1)边界条件,到达终点</span></span><br><span class="line">	<span class="keyword">if</span>(x==n &amp;&amp; y==m) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2)试探</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="type">int</span> xx=x+dx[i];</span><br><span class="line">		<span class="type">int</span> yy=y+dy[i];</span><br><span class="line">		<span class="comment">// 3)约束条件</span></span><br><span class="line">		<span class="comment">// 越界处理</span></span><br><span class="line">		<span class="keyword">if</span>(xx&lt;<span class="number">0</span> || yy&lt;<span class="number">0</span> || xx&gt;n || yy&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 注意本题限制了方向只能往右走,所以不存在往回走的情况</span></span><br><span class="line">		<span class="comment">// 不需要状态数组</span></span><br><span class="line">		dfs(xx,yy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; <span class="comment">// 注意右上角是(m,n),即行是n,列是m</span></span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="33-洛谷-p1219-八皇后">3.3. 洛谷 P1219 八皇后</span></h3><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/P1219">P1219 USACO1.5 八皇后 Checker Challenge - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13</span>+<span class="number">5</span>; <span class="comment">// 棋盘最大范围</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 棋盘大小</span></span><br><span class="line"><span class="type">int</span> x[N]; <span class="comment">// x[i]:第i个皇后(第i行上的皇后)所在的列数</span></span><br><span class="line"><span class="comment">//int g[N][N]; // 地图,不需要地图嗷</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看第u个皇后是否能放,与前u-1个皇后作比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=u<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		<span class="comment">// 剪枝函数,若不在同一列或同一对角线</span></span><br><span class="line">		<span class="keyword">if</span>(x[u]==x[i] || <span class="built_in">abs</span>(u-i)==<span class="built_in">abs</span>(x[u]-x[i])) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能放</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 能放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前在放第u个皇后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">	<span class="comment">// 1)边界条件</span></span><br><span class="line">	<span class="keyword">if</span>(u&gt;n) &#123;</span><br><span class="line">		<span class="comment">// 皇后放完了,找到可行解了,直接输出</span></span><br><span class="line">		<span class="comment">// 只输出前3个</span></span><br><span class="line">		<span class="keyword">if</span>(++idx&lt;=<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;x[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2)试探,遍历所有可放的列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 3)如果能和前u-1行的皇后不冲突,则占据,向下递归</span></span><br><span class="line">		x[u]=i;</span><br><span class="line">		<span class="keyword">if</span>(place(u)) dfs(u+<span class="number">1</span>);</span><br><span class="line">		x[u]=<span class="number">0</span>; <span class="comment">// 4)释放,状态复原 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	dfs(<span class="number">1</span>); <span class="comment">// 从第一个皇后开始放</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>图论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/2024/10/03/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="离散化">离散化</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E6%A6%82%E8%BF%B0">0. 概述</a></li>
<li><a href="#1-%E7%A6%BB%E6%95%A3%E5%8C%96">1. 离散化</a><ul>
<li><a href="#11-%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%88%86">1.1. 基于二分</a></li>
<li><a href="#12-%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8">1.2. 基于哈希表</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="0-概述">0. 概述</span></h2><ul>
<li><p>上篇博客我们介绍了桶结构，假设现在给我们一个序列，数据范围是$[-10^9,10^9]$，显然我们是不能再用一个数组来存的</p>
</li>
<li><p>所以现在需要做的就是把大范围的数据映射到小范围数据，如：将$-123456789$映射到$5$，那么$a[5]&#x3D;-123456789$，统计的时候直接$cnt[3]++$即可，这便是离散化</p>
</li>
<li><p>怎么快速的映射，并且让映射的数字相互之间不冲突？<br><strong>排序加去重，使序列升序的排到数组中</strong></p>
</li>
<li><p>怎么找到映射后的数字在映射数组的下标？</p>
<p><strong>二分（已经排序了）、哈希表</strong></p>
</li>
</ul>
<h2><span id="1-离散化">1. 离散化</span></h2><blockquote>
<p> 题目链接：<a href="https://www.acwing.com/problem/content/804/">802. 区间和 - AcWing题库</a></p>
</blockquote>
<ul>
<li>该题目的数据范围很大，但是数据的总数又比较小，在数轴上非常稀疏，并且如果用枚举的方式求区间和必定会超时，所以非常适合用离散化的思想来解决</li>
</ul>
<h3><span id="11-基于二分">1.1. 基于二分</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 必须要用离散化</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+10</span>; <span class="comment">// max(n+2m)=3e5,假设每次输入的值都不同,最大也才3e5个空间</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// n次在x位置上加c的操作,m次查询区间[l,r]所有数的和</span></span><br><span class="line"><span class="type">int</span> x,c;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 存储数字</span></span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alls:需要离散化的数组,在插入和查询过程中把需要离散化的坐标添加进来</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储插入和查询操作中遇到的所有唯一坐标,然后排序用于索引</span></span><br><span class="line">vector&lt;PII&gt; add,query; <span class="comment">// 存储插入和查询操作的二元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找第一个大于等于x的下标,答案在左边,因此需要用二分的第二个模板(压缩右边界)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(alls[mid]&gt;=x) </span><br><span class="line">			r=mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l=mid<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r<span class="number">+1</span>; <span class="comment">// 返回的是顺序而不是下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;c);</span><br><span class="line">		add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x); <span class="comment">// 需要离散化的数值大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">		<span class="comment">// 区间也需要离散化</span></span><br><span class="line">		alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离散化:先排序后去重(因为可能有多个操作在同一个点上)</span></span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 去重,unique去除范围内的重复元素并返回新数组的末尾位置</span></span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 执行前n次插入操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:add) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">find</span>(item.first); <span class="comment">// 找到离散化后的下标</span></span><br><span class="line">		a[x]+=item.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用映射后的地址求一次前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) </span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	<span class="comment">// 执行后m次询问区间和操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:query) &#123;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">find</span>(item.first);</span><br><span class="line">		<span class="type">int</span> r=<span class="built_in">find</span>(item.second);</span><br><span class="line">		cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">7 5</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">7 8</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>



<h3><span id="12-基于哈希表">1.2. 基于哈希表</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 二分查询下标的时间是O(nlogn),而哈希表只需要O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x,c;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 所有需要离散化处理的数值</span></span><br><span class="line">vector&lt;PII&gt; add,query; <span class="comment">// 存储插入操作和区间和查询操作的向量</span></span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">// 哈希表(注意手写哈希表更快)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],s[N]; <span class="comment">// 映射后的数组和前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;c);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">		add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 离散化</span></span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 映射到下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=alls.<span class="built_in">size</span>()<span class="number">-1</span>;i++) &#123;</span><br><span class="line">		mp[alls[i]]=i<span class="number">+1</span>; <span class="comment">// 映射到从下标1开始</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行n次add操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:add) &#123;</span><br><span class="line">		<span class="type">int</span> x=mp[item.first];</span><br><span class="line">		a[x]+=item.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用映射后的值计算前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行m次查询操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item:query) &#123;</span><br><span class="line">		l=mp[item.first];</span><br><span class="line">		r=mp[item.second];</span><br><span class="line">		cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数论</title>
    <url>/2024/10/07/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="简单数论">简单数论</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E8%B4%A8%E6%95%B0%E7%AD%9B">1. 质数筛</a></li>
<li><a href="#2-%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8B%86">2. 进制数拆</a></li>
<li><a href="#3-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0">3. 分解质因数</a></li>
<li><a href="#4-%E8%B4%A8%E6%95%B0%E7%AD%9B">4. 质数筛</a><ul>
<li><a href="#41-%E8%AF%95%E9%99%A4%E6%B3%95%E6%9E%9A%E4%B8%BE%E4%BC%98%E5%8C%96">4.1. 试除法（枚举优化）</a></li>
<li><a href="#42-%E6%AC%A7%E6%8B%89%E7%AD%9B">4.2. 欧拉筛</a></li>
</ul>
</li>
<li><a href="#5-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">5. 最大公约数与最小公倍数</a><ul>
<li><a href="#51-%E4%B8%A4%E4%B8%AA%E6%95%B0">5.1. 两个数</a></li>
<li><a href="#52-n%E4%B8%AA%E6%95%B0">5.2. n个数</a><ul>
<li><a href="#521-%E6%B1%82%E5%85%AC%E5%85%B1gcd">5.2.1. 求公共GCD</a></li>
<li><a href="#522-%E6%B1%82%E5%85%AC%E5%85%B1lcm">5.2.2. 求公共LCM</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-质数筛">1. 质数筛</span></h2><blockquote>
<p>先从最简单的质数开始吧，用优化遍历大小的朴素法或者欧拉筛(线性筛)可以完成，时间复杂度分别是O(n)和O(logn)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 最小的质数是2</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-进制数拆">2. 进制数拆</span></h2><blockquote>
<p>比如把任意一个正整数拆成二进制表现的形式，如7&#x3D;2的2次方+2的1次方+2的0次方</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n:待拆分十进制数</span></span><br><span class="line"><span class="comment">// m:拆分成多少进制的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>; <span class="comment">// 权</span></span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%m) &#123;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;<span class="string">&#x27;^&#x27;</span>&lt;&lt;s&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;<span class="built_in">pow</span>(m,s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			v.<span class="built_in">push_back</span>(<span class="built_in">pow</span>(m,s));</span><br><span class="line">		&#125;</span><br><span class="line">		n/=m;</span><br><span class="line">		s++;</span><br><span class="line">	&#125; cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		cout&lt;&lt;v[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=v.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;+&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-分解质因数">3. 分解质因数</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 分解质因数,一边找质因子一边将质因子的值和幂存储起来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[]:存储质因子,p[cnt]=x,第cnt个质因子是x</span></span><br><span class="line"><span class="comment">// g[]:存储质因子的幂,g[cnt]=y,第cnt个质因子是x,幂是y</span></span><br><span class="line"><span class="comment">// cnt:记录个数</span></span><br><span class="line"><span class="type">int</span> n,p[N],g[N],cnt; </span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime_fact</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i*i&lt;=n:枚举优化,从2开始,2是最小的质数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>) cnt++; <span class="comment">// i是n的因子,cnt++</span></span><br><span class="line">		<span class="comment">// 计算i的幂</span></span><br><span class="line">		<span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">			p[cnt]=i;</span><br><span class="line">			g[cnt]++; <span class="comment">// 次幂+1</span></span><br><span class="line">			n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分解完后如果n&gt;1,说明最终剩下的数字是一个质数,也单独算成质因数</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">		p[++cnt]=n;</span><br><span class="line">		g[cnt]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">prime_fact</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;质因数: %d, 幂为:%d\n&quot;</span>,p[i],g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 按唯一分解定理形式打印</span></span><br><span class="line">	cout&lt;&lt;n&lt;&lt;<span class="string">&quot;=&quot;</span>;</span><br><span class="line">	<span class="comment">// 遍历p,g数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="comment">// 打印g[i]次p[i]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=g[i];j++) &#123;</span><br><span class="line">			cout&lt;&lt;p[i];</span><br><span class="line">			<span class="keyword">if</span>(j!=g[i]) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(i!=cnt) cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-质数筛">4. 质数筛</span></h2><h3><span id="41-试除法枚举优化">4.1. 试除法（枚举优化）</span></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(num)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要找从 $[1,10000]$ 中的所有质数，时间复杂度很高</li>
</ul>
<h3><span id="42-欧拉筛">4.2. 欧拉筛</span></h3><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20230720102317937.png" alt="image-20230720102317937"></p>
<ul>
<li>算法思想：遍历到 $2$ 的时候，筛掉范围内所有 $2$ 的倍数，到 $3$ 的时候，筛掉所有 $3$ 的倍数，被筛掉的数会被标记为合数，合数不会进入到 $if$ 中扩展其倍数，相当于每个数只被遍历过一次，因而时间复杂度是 $O(n)$，欧拉筛也被称为线性筛</li>
<li>注意：如果计算 $[l,r]$ 之间出现的质数的个数？可以用前缀和的思想；<br>当 $n$ 过大时，$i×i$ 容易出现数组越界的错误，即可能 $RuntimeError$，此时要将线性筛中第二个 $for$ 中的$j&#x3D;i×i$ 改为 $j&#x3D;i+i$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 欧拉筛</span></span><br><span class="line"><span class="comment">  先从最小的质数开始,每次在数据范围内将它的倍数标记为合数,那么留下的一定是素数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// f[i]:记录1~i中所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]:i的访问状态</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存放1~n中所有素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx:找素数迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i未放问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]<span class="number">+1</span>; <span class="comment">// 计算前缀和,维护数量</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 存储素数</span></span><br><span class="line">			<span class="comment">// 如果出现RE,将j=i*i改成j=i+i,这样就不会越界</span></span><br><span class="line">			<span class="comment">// 将i的倍数全部标记为合数,无需遍历</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">get_primes</span>(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1~%d 之间的质数分别是:&quot;</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=idx;i++) &#123;</span><br><span class="line">		cout&lt;&lt;p[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=idx) cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">	&#125; cout&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d~%d 之间存在的质数个数是:%d\n&quot;</span>,l,r,f[r]-f[l<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="5-最大公约数与最小公倍数">5. 最大公约数与最小公倍数</span></h2><blockquote>
<p>辗转相除法的时间复杂度：近似 $O(max(a,b))$</p>
</blockquote>
<h3><span id="51-两个数">5.1. 两个数</span></h3><ul>
<li>辗转相除法（欧几里得算法）求解最大公约数，最小公倍数就是两数的成绩除以最大公约数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求两个数的最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>(m%n) &#123;</span><br><span class="line">		r=m%n;</span><br><span class="line">		m=n;</span><br><span class="line">		n=r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简单易背的方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两数的最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCM</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m*n/<span class="built_in">GCD</span>(m,n);	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3><span id="52-n个数">5.2. n个数</span></h3><h4><span id="521-求公共gcd">5.2.1. 求公共GCD</span></h4><ul>
<li>求多个数的 $GCD$ 的思路是先求两个数的 $GCD$，再用这个结果与后续的每一个数分别求出 $GCD$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过循环求出公共GCD</span></span><br><span class="line">	<span class="type">int</span> res=a[<span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=gcd(res,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述求解方法的时间复杂度最坏是 $O(n^2)$，所以数据量比较大时，推荐用下述方法求解公共 $GCD$</li>
</ul>
<ol>
<li><p>对这组数从大到小排序</p>
</li>
<li><p>对每两个相邻的数 $A,B$（假设 $A$ 在前，故有 $A&gt;B$），如果 $A&#x3D;n×B$，则令 $A&#x3D;B$；否则令 $A&#x3D;A%B$</p>
</li>
<li><p>重复上述步骤，直到数组中每个数字都相同，此时这个数就为公共 $GCD$</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi_gcd</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 直到所有数字相等</span></span><br><span class="line">	<span class="keyword">while</span>(a[<span class="number">1</span>]!=a[n]) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]%a[i+<span class="number">1</span>]==<span class="number">0</span>) a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> a[i]=a[i]%a[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="522-求公共lcm">5.2.2. 求公共LCM</span></h4><ul>
<li>同样的，我们可以对这组数据依次求最小公倍数，但是时间复杂度在最坏时达到 $O(n^2)$</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">multi_lcm</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		res=res*a[i]/gcd(res,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接下来介绍质因子分解法，如：求 $10,12,4$ 的最小公倍数<br>$① 10&#x3D;2×5,\ ② 12&#x3D;2×3×3,\ ③4&#x3D;2×2$<br>可见，$2$ 在①②③式中都出现了， $3$ 只在②式中出现， $5$ 只在①式中出现<br>所以最小公倍数：$2^3×3^1×5^1&#x3D;60$，即对每个质因子的最高次幂做乘积得到的就是公共 $LCM$</p>
</li>
<li><p>用这种方法也可以避免遍历时做乘法超出数据类型所能表示的最大范围的情况</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 求公共LCM</span></span><br><span class="line"><span class="comment">  1) 先用欧拉筛预处理出数据范围内所有质数</span></span><br><span class="line"><span class="comment">  2) 将数组a中的数字依次分解质因数,按照欧拉筛筛出来的质数分解</span></span><br><span class="line"><span class="comment">  3) 用一个map记录所有质因子出现的最小次数(计算GCD)或最大次数(计算LCM)</span></span><br><span class="line"><span class="comment">  4) 枚举map中的质因子及其出现次数乘在一起算出GCD和LCM即可</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// f[i]:记录1~i中所有质数的数量</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]:i的访问状态</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存放1~n中所有素数</span></span><br><span class="line"><span class="type">int</span> idx,n; <span class="comment">// idx:找素数迭代器 </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m_max; <span class="comment">// m_max[i]:对a[i]进行质因数分解后每个质因数的最大次数</span></span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果i未放问过</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>; <span class="comment">// 计算前缀和,维护数量</span></span><br><span class="line">			p[++idx]=i; <span class="comment">// 存储素数</span></span><br><span class="line">			<span class="comment">// 如果出现RE,将j=i*i改成j=i+i,这样就不会越界</span></span><br><span class="line">			<span class="comment">// 将i的倍数全部标记为合数,无需遍历</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>]; <span class="comment">// 向下传递素数个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_facts</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 对于数组a中的每一个数字,分解质因数,计算在这n个数中的最大次数	</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=idx;j++) &#123;</span><br><span class="line">			<span class="comment">// 剪枝,如p[j]×p[j]&gt;a[i],说明p[j]不可能为a[i]质因数</span></span><br><span class="line">			<span class="keyword">if</span>(p[j]*p[j]&gt;a[i]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 遍历质数数组</span></span><br><span class="line">			<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 分解后p[i]的次数</span></span><br><span class="line">			<span class="keyword">while</span>(a[i]%p[j]==<span class="number">0</span>) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				a[i]/=p[j];</span><br><span class="line">			&#125;</span><br><span class="line">			m_max[p[j]]=max(m_max[p[j]],cnt); <span class="comment">// 更新质因数p[i]出现的最大次数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 本身是质数</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			m_max[a[i]]=<span class="number">1</span>; <span class="comment">// 次幂只能为1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];	</span><br><span class="line">	&#125;</span><br><span class="line">	get_primes(<span class="number">1000</span>);</span><br><span class="line">	get_facts(a);</span><br><span class="line">	<span class="comment">// 打印测试</span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it=m_max.begin();it!=m_max.end();it++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=it-&gt;second;i++) &#123;</span><br><span class="line">			res*=(it-&gt;first);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 公共LCM</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例:</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">12 24 30 32 36 42</span></span><br><span class="line"><span class="comment">输出样例:</span></span><br><span class="line"><span class="comment">10080</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心区间问题</title>
    <url>/2024/10/05/%E8%B4%AA%E5%BF%83%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">



<h1><span id="贪心区间问题">贪心区间问题</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9">1. 最大不相交区间数（区间选点）</a></li>
<li><a href="#2-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84">2. 区间分组</a></li>
<li><a href="#3-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96">3. 区间覆盖</a></li>
<li><a href="#4-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">4. 区间合并</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>以下例题来自于AcWing 906~908</p>
</blockquote>
<h2><span id="1-最大不相交区间数区间选点">1. 最大不相交区间数（区间选点）</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240307214934220.png" alt="image-20240307214934220"></p>
<ul>
<li>翻译一下题目吧<ol>
<li>最大不相交区间数：也就是说给定$N$个闭区间，问能从中选出多少个区间使其互不相交（同活动安排问题）</li>
<li>区间选点：给定 $N$ 个区间，在数轴上选择尽量少的点，使每个区间至少包含一个选出的点（同整数区间问题：找到一个含元素个数最少的集合，使对每一个区间都至少有一个整数属于该集合，输出该集合的元素个数）</li>
<li>为什么这两个问题其实是同一个问题？观察下方图像，在找不相交区间的时候其实就是把 $N$ 个区间划分成 $M$ 个集合，从这 $M$ 个集合中分别选出一个区间，那么这 $M$ 个集合是一定不相交的，此时 $M$ 就是答案，区间选点中点的个数其实就是集合的个数，只要 $range[i].l&gt;last_r$ 就说明需要新开一个集合了，所以 $ans++$</li>
</ol>
</li>
<li>贪心策略：新建一个结构体存储区间的左端点和右端点，将这$N$个区间按照右端点从小到大排序（因为活动选择<strong>越早结束越好</strong>），遍历所有的区间，如果当前遍历到的区间左端点的值大于了上一个区间的右端点的值，说明此时区间没有重合，则区间个数$+1$</li>
<li>如果假设选的点都出现在区间的右端点，此时为了让每个区间都至少包含一个交点，就可以作图如下：</li>
</ul>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529204230868.png" alt="image-20240529204230868"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 活动安排+最大不相交区间+区间选点 </span></span><br><span class="line"><span class="comment">  1) 用一个变量记录上一个区间右端点,把所有区间依据区间右端点从小到大排序</span></span><br><span class="line"><span class="comment">  2) 如果某个区间的左端点＞上一个区间右端点,则选点数+1,或不相交区间的个数+1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l; </span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N]; <span class="comment">// 每个区间有左右端点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照右端点从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Range a,Range b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> front_r=INT_MIN; <span class="comment">// 保证至少有一个集合,即range[i].l一定比初始front_r大 </span></span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n,cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以定义res=1,front_r=(sorted)range[1].r,下面的for循环从i=2开始</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(range[i].l&gt;front_r) &#123;</span><br><span class="line">			front_r=range[i].r; <span class="comment">// 更新右端点</span></span><br><span class="line">			res++; <span class="comment">// 点数+1</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/solution/P1250">P1250 种树 - 洛谷 </a></p>
</blockquote>
<ul>
<li>题目大意：在区间 $[a,b]$ 内至少种 $c$ 棵树，问树最少的个数</li>
<li>解题思路：<ul>
<li>即让尽可能多的树同时在多个区间出现，对每个区间先统计已有树的数量，如果不足 $c$ 棵则补差</li>
<li>为了让树尽可能能被下一个区间用上，补差时应当从末尾补差</li>
<li>因为每个坐标点只能种一棵树，所以还需要一个状态数组 $st$ 辅助存储</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: </span></span><br><span class="line"><span class="comment">  1) 要在[a,b]种至少c棵树,树最少,即让尽可能多的树同时在多个区间出现,再对多个区间补差</span></span><br><span class="line"><span class="comment">  2) 在补差的时候一定要补在该区间的尾部,因为这样是最后可能让下一个区间用上的</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> n; <span class="comment">// 树的个数</span></span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> used[N]; <span class="comment">// 判断是否已经有树了(一个点不能种两棵树)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Range a,Range b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r; <span class="comment">// 按右端点从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;range[i].l,&amp;range[i].r,&amp;range[i].n); 	</span><br><span class="line">	&#125;</span><br><span class="line">	sort(range+<span class="number">1</span>,range+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>; <span class="comment">// 存储该区间内已有的树的个数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=range[i].l;j&lt;=range[i].r;j++) <span class="keyword">if</span>(used[j]) k++;</span><br><span class="line">		<span class="comment">// 1) 已满足range[i].n棵树则退出</span></span><br><span class="line">		<span class="keyword">if</span>(k&gt;=range[i].n) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 2) 不满足,则需要补差,补差需要从末尾补,最有可能给下一个区间用</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=range[i].r;j&gt;=range[i].l;j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!used[j]) &#123;</span><br><span class="line">				used[j]=<span class="literal">true</span>;</span><br><span class="line">				k++;</span><br><span class="line">				ans++; <span class="comment">// 树的数量只在此处增加,即所有的树其实都是从末尾补的</span></span><br><span class="line">				<span class="keyword">if</span>(k==range[i].n) <span class="keyword">break</span>; <span class="comment">// 已够n棵</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-区间分组">2. 区间分组</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240308190931030.png" alt="image-20240308190931030"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529205928100.png" alt="image-20240529205928100"></p>
<ul>
<li>翻译一下题目，现在有$N$个区间，问最少分多少组，能让这些分组中的所有区间两两之间包括端点都没有交集</li>
<li>贪心策略：将所有区间按照左端点从小到大排序，从前往后处理每个区间，判断是否能把这个区间放到现有的某个分组中，即判断 $range[i].l \ &gt; \ 某一分组最大右端点$<ol>
<li>如果存在这样的分组（与某个分组间没有交集），则将区间 $ i $ 放进去，并且更新这个分组的最大右端点（注意，如果与多个分组都有交集则可以放到任意一个分组中，不影响结果，可自行模拟证明）</li>
<li>如果不存在这样的分组（与每个分组间都有交集），则开一个新组，再把区间 $i$ 放进去</li>
<li>在判断当前区间是否与某一分组有交集时，只需要与所有分组中最小的分组最大右端点进行比较即可，因为这是最有可能满足 $range[i].l \ &gt; \ 某一分组最大右端点$ 的情况，对于所有分组中最小的分组最大右端点，只需要用一个小根堆来维护即可</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: </span></span><br><span class="line"><span class="comment">  1) 先将所有区间按照左端点从小到大排序</span></span><br><span class="line"><span class="comment">  2) 用优先队列维护所有分组的整体右端点的最小值,因为在遍历区间时需要用range[i].l与所有分组的max_r比较,而min(max_r)是最容易比range[i].l小的,即最容易插入该分组中</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Range a,Range b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 按照左端点从小到大排序</span></span><br><span class="line">	<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 维护每个分组的最右边界的最小值</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 枚举区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 如果每个分组的最小的max_r都比当前区间左端点大</span></span><br><span class="line">		<span class="comment">// 说明与每个分组中的区间都要产生交集,则不能放入任何分组</span></span><br><span class="line">		<span class="comment">// 此时新开一个分组</span></span><br><span class="line">		<span class="keyword">if</span>(pq.<span class="built_in">empty</span>() || pq.<span class="built_in">top</span>()&gt;=range[i].l) &#123;</span><br><span class="line">			pq.<span class="built_in">push</span>(range[i].r); <span class="comment">// 新开分组,保存右端点</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果无交集,此时可以放进这个分组中</span></span><br><span class="line">			<span class="comment">// 并维护所有分组中最大右端点的最小值</span></span><br><span class="line">			pq.<span class="built_in">pop</span>();</span><br><span class="line">			pq.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 小根堆的大小就是分组的个数</span></span><br><span class="line">	cout&lt;&lt;pq.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-区间覆盖">3. 区间覆盖</span></h2><p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240308203244259.png" alt="image-20240308203244259"></p>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240529211220012.png" alt="image-20240529211220012"></p>
<ul>
<li>翻译一下题目，···，这道题没什么可翻译的</li>
<li>贪心策略：将所有区间按照左端点从小到大排序，从前往后依次枚举每个区间，在所有能覆盖 $start$ 的区间中选择一个右端点最大的区间，然后将 $start$ 更新成为右端点的最大值，继续向后覆盖，如果所有区间都遍历过了但并没有覆盖到 $end$ 的话说明无法完全覆盖，则输出 $-1$</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 对区间按照左端点从小到大排序,因为每次都要保证覆盖start</span></span><br><span class="line"><span class="comment">  再从满足覆盖start的区间中选出右端点最大的,这样就能保证覆盖线段的区间数最小</span></span><br><span class="line"><span class="comment">  再更新start的值,如果遍历完所有区间能使start&gt;=end,则可覆盖,输出区间数</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// 重载运算符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> st,en;</span><br><span class="line">	cin&gt;&gt;st&gt;&gt;en;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(range<span class="number">+1</span>,range<span class="number">+1</span>+n);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="comment">// 统计区间数</span></span><br><span class="line">	<span class="type">bool</span> flag=<span class="literal">false</span>; <span class="comment">// 是否能覆盖完整个区间</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历所有区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// front_r:当前覆盖到的区域</span></span><br><span class="line">		<span class="comment">// j:每次从第i个区间后开始找</span></span><br><span class="line">		<span class="type">int</span> j=i,front_r=INT_MIN;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=n &amp;&amp; range[j].l&lt;=st) &#123;</span><br><span class="line">			front_r=<span class="built_in">max</span>(front_r,range[j].r); <span class="comment">// 找最大的右端点</span></span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果最大的front_r仍小于st,说明线段不可被已有区间覆盖</span></span><br><span class="line">		<span class="keyword">if</span>(front_r&lt;st) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 如果找得到,区间数+1</span></span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="comment">// 已经完全覆盖线段</span></span><br><span class="line">		<span class="keyword">if</span>(front_r&gt;=en) &#123;</span><br><span class="line">			flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则更新i和j</span></span><br><span class="line">		st=front_r; <span class="comment">// 迭代st,后面的区间继续和st比</span></span><br><span class="line">		i=j<span class="number">-1</span>; <span class="comment">// 双指针,加速遍历</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(!flag) cnt=<span class="number">-1</span>;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-区间合并">4. 区间合并</span></h2><ul>
<li>题目最简单的一集，$N$ 个区间，端点重叠也可合并，求合并后的区间数量和左右端点</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  解题思路: 区间合并,端点也算重叠,将有重叠的区间合并后输出</span></span><br><span class="line"><span class="comment">  1) 区间按左端点从小到大排序,有重叠则合并更新区间右端点</span></span><br><span class="line"><span class="comment">  2) range数组一个存储合并前的区间,一个存储合并后的区间,最后遍历输出即可</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// range:原区间,ans:合并后区间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> l;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">&#125;range[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接return a.l&lt;b.l ,如果右端点也从小到大排序则合并次数多了,常数反而大了</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Range a,Range b)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.l!=b.l) <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">	<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		range[i]=&#123;l,r&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(range+<span class="number">1</span>,range+<span class="number">1</span>+n,cmp);</span><br><span class="line">	<span class="comment">// 枚举所有区间进行合并</span></span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	ans[++cnt]=range[<span class="number">1</span>]; <span class="comment">// 结构体之间等价赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="comment">// 可合并</span></span><br><span class="line">		<span class="keyword">if</span>(range[i].l&lt;=ans[cnt].r) &#123;</span><br><span class="line">			ans[cnt].r=max(ans[cnt].r,range[i].r); <span class="comment">// 更新右端点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不可合并,开新区间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ans[++cnt]=range[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 区间个数</span></span><br><span class="line">	<span class="comment">// 输出合并后的区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans[i].l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans[i].r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2024/10/02/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="进制转换">进制转换</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E5%B8%B8%E7%94%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C-%E5%85%AB-%E5%8D%81-%E5%8D%81%E5%85%AD">1. 常用转换（二、八、十、十六）</a></li>
<li><a href="#2-%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%9C%80%E9%AB%98%E4%B8%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0">2. 任意进制（最高三十六进制）转换为十进制数</a></li>
<li><a href="#3-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%95%B0%E6%9C%80%E9%AB%98%E4%B8%89%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6">3. 十进制数转换为任意进制数（最高三十六进制）</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-常用转换二-八-十-十六">1. 常用转换（二、八、十、十六）</span></h2><blockquote>
<p>$C++$ 中常见进制数</p>
</blockquote>
<ul>
<li>$%d$ ：十进制数</li>
<li>$%x$ ：十六进制数</li>
<li>$%o$ ：八进制数</li>
<li>$%b$ ：二进制数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 十进制转换为其他常用进制</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">	cin&gt;&gt;dec&gt;&gt;n;</span><br><span class="line">	<span class="function">bitset&lt;20&gt; <span class="title">bt</span><span class="params">(n)</span></span>; <span class="comment">// 转换成二进制(最大20位)</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;2进制:&quot;</span>&lt;&lt;bt&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;8进制:&quot;</span>&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;16进制:&quot;</span>&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;16进制(字母大写输出):&quot;</span>&lt;&lt;hex&lt;&lt;<span class="built_in">setiosflags</span>(ios::uppercase)&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 同理,其他常用进制可以互相转换</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">	cin&gt;&gt;hex&gt;&gt;x;</span><br><span class="line">	<span class="function">bitset&lt;20&gt; <span class="title">bt1</span><span class="params">(x)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;2进制:&quot;</span>&lt;&lt;bt1&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;8进制:&quot;</span>&lt;&lt;oct&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;10进制:&quot;</span>&lt;&lt;dec&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-任意进制最高三十六进制转换为十进制数">2. 任意进制（最高三十六进制）转换为十进制数</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// 任何进制数转换为十进制数</span></span><br><span class="line"><span class="comment">// s:这个任意进制数的字符串形式</span></span><br><span class="line"><span class="comment">// R:这个字符串当前的进制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Atoi</span><span class="params">(<span class="built_in">string</span> s,<span class="type">int</span> R)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">			res=res*R+s[i]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 每次*=R升权</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">			res=res*R+s[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">10</span>; <span class="comment">// 因为A表示10</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Atoi(<span class="string">&quot;ZDBAEFEA&quot;</span>,<span class="number">36</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Atoi(<span class="string">&quot;100&quot;</span>,<span class="number">16</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-十进制数转换为任意进制数最高三十六进制">3. 十进制数转换为任意进制数（最高三十六进制）</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转换为任意进制</span></span><br><span class="line"><span class="comment">// num:这个十进制的数</span></span><br><span class="line"><span class="comment">// R:要转换成多少进制</span></span><br><span class="line"><span class="function">string <span class="title">Itoa</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="type">int</span> rmd; <span class="comment">// 记录每次做除法的余数</span></span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">0</span>) str=<span class="string">&quot;0&quot;</span>; <span class="comment">// 特判任意进制的0</span></span><br><span class="line">	<span class="keyword">while</span>(num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		rmd=num%R; <span class="comment">// 每次对R取余,可以类比一下十进制转二进制</span></span><br><span class="line">		ch=(rmd&lt;<span class="number">10</span>)?(rmd+<span class="string">&#x27;0&#x27;</span>):(rmd<span class="number">-10</span>+<span class="string">&#x27;A&#x27;</span>); <span class="comment">// 小于10表示为[0,9],否则减去10+&#x27;A&#x27;</span></span><br><span class="line">		str=ch+str; <span class="comment">// 字符串拼接</span></span><br><span class="line">		num/=R;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里按照题目要求补前导0等操作</span></span><br><span class="line">	<span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">1</span>) str=<span class="string">&quot;0&quot;</span>+str; </span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Itoa</span>(<span class="number">196</span>,<span class="number">16</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接矩阵</title>
    <url>/2024/10/04/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="邻接矩阵">邻接矩阵</span></h1><!-- toc -->

<ul>
<li><a href="#0-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5">0. 邻接矩阵</a></li>
<li><a href="#1-%E6%B4%9B%E8%B0%B73643-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8">1. 洛谷3643 图的存储</a></li>
</ul>
<!-- tocstop -->

<h2><span id="0-邻接矩阵">0. 邻接矩阵</span></h2><ul>
<li>邻接矩阵相比于上一篇博客邻接表的讲解要简单得多</li>
</ul>
<ol>
<li>数据结构，如果将二维数组 $g$ 定义为全局变量，那默认初始化应该为 $0$ ，如果题目中存在自环，可以做特判，$memset$ 初始化数组 $g$ 为 $0x3f3f3f3f$ 表示无穷大，$0$ 表示自环</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的度</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>以下模板是无向图的邻接矩阵模板，如果改成有向图，和邻接表一样，不需要对称建边，比如有一条边是 $(1,3)$，则 $d[1]++,\ g[1][3]&#x3D;1 $ 即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入边</span></span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="comment">// 邻接矩阵建边</span></span><br><span class="line">    d[u]++,d[v]++; <span class="comment">// 顶点u和顶点v度数+1</span></span><br><span class="line">    g[u][v]=<span class="number">1</span>,g[v][u]=<span class="number">1</span>; <span class="comment">// 互相可达,为0表示不可达(如果题目涉及自环可用memset初始化为0x3f3f3f3f表示不可达)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整代码如下，注意代码采用无向图模板</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 图的存储-邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span>+<span class="number">5</span>)*<span class="number">2</span>; <span class="comment">// 无向图建边最大边数为题目最大边数*2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储每个顶点的度</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 假设题目编号默认从1开始</span></span><br><span class="line">	<span class="type">int</span> n,m; <span class="comment">// 存储顶点数和边数</span></span><br><span class="line">	<span class="comment">// 输入边</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="comment">// 邻接矩阵建边</span></span><br><span class="line">		d[u]++,d[v]++; <span class="comment">// 顶点u和顶点v度数+1</span></span><br><span class="line">		g[u][v]=<span class="number">1</span>,g[v][u]=<span class="number">1</span>; <span class="comment">// 互相可达,为0表示不可达(如果题目涉及自环可用memset初始化为0x3f3f3f3f表示不可达)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;g[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="1-洛谷3643-图的存储">1. 洛谷3643 图的存储</span></h2><blockquote>
<p>题目链接：<a href="https://www.luogu.com.cn/problem/B3643">B3643 图的存储 - 洛谷</a></p>
</blockquote>
<p><img src="https://gitee.com/RoysterCDD/figurebed/raw/master/img/image-20240309115736673.png" alt="image-20240309115736673"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+10</span>; <span class="comment">// 最大顶点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span><span class="number">+10</span>)*<span class="number">2</span>; <span class="comment">// 最大边数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 顶点数和边数</span></span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存度数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:编号i的顶点的</span></span><br><span class="line"><span class="type">int</span> ne[M];</span><br><span class="line"><span class="type">int</span> e[M];</span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 建树因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星(头插法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="comment">// 邻接矩阵建边</span></span><br><span class="line">		d[u]++,d[v]++; <span class="comment">// 度数+1</span></span><br><span class="line">		g[u][v]=<span class="number">1</span>,g[v][u]=<span class="number">1</span>; <span class="comment">// 互达</span></span><br><span class="line">		<span class="comment">// 邻接表建边</span></span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">		<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">			cout&lt;&lt;g[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历邻接表</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		cout&lt;&lt;d[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// 先输出点i的度数</span></span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=h[i];j!=<span class="number">-1</span>;j=ne[j]) &#123;</span><br><span class="line">			<span class="type">int</span> t=e[j];</span><br><span class="line">			s.<span class="built_in">push_back</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 编号从小到大排序</span></span><br><span class="line">		<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> t:s) cout&lt;&lt;t&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>递推</title>
    <url>/2024/10/03/%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="递推">递推</span></h1><!-- toc -->

<ul>
<li><a href="#%E4%B8%80%E6%9C%AC%E9%80%9A-1188%E8%8F%B2%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%972">一本通 1188：菲波那契数列(2)</a></li>
<li><a href="#%E4%B8%80%E6%9C%AC%E9%80%9A-1189pell%E6%95%B0%E5%88%97">一本通 1189：Pell数列</a></li>
<li><a href="#%E4%B8%80%E6%9C%AC%E9%80%9A-1190%E4%B8%8A%E5%8F%B0%E9%98%B6">一本通 1190：上台阶</a></li>
</ul>
<!-- tocstop -->

<h2><span id="一本通-1188菲波那契数列2">一本通 1188：菲波那契数列(2)</span></h2><blockquote>
<p>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1188">信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)</a></p>
</blockquote>
<ul>
<li>斐波那契数列问题我们经常用递归解决，但是本题由于数据范围比较大，所以递归层数会非常多，会遇到爆栈的问题，必定会TLE</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因此我们选择用递推解决，同时还有一个问题，题目要求的是菲波那契数列中第$a$个数对$1000$取模得到的结果，我们只需要在计算$Fibonacci$数列的时候一边计算一边对$1000$取模就可以了，这并不会最终结果</li>
<li>如果我们不一边计算一边取模，而是对单独我们要的那个值进行取模会遇到什么结果？在计算数列的时候就已经爆$int$、$long\ long$了，那么在累加求解的过程中就会溢出，最终得到的是负数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 想想能不能用递归做呢?不能,因为数据范围很大,递归会爆栈,一定会TLE</span></span><br><span class="line"><span class="comment">//int fib(int n) &#123;</span></span><br><span class="line"><span class="comment">//	if(n==1 || n==2) </span></span><br><span class="line"><span class="comment">//		return 1;</span></span><br><span class="line"><span class="comment">//	else </span></span><br><span class="line"><span class="comment">//		return (fib(n-1)+fib(n-2))%1000;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> fib[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="comment">// 预处理计算出所有的fib,再处理查询</span></span><br><span class="line">	<span class="comment">// 初始化:</span></span><br><span class="line">	fib[<span class="number">1</span>]=fib[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=N;i++) &#123;</span><br><span class="line">		fib[i]=(fib[i<span class="number">-1</span>]+fib[i<span class="number">-2</span>])%<span class="number">1000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line"><span class="comment">//		scanf(&quot;%d&quot;,&amp;temp);</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;fib(temp)%1000&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">// 用递推做法</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">		cout&lt;&lt;fib[temp]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="一本通-1189pell数列">一本通 1189：Pell数列</span></h2><blockquote>
<p>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1189">信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)</a></p>
</blockquote>
<ul>
<li>当作业咯</li>
</ul>
<h2><span id="一本通-1190上台阶">一本通 1190：上台阶</span></h2><blockquote>
<p>题目链接：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1190">信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)</a></p>
</blockquote>
<ul>
<li>其实这道题是动态规划中线性$DP$中非常经典的题目，非常适合新手初步接触动态规划类型题目，从动态规划的四要素来分析该问题</li>
</ul>
<ol>
<li>状态表示，$dp[i]$：到达第$i$步台阶的方案数</li>
<li>初始化，$dp[1]&#x3D;1$，到达台阶一的方案只有一种，那就是直接走一步，$dp[2]&#x3D;2$，到达台阶二的方案有两种，那就是走两个一步，或者直接走两步，$dp[3]&#x3D;4$，到达台阶三的方案有四种，要么走四个一步，要么走两个两步，要么先走两步，再走两个一步，要么先走两个一步，再走一个两步</li>
<li>状态转移，$dp[i]&#x3D;dp[i-1]+dp[i-2]+dp<a href="n%3E=3">i-3</a>$：到达第台阶$i$要么是从第$i-1$步台阶走一步上来的，要么是从第$i-2$步台阶走两步上来的，要么是从第$i-3$步台阶走三步上来的</li>
<li>目标值，要求到达第$n$步台阶方案数，所以直接输出$dp[n]$即可</li>
</ol>
<ul>
<li>注意就算最大台阶只有$70$步，但数据增长速度很快，所以需要开$long \ long$才能通过</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">70</span><span class="number">+5</span>; <span class="comment">// 最大台阶数</span></span><br><span class="line">ll dp[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	dp[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 预处理所有方案</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=N;i++) &#123;</span><br><span class="line">		dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]+dp[i<span class="number">-3</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>) &#123;</span><br><span class="line">		cout&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接表+链式前向星</title>
    <url>/2024/10/04/%E9%82%BB%E6%8E%A5%E8%A1%A8+%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="邻接表">邻接表</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E9%82%BB%E6%8E%A5%E8%A1%A8">1. 邻接表</a></li>
</ul>
<!-- tocstop -->

<h2><span id="1-邻接表">1. 邻接表</span></h2><ul>
<li>邻接表存储图需要注意的要点有：</li>
</ul>
<ol>
<li>模板采用的是无向图，所以最大边数 $M$ 开到了题目所给最大边数的两倍，如果是有向图，那么在建边的时候，只需要建一次即可，比如 $a$ 到 $b$ 有一条边，那么只需要 $add(a,b)$ ，不需要 $add(b,a)$ 对称建边</li>
<li>链式前向星（也称数组模拟邻接表）的数据结构为：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:第i个顶点的起始边编号,默认从-1开始</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[idx]:第idx条边的下一条边的编号</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[idx]:第idx条边指向的节点的编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，数组 $h$ 应被初始化为 $-1$ ，表示所有顶点的起始边编号是 $-1$ ，可以理解为头结点，因为采用的是头插法，如果顶点 $i$ 没有与其直接相连的边，那么 $h[i]&#x3D;-1$，如果顶点 $i$ 有与其直接相连的边，那么顶点 $i$ 的邻接表的最后一个元素是 $-1$</li>
</ul>
<blockquote>
<p>此处表格参考博客：<a href="https://blog.csdn.net/hnjzsyjyj/article/details/119895317">CSDN博客</a></p>
</blockquote>
<ol start="3">
<li>重点讲解链式前向星，假设现在有五条边<strong>有向边</strong>， $(1,4),\ (4,3),\ (1,2),\ (2,4),\ (1,3)$ ，对应执行 $add(1,4),\ add(4,3),\ add(1,2),\ add(2,4),\ add(1,3)$，我们手动模拟一下建边过程应该是这样的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建边(链式前向星)[头插法]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b; <span class="comment">// 第idx条边指向顶点b</span></span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 第idx条边的下一条边是顶点a的起始边[体现头插法思想]</span></span><br><span class="line">	h[a]=idx++; <span class="comment">// 顶点a的下一条边是第idx条边,编号+1以表示下一条边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">add(a,b)</th>
<th align="center">idx</th>
<th align="center">e[idx]&#x3D;b, ne[idx]&#x3D;h[a],h[a]&#x3D;idx++</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(1,4)</td>
<td align="center">1</td>
<td align="center">e[1]&#x3D;4, ne[1]&#x3D;h[1]&#x3D;-1, h[1]&#x3D;1, idx&#x3D;2</td>
</tr>
<tr>
<td align="center">(4,3)</td>
<td align="center">2</td>
<td align="center">e[2]&#x3D;3, ne[2]&#x3D;h[4]&#x3D;-1, h[4]&#x3D;2, idx&#x3D;3</td>
</tr>
<tr>
<td align="center">(1,2)</td>
<td align="center">3</td>
<td align="center">e[3]&#x3D;2, ne[3]&#x3D;h[1]&#x3D;1, h[1]&#x3D;3, idx&#x3D;4</td>
</tr>
<tr>
<td align="center">(2,4)</td>
<td align="center">4</td>
<td align="center">e[4]&#x3D;2, ne[4]&#x3D;h[2]&#x3D;-1, h[2]&#x3D;4, idx&#x3D;5</td>
</tr>
<tr>
<td align="center">(1,3)</td>
<td align="center">5</td>
<td align="center">e[5]&#x3D;3, ne[5]&#x3D;h[1]&#x3D;3, h[1]&#x3D;5, idx&#x3D;6</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>建边完成后，每个数组的情况应该是（下标均从 $0$ 开始）：</p>
<ul>
<li><p>$h&#x3D;[-1, 4, 3, -1, 1, -1]$</p>
</li>
<li><p>$ne&#x3D;[-1, -1, 0, -1, 2]$</p>
</li>
<li><p>$e&#x3D;[4, 3, 2, 4, 3]$</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>比如我们现在要输出与顶点 $1$ 直接相连的边，代码最终会输出 $3\ 2\ 4$，因为采用的是头插法，所以边的遍历顺序是 $(1,3),\ (1,2),\ (1,4)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// j初始化为顶点1的起始边,因为最后一条边的编号一定为-1(头插法),然后j通过ne数组迭代到下一条相连边的编号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=h[<span class="number">1</span>];j!=<span class="number">-1</span>;j=ne[j]) &#123;</span><br><span class="line">    cout&lt;&lt;e[j]&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">// e[j]:编号为j的边指向的顶点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>完整样例代码，注意代码中的模拟数据和前文不同，并且采用无向图建边，如果从无向图建边改为有向图建边前文已介绍</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路: 邻接表、链式前向星模板</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span><span class="number">+5</span>; <span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1e5</span><span class="number">+5</span>)*<span class="number">2</span>; <span class="comment">// 最大边数,因为无向图是双向建边,所以要*2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">// h[i]:第i个顶点的起始边编号,默认从-1开始</span></span><br><span class="line"><span class="type">int</span> ne[M]; <span class="comment">// ne[idx]:第idx条边的下一条边的编号</span></span><br><span class="line"><span class="type">int</span> e[M]; <span class="comment">// e[idx]:第idx条边指向的节点的编号</span></span><br><span class="line"><span class="type">int</span> idx; <span class="comment">// 边的编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建边(链式前向星)[头插法]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx]=b; <span class="comment">// 第idx条边指向顶点b</span></span><br><span class="line">	ne[idx]=h[a]; <span class="comment">// 第idx条边的下一条边是顶点a的起始边[体现头插法思想]</span></span><br><span class="line">	h[a]=idx++; <span class="comment">// 顶点a的下一条边是第idx条边,编号+1以表示下一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); <span class="comment">// 每个顶点的起始边编号初始化为-1</span></span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">add</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>),<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">add</span>(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">3</span>),<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>),<span class="built_in">add</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 遍历每个顶点,输出与其直接相邻的所有顶点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">		<span class="comment">// 从顶点i的起始边开始搜索,因为是头插,所以-1最终会变成最后一个边的编号,遇到则停止,通过ne数组迭代到下一条边的编号</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=h[i];j!=<span class="number">-1</span>;j=ne[j]) &#123;</span><br><span class="line">			s.<span class="built_in">push_back</span>(e[j]); <span class="comment">// e里面存储的是顶点编号</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;与顶点 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; 直接相连的顶点有:&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> item:s) cout&lt;&lt;item&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2024/10/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1><span id="高精度">高精度</span></h1><!-- toc -->

<ul>
<li><a href="#1-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%E9%AB%98%E7%B2%BE%E9%AB%98%E7%B2%BE">1. 高精度加法（高精+高精）</a></li>
<li><a href="#2-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95%E9%AB%98%E7%B2%BE-%E9%AB%98%E7%B2%BE">2. 高精度减法（高精-高精）</a></li>
<li><a href="#3-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95">3. 高精度乘法</a><ul>
<li><a href="#31-%E9%AB%98%E7%B2%BE%E4%BD%8E%E7%B2%BE">3.1. 高精×低精</a></li>
<li><a href="#32-%E9%AB%98%E7%B2%BE%E9%AB%98%E7%B2%BE">3.2. 高精×高精</a></li>
</ul>
</li>
<li><a href="#4-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95">4. 高精度除法</a><ul>
<li><a href="#41-%E9%AB%98%E7%B2%BE%E4%BD%8E%E7%B2%BE">4.1. 高精÷低精</a></li>
<li><a href="#42-%E9%AB%98%E7%B2%BE%E9%AB%98%E7%B2%BE">4.2. 高精÷高精</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="1-高精度加法高精高精">1. 高精度加法（高精+高精）</span></h2><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量,初始化每个元素都为0</span></span><br><span class="line"><span class="type">int</span> a[MAX_SIZE];</span><br><span class="line"><span class="type">int</span> b[MAX_SIZE];</span><br><span class="line"><span class="type">int</span> c[MAX_SIZE<span class="number">+1</span>]; <span class="comment">// 最多200+1位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 高精度加法问题</span></span><br><span class="line">	<span class="comment">// 输入大整数</span></span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> n1=s<span class="number">1.l</span>ength();</span><br><span class="line">	<span class="type">int</span> n2=s<span class="number">2.l</span>ength();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序存储大整数到数组中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		a[i]=s1[n1<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">		b[i]=s2[n2<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 模拟竖式加法进行计算</span></span><br><span class="line">	<span class="type">int</span> n3=<span class="built_in">max</span>(n1,n2)<span class="number">+1</span>; <span class="comment">// 最多再进一位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n3;i++) &#123;</span><br><span class="line">		c[i]+=a[i]+b[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i]/<span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">// c[i+1]+=c[i]/10; // 这里也可以改为c[i+1]+=1 因为最多也就9+9=18,进1位</span></span><br><span class="line">			c[i<span class="number">+1</span>]+=<span class="number">1</span>;</span><br><span class="line">			c[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[n3]==<span class="number">0</span> &amp;&amp; n3&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		n3--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n3;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>; <span class="comment">// 最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加引用是为了提高效率,没有引用的话会再copy一遍</span></span><br><span class="line"><span class="comment">// C=A+B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 保留上一位的进位</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// &quot;||&quot;保证了A和B谁的数位更高或更低都能计算</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || i&lt;B.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果最高位还要进位的话,就补个1</span></span><br><span class="line">	<span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> C=<span class="built_in">add</span>(A,B); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="2-高精度减法高精-高精">2. 高精度减法（高精-高精）</span></h2><blockquote>
<p>重点在于判定是A大还是B大</p>
</blockquote>
<ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="type">int</span> c[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 高精度减法两种情况</span></span><br><span class="line">	<span class="comment">// 输入大整数</span></span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> n1=s<span class="number">1.l</span>ength();</span><br><span class="line">	<span class="type">int</span> n2=s<span class="number">2.l</span>ength();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断哪个数字更大</span></span><br><span class="line">	<span class="keyword">if</span>(n1&lt;n2 || (n1==n2 &amp;&amp; s1&lt;s2)) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(s1,s2);</span><br><span class="line">		cout&lt;&lt;<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">		<span class="comment">// 如果交换了,n1和n2要更新一下</span></span><br><span class="line">		n1=s<span class="number">1.l</span>ength();</span><br><span class="line">		n2=s<span class="number">2.l</span>ength();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序存储,最后都用a-b</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		a[i]=s1[n1-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">		b[i]=s2[n2-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 竖式相减</span></span><br><span class="line">	<span class="type">int</span> n3=<span class="built_in">max</span>(n1,n2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n3;i++) &#123;</span><br><span class="line">		c[i]+=a[i]-b[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			c[i<span class="number">+1</span>]--;</span><br><span class="line">			c[i]+=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[n3]==<span class="number">0</span> &amp;&amp; n3&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		n3--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n3;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">			<span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明A==B,也是A&gt;=B的子集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C=A-B(A&gt;=B)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>; <span class="comment">// 保留进位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		t=A[i]-t;</span><br><span class="line">		<span class="comment">// 判断B[i]是否存在,因为B的位数可能比A更小</span></span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t-=B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>((t<span class="number">+10</span>)%<span class="number">10</span>); <span class="comment">// 如果t&gt;=0,则(t+10)%10=t;如果t&lt;0,则(t+10)%10变为正数</span></span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=<span class="number">1</span>; <span class="comment">// 借位,再算下一位的时候要多减去一个1</span></span><br><span class="line">		<span class="keyword">else</span> t=<span class="number">0</span>; <span class="comment">// 不借位</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去前导0(vector做高精加的话就不会出现前导0,相减的话可能出现003这种数字)</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B)) &#123;</span><br><span class="line">		<span class="keyword">auto</span> C=<span class="built_in">sub</span>(A,B);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> C=<span class="built_in">sub</span>(B,A);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-高精度乘法">3. 高精度乘法</span></h2><h3><span id="31-高精低精">3.1. 高精×低精</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> len1,len2;</span><br><span class="line"><span class="type">int</span> a[N],b,c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1||t;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=len1) t+=a[i]*b;</span><br><span class="line">		c[++len2]=t%<span class="number">10</span>;</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[len2]==<span class="number">0</span> &amp;&amp; len2&gt;<span class="number">1</span>) len2--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;str&gt;&gt;b;</span><br><span class="line">	len1=str.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++) a[i]=str[len1-i]-<span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将数a倒序</span></span><br><span class="line">	<span class="built_in">mul</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len2;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;c[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果有&quot;||t&quot;就不用单独处理剩余的t了,只要t不是0就会一直处理t的进位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || t;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i]*b;</span><br><span class="line">		C.<span class="built_in">push_back</span>(t%<span class="number">10</span>); <span class="comment">// 只取个位</span></span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理最后剩余的t</span></span><br><span class="line"><span class="comment">//	while(t) &#123;</span></span><br><span class="line"><span class="comment">//		C.push_back(t%10);</span></span><br><span class="line"><span class="comment">//		t/=10;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">// 为了避免1234*0=0000的这种情况,还是需要去除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C=<span class="built_in">mul</span>(A,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="32-高精高精">3.2. 高精×高精</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s1[MAXN];</span><br><span class="line"><span class="type">char</span> s2[MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="type">int</span> c[MAXN+MAXN]; <span class="comment">// 100(3)*100(3)=10000(6)</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 高精度乘法</span></span><br><span class="line">	<span class="comment">// 输入大整数</span></span><br><span class="line">	<span class="comment">// 这里如果用gets,在信奥一本通上无法通过</span></span><br><span class="line">	<span class="comment">// cin.getline(s1,MAXN);</span></span><br><span class="line">	<span class="comment">// cin.getline(s2,MAXN);</span></span><br><span class="line">	cin&gt;&gt;s1;</span><br><span class="line">	cin&gt;&gt;s2;</span><br><span class="line">	<span class="type">int</span> n1=<span class="built_in">strlen</span>(s1);</span><br><span class="line">	<span class="type">int</span> n2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		a[i]=s1[n1-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">		b[i]=s2[n2-i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 竖式乘法</span></span><br><span class="line">	<span class="type">int</span> n3=n1+n2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n2;j++) &#123;</span><br><span class="line">			c[i+j]+=a[i]*b[j];</span><br><span class="line">			<span class="keyword">if</span>(c[i+j]&gt;=<span class="number">10</span>) <span class="comment">// 说明要进位</span></span><br><span class="line">			&#123;</span><br><span class="line">				c[i+j<span class="number">+1</span>]+=c[i+j]/<span class="number">10</span>;</span><br><span class="line">				c[i+j]%=<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	// 处理进位问题</span></span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;n3;i++) &#123;</span></span><br><span class="line"><span class="comment">//		c[i+1]+=c[i]/10; </span></span><br><span class="line"><span class="comment">//		c[i]%=10;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 处理前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c[n3]==<span class="number">0</span> &amp;&amp; n3&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		n3--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逆序输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n3;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span> &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">C</span><span class="params">(A.size()+B.size(),<span class="number">0</span>)</span>; <span class="comment">// C最大数位为size_A+size_B,如100(3)×100(3)=10000(5)</span></span><br><span class="line">	<span class="comment">// 对C预开大小,是为了用类似于数组的方式来操控C</span></span><br><span class="line">	<span class="comment">// 因为A[i]要乘以每一位B[j]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.size();i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;B.size();j++) &#123;</span><br><span class="line">			C[i+j]+=A[i]*B[j];</span><br><span class="line">			<span class="comment">// 说明需要进位</span></span><br><span class="line">			<span class="keyword">if</span>(C[i+j]&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">				C[i+j+<span class="number">1</span>]+=C[i+j]/<span class="number">10</span>;</span><br><span class="line">				C[i+j]%=<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 去除前导0,因为开了大小为A.size()+B.size()的全为0的数组,有可能用不完这些空间</span></span><br><span class="line">	<span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back()==<span class="number">0</span>) C.pop_back();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">string</span> a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.push_back(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.push_back(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C=mul(A,B);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">cout</span>&lt;&lt;C[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="4-高精度除法">4. 高精度除法</span></h2><h3><span id="41-高精低精">4.1. 高精÷低精</span></h3><ul>
<li>基于数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e2</span><span class="number">+2</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N[maxn]; <span class="comment">// 存放大整数</span></span><br><span class="line"><span class="type">int</span> ans[maxn]; <span class="comment">// 存放商数</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">13</span>; <span class="comment">// 余数</span></span><br><span class="line"><span class="comment">// 高精度除以低精度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> n1=s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n1;i++) &#123;</span><br><span class="line">		ans[i]=(x*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>))/b; <span class="comment">// 记录余数</span></span><br><span class="line">		x=(x*<span class="number">10</span>+(s[i]-<span class="string">&#x27;0&#x27;</span>))%b; <span class="comment">// 余数继续参与计算</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去除ans的前导0</span></span><br><span class="line">	<span class="type">int</span> n2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ans[n2]==<span class="number">0</span> &amp;&amp; n2&lt;n1) &#123;</span><br><span class="line">		n2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印出商数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n2;i&lt;n1;i++) &#123;</span><br><span class="line">		cout&lt;&lt;ans[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 打印余数</span></span><br><span class="line">	cout&lt;&lt;x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传地址方便直接对余数r进行修改</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> B,<span class="type">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		r=r*<span class="number">10</span>+A[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(r/B); <span class="comment">// 商</span></span><br><span class="line">		r=r%B; <span class="comment">// 余数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 由于除法运算中高位到低位运算,因此C的前导0都在vector的前面而不是尾部</span></span><br><span class="line">	<span class="comment">// 所以反转C,这样0就位于数组尾部,从而用pop删除前导0</span></span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="type">int</span> B,r=<span class="number">0</span>; <span class="comment">// 代表余数</span></span><br><span class="line">	cin&gt;&gt;str&gt;&gt;B;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++) A.<span class="built_in">push_back</span>(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C=<span class="built_in">div</span>(A,B,r);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i]; <span class="comment">// 再逆序一遍变成正序</span></span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl; <span class="comment">// 余数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="42-高精高精">4.2. 高精÷高精</span></h3><blockquote>
<p>用数组模拟是非常麻烦的，这里只介绍基于STL库中的vector实现方法</p>
</blockquote>
<ul>
<li>基于STL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较A和B谁更大</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]!=B[i]) <span class="keyword">return</span> A[i]&gt;B[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用高精度减法来模拟高精度除法(高精÷高精)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||t;i++)&#123;</span><br><span class="line">		t = A[i] - t;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>((t<span class="number">+10</span>)%<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r:存储每次迭代后的余数</span></span><br><span class="line"><span class="comment">// C:存储每次返回后组成的商数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B, vector&lt;<span class="type">int</span>&gt; &amp;r)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C; </span><br><span class="line">	<span class="type">int</span> j = B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 比如12345÷67,j=2,那么初始余数就为45</span></span><br><span class="line">	r.<span class="built_in">assign</span>(A.<span class="built_in">end</span>()-j,A.<span class="built_in">end</span>()); <span class="comment">// 初始化余数r为A的最后j位</span></span><br><span class="line">	<span class="comment">// 当j小于等于A的长度时循环</span></span><br><span class="line">	<span class="keyword">while</span>(j&lt;=A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 当余数r大于等于B时循环</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">cmp</span>(r,B))&#123;</span><br><span class="line">			<span class="comment">// 利用高精减计算r-B的结果</span></span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; s = <span class="built_in">sub</span>(r,B);</span><br><span class="line">			r.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="comment">// 将结果赋值给r</span></span><br><span class="line">			r.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">			k++; <span class="comment">// 商+1</span></span><br><span class="line">		&#125; </span><br><span class="line">		C.<span class="built_in">push_back</span>(k); <span class="comment">// 存储商</span></span><br><span class="line">		<span class="comment">// 如果j小于A的长度,则将A中的下一位加入到余数r的最前面</span></span><br><span class="line">		<span class="keyword">if</span>(j&lt;A.<span class="built_in">size</span>()) r.<span class="built_in">insert</span>(r.<span class="built_in">begin</span>(),A[A.<span class="built_in">size</span>()-j<span class="number">-1</span>]);</span><br><span class="line">		<span class="comment">// 去掉余数0,因为随时要进行下一轮的计算</span></span><br><span class="line">		<span class="keyword">if</span>(r.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;r.<span class="built_in">back</span>()==<span class="number">0</span>) r.<span class="built_in">pop_back</span>();</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 反转结果,因为要利用高精减必须从低位开始</span></span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// 去掉前导0</span></span><br><span class="line">	<span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; A,B,r;</span><br><span class="line">	<span class="comment">// 逆序存储</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> C = <span class="built_in">div</span>(A,B,r);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
</search>
